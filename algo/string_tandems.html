<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Поиск всех тандемных повторов в строке алгоритмом Мейна-Лоренца (разделяй-и-властвуй)</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 6 Sep 2011 1:03<br>редактировано: 11 Feb 2012 15:03</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="string_tandems.html#" id="contents-hide">[скрыть]</a><a href="string_tandems.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Поиск всех тандемных повторов в строке. Алгоритм Мейна-Лоренца </h1><p>Дана строка <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">.<p><b>Тандемным повтором</b> (tandem repeat) в ней называются два вхождения какой-либо подстроки подряд. Иными словами, тандемный повтор описывается парой индексов <img class=tex src="../tex2png/cache/03d9ee6ff5dbf9f4d71c1efe94e10f6b.png" alt="i < j"> такими, что подстрока <img class=tex src="../tex2png/cache/1da9aede35685d45e082c44a363fe070.png" alt="s[i \ldots j]"> &mdash; это две одинаковые строки, записанные подряд.<p>Задача заключается в том, чтобы <b>найти все тандемные повторы</b>. Упрощённые варианты этой задачи: найти <b>любой</b> тандемный повтор или найти <b>длиннейший</b> тандемный повтор.<p><b>Примечание</b>. Во избежание путаницы все строки в статье мы будем считать 0-индексированными, т.е. первый символ строки имеет индекс 0.<p>Описываемый здесь алгоритм был опубликован в 1982 г. Мейном и Лоренцем (см. список литературы).<p><p><h2 style="padding-top:40px;"> Пример </h2><p>Рассмотрим тандемные повторы на примере какой-нибудь простой строки, например:<p><p class=formula><img class=tex src="../tex2png/cache/718049511256dedae436c32b061d8383.png" alt=" "acababaee" "></p><p>В этой строке присутствуют следующие тандемные повторы:<p><ul><li><img class=tex src="../tex2png/cache/96dfd93a56473b232c179ad47d4eab28.png" alt="[2;5] = "abab""><li><img class=tex src="../tex2png/cache/9002ac0f9d71d5eb8164c403fe88dea2.png" alt="[3;6] = "baba""><li><img class=tex src="../tex2png/cache/54a34b1c1d5bdaa0b3f3d5fda4db7d4c.png" alt="[7;8] = "ee""></ul><p>Другой пример:<p><p class=formula><img class=tex src="../tex2png/cache/4d3a3194344afa21b46e4b563fc85dd6.png" alt=" "abaaba" "></p><p>Здесь есть только два тандемных повтора:<p><ul><li><img class=tex src="../tex2png/cache/26fe4f1e4af725bcb76a39a3d96a28d5.png" alt="[0;5] = "abaaba""><li><img class=tex src="../tex2png/cache/1b01474b3b560ea6d3c5acf7ce80ee76.png" alt="[2;3] = "aa""></ul><p><p><h2 style="padding-top:40px;"> Число тандемных повторов </h2><p>Вообще говоря, тандемных повторов в строке длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> может быть порядка <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)">.<p>Очевидным примером является строка, составленная из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> одинаковых букв &mdash; в такой строке тандемным повтором является любая подстрока чётной длины, которых примерно <img class=tex src="../tex2png/cache/e3798b00ce9044a8c8877317c2dfb661.png" alt="n^2 / 4">. Вообще, любая периодичная строка с коротким периодом будет содержать очень много тандемных повторов<p>С другой стороны, сам по себе этот факт никак не препятствует существованию алгоритма с асимптотикой <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">, поскольку алгоритм может выдавать тандемные повторы в том или ином сжатом виде, группами по несколько штук сразу.<p>Более того, существует понятие <b>серий</b> &mdash; четвёрок чисел, которые описывают целую группу периодических подстрок. Было доказано, что число серий в любой строке линейно по отношению к длине строки.<p>Впрочем, описываемый ниже алгоритм не использует понятие серий, поэтому не будем детализировать это понятие.<p>Приведём здесь и другие интересные результаты, относящиеся к количеству тандемных повторов:<p><ul><p><li>Известно, что если рассматривать только примитивные тандемные повторы (т.е. такие, половинки которых не являются кратными строками), то их количество в любой строке &mdash; <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">.<p><li>Если кодировать тандемные повторы тройками чисел (называемыми тройками Крочемора (Crochemore)) <img class=tex src="../tex2png/cache/848a895f17b83ff8ff09cb04024051ae.png" alt="(i,p,r)"> (где <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> &mdash; позиция начала, <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> &mdash; длина повторяющейся подстроки, <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> &mdash; количество повторов), то все тандемные повторы любой строки можно вывести с помощью <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)"> таких троек. (Именно такой результат получается на выходе алгоритма Крочемора нахождения всех тандемных повторов.)<p><li>Строки Фибоначчи, определяемые следующим образом:<p><p class=formula><img class=tex src="../tex2png/cache/73a4b52dd331f14ed4bee1c71622b22b.png" alt=" t_0 = b, "><br><img class=tex src="../tex2png/cache/4988270bc10b27e41a679f1f453deb8c.png" alt=" t_1 = a, "><br><img class=tex src="../tex2png/cache/2a15f10c5b70a91ca555e6e599a99ceb.png" alt=" t_i = t_{i-1} + t_{i-2}, "></p><p>являются "сильно" периодичными.<p>Число тандемных повторов в <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой строке Фибоначчи длины <img class=tex src="../tex2png/cache/87fce7c1b08ec1bf7a0d6c116c4c586f.png" alt="f_i">, даже сжатых с помощью троек Крочемора, составляет <img class=tex src="../tex2png/cache/cdecb5d8567e801bb6144412b8292e6f.png" alt="O (f_n \log f_n)">.<p>Число примитивных тандемных повторов в строках Фибоначчи &mdash; также имеет порядок <img class=tex src="../tex2png/cache/cdecb5d8567e801bb6144412b8292e6f.png" alt="O (f_n \log f_n)">.<p></ul><p><p><h2 style="padding-top:40px;"> Алгоритм Мейна-Лоренца </h2><p>Идея алгоритма Мейна-Лоренца довольно стандартна: это алгоритм <b>"разделяй-и-властвуй"</b>.<p>Кратко он заключается в том, что исходная строка разбивается пополам, решение запускается от каждой из двух половинок по отдельности (тем самым мы найдём все тандемные повторы, располагающиеся только в первой или только во второй половинке). Дальше идёт самая сложная часть &mdash; это нахождение тандемных повторов, начинающихся в первой половине и заканчивающихся во второй (назовём такие тандемные повторы для удобства <b>пересекающими</b>). Как именно это делается &mdash; и есть сама суть алгоритма Мейна-Лоренца; это мы подробно опишем ниже.<p>Асимптотика алгоритма "разделяй-и-властвуй" хорошо исследована. В частности, для нас важно, что если мы научимся искать пересекающие тандемные повторы в строке длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">, то итоговая асимптотика всего алгоритма получится <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">.<p><p><h3 style="padding-top:15px;"> Поиск пересекающих тандемных повторов </h3><p>Итак, алгоритм Мейна-Лоренца свёлся к тому, чтобы по заданной строке <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> научиться искать все пересекающие тандемные повторы, т.е. такие, которые начинаются в первой половине строки, а заканчиваются &mdash; во второй.<p>Обозначим через <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> и <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> две половинки строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">:<p><p class=formula><img class=tex src="../tex2png/cache/bf9aeb574d46ba7b440b712cd2005274.png" alt=" s = u + v "></p><p>(их длины примерно равны длине строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, делённой пополам).<p><p><h4> Правые и левые тандемные повторы </h4><p>Рассмотрим произвольный тандемный повтор и посмотрим на его средний символ (точнее, на тот символ, с которого начинается вторая половинка тандема; т.е. если тандемный повтор &mdash; это подстрока <img class=tex src="../tex2png/cache/1da9aede35685d45e082c44a363fe070.png" alt="s[i \ldots j]">, то средним символом будет <img class=tex src="../tex2png/cache/f93a0b741268a5f6d415ce3d3be80f67.png" alt="(i+j+1)/2">.<p>Тогда назовём тандемный повтор <b>левым или правым</b> в зависимости от того, где находится этот символ &mdash; в строке <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> или в строке <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. (Можно сказать и так: тандемный повтор называется левым, если большая его часть лежит в левой половине строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">; иначе &mdash; тандемный повтор называется правым.)<p>Научимся искать <b>все левые тандемные повторы</b>; для правых всё будет аналогично.<p><p><h4> Центральная позиция <img class=tex src="../tex2png/cache/5c212b117541b1035e5cb8562641fe42.png" alt="cntr"> тандемного повтора </h4><p>Обозначим длину искомого левого тандемного повтора через <img class=tex src="../tex2png/cache/3650ed0a6fb5ffca4bb59efafb0d59b5.png" alt="2k"> (т.е. длина каждой половинки тандемного повтора &mdash; это <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">). Рассмотрим первый символ тандемного повтора, попадающий в строку <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> (он стоит в строке <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> в позиции <img class=tex src="../tex2png/cache/2e3307503b18e0fdd16886a383eed716.png" alt="length(u)">). Он совпадает с символом, стоящим на <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> позиций раньше него; обозначим эту позицию через <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr">.<p><b>Искать все тандемные повторы мы будем, перебирая эту позицию <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr"></b>: т.е. найдём сначала все тандемные повторы с одним значением <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr">, затем с другим значением, и т.д. &mdash; перебирая все возможные значения <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr"> от <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0"> до <img class=tex src="../tex2png/cache/eadaadbbf191197b314321bfb6d51b70.png" alt="length(u)-1">.<p><b>Например</b>, рассмотрим такую строку:<p><p class=formula><img class=tex src="../tex2png/cache/190fffbdb5b78b13f0c64390eaa2b942.png" alt=" s = "cac|ada" "></p><p>(символ вертикальной черты разделяет две половинки <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> и <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">)<p>Тандемный повтор <img class=tex src="../tex2png/cache/50994313d97974e1cd2794eb84638ca9.png" alt=""caca"">, содержащийся в этой строке, будет обнаружен, когда мы будем просматривать значение <img class=tex src="../tex2png/cache/3c2d56648f967b25ffcca9339d3678b3.png" alt="cntr = 1"> &mdash; потому что именно в позиции <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"> стоит символ 'a', совпадающий с первым символом тандемного повтора, попавшим в половинку <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">.<p><p><h4> Критерий наличия тандемного повтора с заданным центром <img class=tex src="../tex2png/cache/5c212b117541b1035e5cb8562641fe42.png" alt="cntr"> </h4><p>Итак, мы должны научиться для зафиксированного значения <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr"> быстро искать все тандемные повторы, соответствующие ему.<p>Получаем такую схему (для абстрактной строки, в которой содержится тандемный повтор <img class=tex src="../tex2png/cache/3e373fcee872b87fcee6b4938e421d82.png" alt=""abcabc"">):<p><p class=formula><img class=tex src="../tex2png/cache/a529c4b726c970b9b906923e55f9dc95.png" alt="
\setlength{\unitlength}{2mm}

\begin{picture}([...]"></p><p>Здесь через <img class=tex src="../tex2png/cache/91bfa45247ac88d05f75403d6ecb5d68.png" alt="l_1"> и <img class=tex src="../tex2png/cache/999b7ef5ab10bdfeecdbbdc720766fb4.png" alt="l_2"> мы обозначили длины двух кусочков тандемного повтора: <img class=tex src="../tex2png/cache/91bfa45247ac88d05f75403d6ecb5d68.png" alt="l_1"> &mdash; это длина части тандемного повтора до позиции <img class=tex src="../tex2png/cache/5c24a696fb1666c8050cdbf185d0dbcb.png" alt="cntr-1">, а <img class=tex src="../tex2png/cache/999b7ef5ab10bdfeecdbbdc720766fb4.png" alt="l_2"> &mdash; это длина части тандемного повтора от <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr"> до конца половинки тандемного повтора. Таким образом, <img class=tex src="../tex2png/cache/a0523bad6eb08d1f11a6b4da750b46d2.png" alt="l_1+l_2+l_1+l_2"> &mdash; это длина тандемного повтора.<p>Взглянув на эту картинку, можно понять, что <b>необходимое и достаточное</b> условие того, что с центром в позиции <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr"> находится тандемный повтор длины <img class=tex src="../tex2png/cache/ba444e07ef7c1e3aa99d8a858291995d.png" alt="2 l = 2 (l_1 + l_2) = 2 (length(u) - cntr)">, является следующее условие:<p><ul><p><li>Пусть <img class=tex src="../tex2png/cache/2b3831d7d2edca0658a067b684887d60.png" alt="k_1"> &mdash; это наибольшее число такое, что <img class=tex src="../tex2png/cache/2b3831d7d2edca0658a067b684887d60.png" alt="k_1"> символов перед позицией <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr"> совпадают с последними <img class=tex src="../tex2png/cache/2b3831d7d2edca0658a067b684887d60.png" alt="k_1"> символами строки <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">:<p><p class=formula><img class=tex src="../tex2png/cache/3f98ee8fe36063d92279a2b68f7f8983.png" alt=" u[ cntr-k_1 \ldots cntr-1 ] == u[ length(u)-k_1 \[...]"></p><p><li>Пусть <img class=tex src="../tex2png/cache/daa41655761beb69365ffeafd21fc329.png" alt="k_2"> &mdash; это наибольшее число такое, что <img class=tex src="../tex2png/cache/daa41655761beb69365ffeafd21fc329.png" alt="k_2"> символов, начиная с позиции <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr">, совпадают с первыми <img class=tex src="../tex2png/cache/daa41655761beb69365ffeafd21fc329.png" alt="k_2"> символами строки <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">:<p><p class=formula><img class=tex src="../tex2png/cache/1d2f6fd25bd316d8b47cafad09f647b6.png" alt=" u[ cntr \ldots cntr+k_2-1] == v[ 0 \ldots k_2-1 ][...]"></p><p><li>Тогда должно выполняться:<p><p class=formula><img class=tex src="../tex2png/cache/1c20a6fda644c2cddcfb2a9ce70c2ced.png" alt=" \cases{
l_1 \le k_1, \cr
l_2 \le k_2.
} "></p><p></ul><p>Этот критерий можно <b>переформулировать</b> таким образом. Зафиксируем конкретное значение <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr">, тогда:<p><ul><p><li>Все тандемные повторы, которые мы будем сейчас обнаруживать, будут иметь длину <img class=tex src="../tex2png/cache/38db0c554c0cffc529cef077d225630b.png" alt="2 l = 2 (length(u) - cntr)">.<p>Однако таких тандемных повторов может быть <b>несколько</b>: всё зависит от выбора длин кусочков <img class=tex src="../tex2png/cache/91bfa45247ac88d05f75403d6ecb5d68.png" alt="l_1"> и <img class=tex src="../tex2png/cache/2185eb13811908d291a7f7179f70c689.png" alt="l_2 = l - l_1">.<p><li>Найдём <img class=tex src="../tex2png/cache/2b3831d7d2edca0658a067b684887d60.png" alt="k_1"> и <img class=tex src="../tex2png/cache/daa41655761beb69365ffeafd21fc329.png" alt="k_2">, как было описано выше.<p><li>Тогда подходящими будут являться тандемные повторы, для которых длины кусочков <img class=tex src="../tex2png/cache/91bfa45247ac88d05f75403d6ecb5d68.png" alt="l_1"> и <img class=tex src="../tex2png/cache/999b7ef5ab10bdfeecdbbdc720766fb4.png" alt="l_2"> удовлетворяют условиям:<p><p class=formula><img class=tex src="../tex2png/cache/0542c84c9290c37770ba709e7ed6b13c.png" alt=" \cases{
l_1 + l_2 = l = length(u) - cntr, \cr
l[...]"></p><p></ul><p><p><h4> Алгоритм нахождения длин <img class=tex src="../tex2png/cache/336b54d07234a59813975f30ae9ddf8c.png" alt="k_1"> и <img class=tex src="../tex2png/cache/8d887298ab37b0c1f9c458a50eba0ef9.png" alt="k_2"> </h4><p>Итак, вся задача сводится к быстрому вычислению длин <img class=tex src="../tex2png/cache/2b3831d7d2edca0658a067b684887d60.png" alt="k_1"> и <img class=tex src="../tex2png/cache/daa41655761beb69365ffeafd21fc329.png" alt="k_2"> для каждого значения <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr">.<p>Напомним их определения:<p><ul><p><li><img class=tex src="../tex2png/cache/2b3831d7d2edca0658a067b684887d60.png" alt="k_1"> &mdash; максимальное неотрицательное число, для которого выполнено:<p><p class=formula><img class=tex src="../tex2png/cache/3f98ee8fe36063d92279a2b68f7f8983.png" alt=" u[ cntr-k_1 \ldots cntr-1 ] == u[ length(u)-k_1 \[...]"></p><p><li><img class=tex src="../tex2png/cache/daa41655761beb69365ffeafd21fc329.png" alt="k_2"> &mdash; максимальное неотрицательное число, для которого выполнено:<p><p class=formula><img class=tex src="../tex2png/cache/1d2f6fd25bd316d8b47cafad09f647b6.png" alt=" u[ cntr \ldots cntr+k_2-1] == v[ 0 \ldots k_2-1 ][...]"></p><p></ul><p>На оба этих запроса можно отвечать за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)">, используя <b><a href="z_function.html">алгоритм нахождения Z-функции</b></a>:<p><ul><p><li>Для быстрого нахождения значений <img class=tex src="../tex2png/cache/2b3831d7d2edca0658a067b684887d60.png" alt="k_1"> заранее посчитаем Z-функцию для строки <img class=tex src="../tex2png/cache/cd092f628acb2e5fd89348f0944c5d0b.png" alt="\overline{u}"> (т.е. строки <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">, выписанной в обратном порядке).<p>Тогда значение <img class=tex src="../tex2png/cache/2b3831d7d2edca0658a067b684887d60.png" alt="k_1"> для конкретного <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr"> будет просто равно соответствующему значению массива Z-функции.<p><li>Для быстрого нахождения значений <img class=tex src="../tex2png/cache/daa41655761beb69365ffeafd21fc329.png" alt="k_2"> заранее посчитаем Z-функцию для строки <img class=tex src="../tex2png/cache/e7b31f6e1fa33c6b9540b1bbdcd95bac.png" alt="v+\#+u"> (т.е. строки <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">, приписанной к строке <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> через символ-разделитель).<p>Опять же, значение <img class=tex src="../tex2png/cache/daa41655761beb69365ffeafd21fc329.png" alt="k_2"> для конкретного <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr"> надо будет просто взять из соответствующего элемента Z-функции.<p></ul><p><p><h4> Поиск правых тандемных повторов </h4><p>До этого момента мы работали только с левыми тандемными повторами.<p>Чтобы искать правые тандемные повторы, надо действовать аналогично: мы определяем центр <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr"> как символ, соответствующий последнему символу тандемного повтора, попавшему в первую строку.<p>Тогда длина <img class=tex src="../tex2png/cache/2b3831d7d2edca0658a067b684887d60.png" alt="k_1"> будет определяться как наибольшее число символов до позиции <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr"> включительно, совпадающих с последними символами строки <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">. Длина <img class=tex src="../tex2png/cache/daa41655761beb69365ffeafd21fc329.png" alt="k_2"> будет определяться как максимальное число символов, начиная с <img class=tex src="../tex2png/cache/85409ffc24855612e96931e9016029ac.png" alt="cntr+1">, совпадающих с первыми символами строки <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">.<p>Таким образом, для быстрого нахождения <img class=tex src="../tex2png/cache/2b3831d7d2edca0658a067b684887d60.png" alt="k_1"> и <img class=tex src="../tex2png/cache/daa41655761beb69365ffeafd21fc329.png" alt="k_2"> надо будет посчитать заранее Z-функцию для строк <img class=tex src="../tex2png/cache/69e8aed02216f4d869e4e775c986f5f2.png" alt="\overline{u} + \# + \overline{v}"> и <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> соответственно. После этого, перебирая конкретное значение <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr">, мы по тому же самому критерию будем находить все правые тандемные повторы.<p><p><h4> Асимптотика </h4><p>Асмиптотика алгоритма Мейна-Лоренца составит, таким образом, <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">: поскольку этот алгоритм представляет собой алгоритм "разделяй-и-властвуй", каждый рекурсивный запуск которого работает за время, линейное относительно длины строки: для четырёх строк за линейное время ищется их <a href="z_function.html">Z-функция</a>, а затем перебирается значение <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr"> и выводятся все группы обнаруженных тандемных повторов.<p>Тандемные повторы обнаруживаются алгоритмом Мейна-Лоренца в виде своеобразных <b>групп</b>: таких четвёрок <img class=tex src="../tex2png/cache/2d2900c8ae43ba5835e2c2751cea3ed4.png" alt="(cntr, l, k_1, k_2)">, каждая из которых обозначает группу тандемных повторов с длиной <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l">, центром <img class=tex src="../tex2png/cache/9834656610155cafb07a4ab9f3107cd4.png" alt="cntr"> и с всевозможными длинами кусочков <img class=tex src="../tex2png/cache/91bfa45247ac88d05f75403d6ecb5d68.png" alt="l_1"> и <img class=tex src="../tex2png/cache/999b7ef5ab10bdfeecdbbdc720766fb4.png" alt="l_2">, удовлетворяющими условиям:<p><p class=formula><img class=tex src="../tex2png/cache/9d483eb0edf474e5b4fe7bed08d21038.png" alt=" \cases{
l_1 + l_2 = l, \cr
l_1 \le k_1, \cr
l_[...]"><p><p></p><p><h2 style="padding-top:40px;"> Реализация </h2><p>Приведём реализацию алгоритма Мейна-Лоренца, которая за время <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)"> находит все тандемные повторы данной строки в сжатом виде (в виде групп, описываемых четвёрками чисел).<p>В целях демонстрации обнаруженные тандемные повторы за время <img class=tex src="../tex2png/cache/4cd2772b06262896a7cf8a9d3c989ea4.png" alt="O (n^2)"> "разжимаются" и выводятся по отдельности. Этот вывод при решении реальных задач легко будет заменить на какие-то другие, более эффективные, действия, например, на поиск наидлиннейшего тандемного повтора или подсчёт количества тандемных повторов.<p><pre class="notranslate cpp">vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> z_function <span class="br0">&#40;</span><span class="kw4">const</span> string <span class="sy3">&amp;</span> s<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> s.<span class="me1">length</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> z <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span>, l<span class="sy1">=</span><span class="nu0">0</span>, r<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy1">&lt;=</span> r<span class="br0">&#41;</span>
			z<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> min <span class="br0">&#40;</span>r<span class="sy2">-</span>i<span class="sy2">+</span><span class="nu0">1</span>, z<span class="br0">&#91;</span>i<span class="sy2">-</span>l<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">while</span> <span class="br0">&#40;</span>i<span class="sy2">+</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&lt;</span> n <span class="sy3">&amp;&amp;</span> s<span class="br0">&#91;</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">==</span> s<span class="br0">&#91;</span>i<span class="sy2">+</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#41;</span>
			<span class="sy2">++</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>i<span class="sy2">+</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy2">-</span><span class="nu0">1</span> <span class="sy1">&gt;</span> r<span class="br0">&#41;</span>
			l <span class="sy1">=</span> i,  r <span class="sy1">=</span> i<span class="sy2">+</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> z<span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> output_tandem <span class="br0">&#40;</span><span class="kw4">const</span> string <span class="sy3">&amp;</span> s, <span class="kw4">int</span> shift, <span class="kw4">bool</span> left, <span class="kw4">int</span> cntr, <span class="kw4">int</span> l, <span class="kw4">int</span> l1, <span class="kw4">int</span> l2<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> pos<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>left<span class="br0">&#41;</span>
		pos <span class="sy1">=</span> cntr<span class="sy2">-</span>l1<span class="sy4">;</span>
	<span class="kw1">else</span>
		pos <span class="sy1">=</span> cntr<span class="sy2">-</span>l1<span class="sy2">-</span>l2<span class="sy2">-</span>l1<span class="sy2">+</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;[&quot;</span> <span class="sy1">&lt;&lt;</span> shift <span class="sy2">+</span> pos <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;..&quot;</span> <span class="sy1">&lt;&lt;</span> shift <span class="sy2">+</span> pos<span class="sy2">+</span><span class="nu0">2</span><span class="sy2">*</span>l<span class="sy2">-</span><span class="nu0">1</span> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;] = &quot;</span> <span class="sy1">&lt;&lt;</span> s.<span class="me1">substr</span> <span class="br0">&#40;</span>pos, <span class="nu0">2</span><span class="sy2">*</span>l<span class="br0">&#41;</span> <span class="sy1">&lt;&lt;</span> endl<span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> output_tandems <span class="br0">&#40;</span><span class="kw4">const</span> string <span class="sy3">&amp;</span> s, <span class="kw4">int</span> shift, <span class="kw4">bool</span> left, <span class="kw4">int</span> cntr, <span class="kw4">int</span> l, <span class="kw4">int</span> k1, <span class="kw4">int</span> k2<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> l1<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> l1<span class="sy1">&lt;=</span>l<span class="sy4">;</span> <span class="sy2">++</span>l1<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>left <span class="sy3">&amp;&amp;</span> l1 <span class="sy1">==</span> l<span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>l1 <span class="sy1">&lt;=</span> k1 <span class="sy3">&amp;&amp;</span> l<span class="sy2">-</span>l1 <span class="sy1">&lt;=</span> k2<span class="br0">&#41;</span>
			output_tandem <span class="br0">&#40;</span>s, shift, left, cntr, l, l1, l<span class="sy2">-</span>l1<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">inline</span> <span class="kw4">int</span> get_z <span class="br0">&#40;</span><span class="kw4">const</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> z, <span class="kw4">int</span> i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy1">&lt;=</span>i <span class="sy3">&amp;&amp;</span> i<span class="sy1">&lt;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>z.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy4">?</span> z<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy4">:</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> find_tandems <span class="br0">&#40;</span>string s, <span class="kw4">int</span> shift <span class="sy1">=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> s.<span class="me1">length</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>n <span class="sy1">==</span> <span class="nu0">1</span><span class="br0">&#41;</span>  <span class="kw1">return</span><span class="sy4">;</span>
&nbsp;
	<span class="kw4">int</span> nu <span class="sy1">=</span> n<span class="sy2">/</span><span class="nu0">2</span>,  nv <span class="sy1">=</span> n<span class="sy2">-</span>nu<span class="sy4">;</span>
	string u <span class="sy1">=</span> s.<span class="me1">substr</span> <span class="br0">&#40;</span><span class="nu0">0</span>, nu<span class="br0">&#41;</span>,
		v <span class="sy1">=</span> s.<span class="me1">substr</span> <span class="br0">&#40;</span>nu<span class="br0">&#41;</span><span class="sy4">;</span>
	string ru <span class="sy1">=</span> string <span class="br0">&#40;</span>u.<span class="me1">rbegin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, u.<span class="me1">rend</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>,
		rv <span class="sy1">=</span> string <span class="br0">&#40;</span>v.<span class="me1">rbegin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, v.<span class="me1">rend</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	find_tandems <span class="br0">&#40;</span>u, shift<span class="br0">&#41;</span><span class="sy4">;</span>
	find_tandems <span class="br0">&#40;</span>v, shift <span class="sy2">+</span> nu<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> z1 <span class="sy1">=</span> z_function <span class="br0">&#40;</span>ru<span class="br0">&#41;</span>,
		z2 <span class="sy1">=</span> z_function <span class="br0">&#40;</span>v <span class="sy2">+</span> <span class="st0">'#'</span> <span class="sy2">+</span> u<span class="br0">&#41;</span>,
		z3 <span class="sy1">=</span> z_function <span class="br0">&#40;</span>ru <span class="sy2">+</span> <span class="st0">'#'</span> <span class="sy2">+</span> rv<span class="br0">&#41;</span>,
		z4 <span class="sy1">=</span> z_function <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> cntr<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> cntr<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>cntr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> l, k1, k2<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>cntr <span class="sy1">&lt;</span> nu<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			l <span class="sy1">=</span> nu <span class="sy2">-</span> cntr<span class="sy4">;</span>
			k1 <span class="sy1">=</span> get_z <span class="br0">&#40;</span>z1, nu<span class="sy2">-</span>cntr<span class="br0">&#41;</span><span class="sy4">;</span>
			k2 <span class="sy1">=</span> get_z <span class="br0">&#40;</span>z2, nv<span class="sy2">+</span><span class="nu0">1</span><span class="sy2">+</span>cntr<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
		<span class="kw1">else</span> <span class="br0">&#123;</span>
			l <span class="sy1">=</span> cntr <span class="sy2">-</span> nu <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
			k1 <span class="sy1">=</span> get_z <span class="br0">&#40;</span>z3, nu<span class="sy2">+</span><span class="nu0">1</span> <span class="sy2">+</span> nv<span class="sy2">-</span><span class="nu0">1</span><span class="sy2">-</span><span class="br0">&#40;</span>cntr<span class="sy2">-</span>nu<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
			k2 <span class="sy1">=</span> get_z <span class="br0">&#40;</span>z4, <span class="br0">&#40;</span>cntr<span class="sy2">-</span>nu<span class="br0">&#41;</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>k1 <span class="sy2">+</span> k2 <span class="sy1">&gt;=</span> l<span class="br0">&#41;</span>
			output_tandems <span class="br0">&#40;</span>s, shift, cntr<span class="sy1">&lt;</span>nu, cntr, l, k1, k2<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p><p><h2 style="padding-top:40px;"> Литература </h2><p><ul><p><li><a href="http://www.cs.colorado.edu/department/publications/reports/docs/CU-CS-241-82.pdf">Michael Main, Richard J. Lorentz. <b>An O (n log n) Algorithm for Finding All Repetitions in a String</b> [1982]</a><p><li>Bill Smyth. <b>Computing Patterns in Strings</b> [2003]<p><li>Билл Смит. <b>Методы и алгоритмы вычислений на строках</b> [2006]<p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>