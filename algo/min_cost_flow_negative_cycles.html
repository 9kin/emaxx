<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Поток минимальной стоимости, циркуляция минимальной стоимости</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2009 21:03<br>редактировано: 24 May 2016 5:41</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="min_cost_flow_negative_cycles.html#" id="contents-hide">[скрыть]</a><a href="min_cost_flow_negative_cycles.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Поток минимальной стоимости, циркуляция минимальной стоимости. Алгоритм удаления циклов отрицательного веса</h1><p><h2 style="padding-top:40px;">Постановка задач</h2><p>Пусть <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> &mdash; сеть (network), то есть ориентированный граф, в котором выбраны вершины-исток <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> и сток <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">. Множество вершин обозначим через <img class=tex src="../tex2png/cache/f4727a593e3ecb8bea258213a2ce0988.png" alt="V">, множество рёбер &mdash; через <img class=tex src="../tex2png/cache/75014114e5532780acf8715ec0ab6829.png" alt="E">. Каждому ребру <img class=tex src="../tex2png/cache/8935962905b8cd99226ff9c8f6387ce6.png" alt="(i,j) \in E"> сопоставлены его пропускная способность <img class=tex src="../tex2png/cache/442703db6c5f38d2cdd9f5fab9a1ff1f.png" alt="u_{ij} \ge 0"> и стоимость единицы потока <img class=tex src="../tex2png/cache/7b464f5d1d51ec98050cfa73f5387499.png" alt="c_{ij}">. Если какого-то ребра <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)"> в графе нет, то предполагается, что <img class=tex src="../tex2png/cache/6544081963708d85c2492cee588ed8c4.png" alt="u_{ij} = c_{ij} = 0">.<p><b>Потоком</b> (flow) в сети <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> называется такая действительнозначная функция <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f">, сопоставляющая каждой паре вершин <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)"> поток <img class=tex src="../tex2png/cache/c43a7b46cc57574be143004753745fb8.png" alt="f_{ij}"> между ними, и удовлетворяющая трём условиям:<p><ul><li>Ограничение пропускной способности (выполняется для любых <img class=tex src="../tex2png/cache/1766412fb7b388873acfb5c638a3180e.png" alt="i, j \in V">):<p class=formula><img class=tex src="../tex2png/cache/a5eb20cc7cf3b06aaee1863f63abe07a.png" alt=" f_{ij} \le u_{ij} "></p><li>Антисимметричность (выполняется для любых <img class=tex src="../tex2png/cache/1766412fb7b388873acfb5c638a3180e.png" alt="i, j \in V">):<p class=formula><img class=tex src="../tex2png/cache/fc8a4e0a38b849296132a6178ca52316.png" alt=" f_{ij} = - f_{ji} "></p><li>Сохранение потока (выполняется для любых <img class=tex src="../tex2png/cache/31785fdc3f8c2c86500f6ba5ac7a1e0d.png" alt="i \in V">, кроме <img class=tex src="../tex2png/cache/defe760e4a116a0afa76f6917b1618bf.png" alt="i=s">, <img class=tex src="../tex2png/cache/45c15fca631c049e38159e5e7a6e18ca.png" alt="i=t">):<p class=formula><img class=tex src="../tex2png/cache/8ba0a267ab11713a074ced31fbfae88a.png" alt=" \sum_{j \in V} f_{ij} = 0 "></p></ul><p>Величиной потока называется величина<p class=formula><img class=tex src="../tex2png/cache/a29420be911879c50522102c353d7347.png" alt=" |f| = \sum_{i \in V} f_{si} "></p><p>Стоимостью потока называется величина<p class=formula><img class=tex src="../tex2png/cache/5b9fbc1578c4c9238108b9d2979ff7e1.png" alt=" z(f) = \sum_{i,j \in V} c_{ij} f_{ij} "></p><p>Задача нахождения <b>потока минимальной стоимости</b> заключается в том, что по заданной величине потока <img class=tex src="../tex2png/cache/2497fc7a3c521f6d55927458761ec88b.png" alt="|f|"> требуется найти поток, обладающий минимальной стоимостью <img class=tex src="../tex2png/cache/54c3d941d44f846827b2367f945fad79.png" alt="z(f)">. Стоит обратить внимание на то, что стоимости <img class=tex src="../tex2png/cache/7b464f5d1d51ec98050cfa73f5387499.png" alt="c_{ij}">, приписанные рёбрам, отвечают за стоимость единицы потока вдоль этого ребра; иногда встречается задача, когда рёбрам сопоставляются стоимости протекания потока вдоль этого ребра (т.е. если протекает поток любой величины, то взимается эта стоимость, независимо от величины потока) &mdash; эта задача не имеет ничего общего с рассматриваемой здесь и, более того, является NP-полной.<p>Задача нахождения <b>максимального потока минимальной стоимости</b> заключается в том, чтобы найти поток наибольшей величины, а среди всех таких &mdash; с минимальной стоимостью. В частном случае, когда веса всех рёбер одинаковы, эта задача становится эквивалентной обычной задаче о максимальном потоке.<p>Задача нахождения <b>циркуляции минимальной стоимости</b> заключается в том, чтобы найти поток нулевой величины с минимальной стоимостью. Если все стоимости неотрицательные, то, понятно, ответом будет нулевой поток <img class=tex src="../tex2png/cache/9e81d78ea2ddbd0dc702a4758459e204.png" alt="f_{ij}=0">; если же есть рёбра отрицательного веса (а, точнее, циклы отрицательного веса), то даже при нулевом потоке возможно найти поток отрицательной стоимости. Задачу нахождения циркуляции минимальной стоимости можно, разумеется, поставить и на сети без истока и стока, поскольку никакой смысловой нагрузки они не несут (впрочем, в такой граф можно добавить исток и сток в виде изолированных вершин и получить обычную по формулировке задачу). Иногда ставится задача нахождения циркуляции максимальной стоимости &mdash; понятно, достаточно изменить стоимости рёбер на противоположные и получим задачу нахождения циркуляции уже минимальной стоимости.<p>Все эти задачи, разумеется, можно перенести и на неориентированные графы. Впрочем, перейти от неориентированного графа к ориентированному легко: каждое неориентированное ребро <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)"> с пропускной способностью <img class=tex src="../tex2png/cache/3b8a07f04173dcd090bcba89262165b1.png" alt="u_{ij}"> и стоимостью <img class=tex src="../tex2png/cache/7b464f5d1d51ec98050cfa73f5387499.png" alt="c_{ij}"> следует заменить двумя ориентированными рёбрами <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)"> и <img class=tex src="../tex2png/cache/e3bb5b2142823f74abc1f67c25b7879e.png" alt="(j,i)"> с одинаковыми пропускными способностями и стоимостями.<p><h2 style="padding-top:40px;">Остаточная сеть</h2><p>Концепция <b>остаточной сети</b> <img class=tex src="../tex2png/cache/244f6ff593781082c3e5f177714595e0.png" alt="G^f"> основана на следующей простой идее. Пусть есть некоторый поток <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f">; вдоль каждого ребра <img class=tex src="../tex2png/cache/8935962905b8cd99226ff9c8f6387ce6.png" alt="(i,j) \in E"> протекает некоторый поток <img class=tex src="../tex2png/cache/61d0c3089d729762b3735ddaaf330d5f.png" alt="f_{ij} \le u_{ij}">. Тогда вдоль этого ребра можно (теоретически) пустить ещё <img class=tex src="../tex2png/cache/25975191f28da113748980e0dd2ea3df.png" alt="u_{ij} - f_{ij}"> единиц потока; эту величину и назовём <b>остаточной пропускной способностью</b>:<p class=formula><img class=tex src="../tex2png/cache/0f57d5bc1ac9ee36bb4838e29fc108fb.png" alt=" r_{ij}^f = u_{ij} - f_{ij} "></p>Стоимость этих дополнительных единиц потока будет такой же:<p class=formula><img class=tex src="../tex2png/cache/e81c34ee9b0a3fe86cba81f0abec92b9.png" alt=" c_{ij}^f = c_{ij} "></p><p>Однако помимо этого, <b>прямого</b> ребра <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)">, в остаточной сети <img class=tex src="../tex2png/cache/244f6ff593781082c3e5f177714595e0.png" alt="G^f"> появляется и <b>обратное ребро</b> <img class=tex src="../tex2png/cache/e3bb5b2142823f74abc1f67c25b7879e.png" alt="(j,i)">. Интуитивный смысл этого ребра в том, что мы можем в будущем отменить часть потока, протекавшего по ребру <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)">. Соответственно, пропускание потока вдоль этого обратного ребра <img class=tex src="../tex2png/cache/e3bb5b2142823f74abc1f67c25b7879e.png" alt="(j,i)"> фактически, и формально, означает уменьшение потока вдоль ребра <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)">. Обратное ребро имеет пропускную способность, равную нулю (чтобы, например, при <img class=tex src="../tex2png/cache/9e81d78ea2ddbd0dc702a4758459e204.png" alt="f_{ij}=0"> и по обратному ребру невозможно было бы пропустить поток; при положительной величине <img class=tex src="../tex2png/cache/95c56ab7320d4d4177424ebfed744c4a.png" alt="f_{ij}>0"> для обратного ребра по свойству антисимметричности станет <img class=tex src="../tex2png/cache/dc79325099351ef9f5bd11f53231d501.png" alt="f_{ji}<0">, что меньше <img class=tex src="../tex2png/cache/7e9ebd0ad0873122cfc8f4faa1ab31dd.png" alt="c_{ji}^f = 0">, т.е. можно будет пропускать какой-то поток вдоль обратного ребра), остаточную пропускную способность &mdash; равную потоку вдоль прямого ребра, а стоимость &mdash; противоположную (ведь после отмены части потока мы должны соответственно уменьшить и стоимость):<p class=formula><img class=tex src="../tex2png/cache/cf33ec586976c5408652b669e1df2b31.png" alt=" u_{ji}^f = 0 "><br><img class=tex src="../tex2png/cache/844a67ed5130160ac1c34fa0d9774165.png" alt=" r_{ji}^f = f_{ij} "><br><img class=tex src="../tex2png/cache/33da1870fb391d1a4fc10dedebdaf22c.png" alt=" c_{ji}^f = -c_{ij} "></p><p>Таким образом, каждому ориентированному ребру в <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> соответствует два ориентированных ребра в остаточной сети <img class=tex src="../tex2png/cache/244f6ff593781082c3e5f177714595e0.png" alt="G^f">, и у каждого ребра остаточной сети появляется дополнительная характеристика &mdash; остаточная пропускная способность. Впрочем, нетрудно заметить, что выражения для остаточной пропускной способности <img class=tex src="../tex2png/cache/ab6a7bc54380a518ec37c97fb2d3346c.png" alt="r_{ij}^f"> по сути одинаковы как для прямого, так и для обратного ребра, т.е. мы можем записать для любого ребра <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)"> остаточной сети:<p class=formula><img class=tex src="../tex2png/cache/f74f315a9b0186f69ea31e1169af2935.png" alt=" r_{ij}^f = u_{ij}^f - f_{ij}^f "></p>Кстати, при реализации это свойство позволяет не хранить остаточные пропускные способности, а просто вычислять их при необходимости для ребра.<p>Следует отметить, что из остаточной сети удаляются все рёбра, имеющие нулевую остаточную пропускную способность. Остаточная сеть <img class=tex src="../tex2png/cache/244f6ff593781082c3e5f177714595e0.png" alt="G^f"> должна содержать <b>только рёбра с положительной остаточной пропускной способностью <img class=tex src="../tex2png/cache/ab6a7bc54380a518ec37c97fb2d3346c.png" alt="r_{ij}^f"></b>.<p>Здесь стоит обратить внимание на такой важный момент: если в сети <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> были одновременно оба ребра <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)"> и <img class=tex src="../tex2png/cache/e3bb5b2142823f74abc1f67c25b7879e.png" alt="(j,i)">, то в остаточной сети у каждого из них появится по обратному ребру, и в итоге появятся <b>кратные рёбра</b>. Например, такая ситуация часто возникает, когда сеть строится по неориентированному графу (и, получается, каждое неориентированное ребро в итоге приведёт к появлению четырёх рёбер в остаточной сети). Эту особенность нужно всегда помнить, она приводит к небольшому усложнению программирования, хотя в общем ничего не меняет. Кроме того, обозначение ребра <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)"> в таком случае становится неоднозначным, поэтому ниже мы везде будем считать, что такой ситуации в сети нет (исключительно в целях простоты и корректности описаний; на правильность идей это никак не влияет).<p><h2 style="padding-top:40px;">Критерий оптимальности по наличию циклов отрицательного веса</h2><p><b>Теорема.</b> Некоторый поток <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> является оптимальным (т.е. имеет наименьшую стоимость среди всех потоков такой же величины) тогда и только тогда, когда остаточная сеть <img class=tex src="../tex2png/cache/244f6ff593781082c3e5f177714595e0.png" alt="G^f"> не содержит циклов отрицательного веса.<p><b>Доказательство: необходимость</b>. Пусть поток <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> является оптимальным. Предположим, что остаточная сеть <img class=tex src="../tex2png/cache/244f6ff593781082c3e5f177714595e0.png" alt="G^f"> содержит цикл отрицательного веса. Возьмём этот цикл отрицательного веса и выберем минимум <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> среди остаточных пропускных способностей рёбер этого цикла (<img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> будет больше нуля). Но тогда можно увеличить поток вдоль каждого ребра цикла на величину <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, при этом никакие свойства потока не нарушатся, величина потока не изменится, однако стоимость потока уменьшится (уменьшится на стоимость цикла, умноженную на <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">). Таким образом, если есть цикл отрицательного веса, то <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> не может быть оптимальным, ч.т.д.<p><b>Доказательство: достаточность</b>. Для этого сначала докажем вспомогательные факты.<p><b>Лемма 1</b> (о декомпозиции потока): любой поток <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> можно представить в виде совокупности путей из истока в сток и циклов, все &mdash; имеющие положительный поток. Докажем эту лемму конструктивно: покажем, как разбить поток на совокупность путей и циклов. Если поток имеет ненулевую величину, то, очевидно, из истока <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> выходит хотя бы одно ребро с положительным потоком; пройдём по этому ребру, окажемся в какой-то вершине <img class=tex src="../tex2png/cache/f52a552b90a1d758e03e5ac6bbd074ef.png" alt="v_1">. Если эта вершина <img class=tex src="../tex2png/cache/9183f387bf2f1626760d5b6b22fd2ce5.png" alt="v_1 = t">, то останавливаемся &mdash; нашли путь из <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> в <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">. Иначе, по свойству сохранения потока, из <img class=tex src="../tex2png/cache/f52a552b90a1d758e03e5ac6bbd074ef.png" alt="v_1"> должно выходить хотя бы одно ребро с положительным потоком; пройдём по нему в какую-то вершину <img class=tex src="../tex2png/cache/e3e728f5f3685457175d559e1ba93479.png" alt="v_2">. Повторяя этот процесс, мы либо придём в сток <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">, либо же придём в какую-то вершину во второй раз. В первом случае мы обнаружим путь из <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> в <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">, во втором &mdash; цикл. Найденный путь/цикл будет иметь положительный поток <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> (минимум из потоков рёбер этого пути/цикла). Тогда уменьшим поток вдоль каждого ребра этого пути/цикла на величину <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, в результате получим снова поток, к которому снова применим этот процесс. Рано или поздно поток вдоль всех рёбер станет нулевым, и мы найдём его декомпозицию на пути и циклы.<p><b>Лемма 2</b> (о разности потоков): для любых двух потоков <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> и <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> одной величины (<img class=tex src="../tex2png/cache/f9275167b501a796a9ce5ef21696058d.png" alt="|f| = |g|">) поток <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> можно представить как поток <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> плюс несколько циклов в остаточной сети <img class=tex src="../tex2png/cache/244f6ff593781082c3e5f177714595e0.png" alt="G^f">. Действительно, рассмотрим разность этих потоков <img class=tex src="../tex2png/cache/79fa0592d1a82700051358e023eef036.png" alt="g-f"> (вычитание потоков &mdash; это почленное вычитание, т.е. вычитание потоков вдоль каждого ребра). Нетрудно убедиться, что в результате получится некоторый поток нулевой величины, т.е. циркуляция. Произведём декомпозицию этой циркуляции согласно предыдущей лемме. Очевидно, это декомпозиция не может содержать путей (т.к. наличие <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">-<img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">-пути с положительным потоком означает, что и величина потока в сети положительна). Таким образом, разность потоков <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> и <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> можно представить в виде суммы циклов в сети <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">. Более того, это будут и циклы в остаточной сети <img class=tex src="../tex2png/cache/244f6ff593781082c3e5f177714595e0.png" alt="G^f">, т.к. <img class=tex src="../tex2png/cache/37ba7be3b50b1f61cdde4df477b1dbb8.png" alt="g_{ij} - f_{ij} \le u_{ij} - f_{ij} = r_{ij}^f">, ч.т.д.<p>Теперь, вооружившись этими леммами, мы легко можем <b>доказать достаточность</b>. Итак, рассмотрим произвольный поток <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f">, в остаточной сети которого нет циклов отрицательной стоимости. Рассмотрим также поток той же величины, но минимальной стоимости <img class=tex src="../tex2png/cache/9922a5368cf0e6ccbde2b8fe883ba1a2.png" alt="f^*">; докажем, что <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> и <img class=tex src="../tex2png/cache/9922a5368cf0e6ccbde2b8fe883ba1a2.png" alt="f^*"> имеют одинаковую стоимость. Согласно лемме 2, поток <img class=tex src="../tex2png/cache/9922a5368cf0e6ccbde2b8fe883ba1a2.png" alt="f^*"> можно представить в виде суммы потока <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> и нескольких циклов. Но раз стоимости всех циклов неотрицательны, то и стоимость потока <img class=tex src="../tex2png/cache/9922a5368cf0e6ccbde2b8fe883ba1a2.png" alt="f^*"> не может быть меньше стоимости потока <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f">: <img class=tex src="../tex2png/cache/afcb1f2bab32737b40974331c874ca43.png" alt="z(f^*) \ge z(f)">. С другой стороны, т.к. поток <img class=tex src="../tex2png/cache/9922a5368cf0e6ccbde2b8fe883ba1a2.png" alt="f^*"> является оптимальным, то его стоимость не может быть выше стоимости потока <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f">. Таким образом, <img class=tex src="../tex2png/cache/20494d64d7b075622f66b216b9959373.png" alt="z(f) = z(f^*)">, ч.т.д.<p><h2 style="padding-top:40px;">Алгоритм удаления циклов отрицательного веса</h2><p>Только что доказанная теорема даёт нам простой <b>алгоритм</b>, позволяющий найти поток минимальной стоимости: если у нас есть какой-то поток <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f">, то построить для него остаточную сеть, проверить, есть ли в ней цикл отрицательного веса. Если такого цикла нет, то поток <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> является оптимальным (имеет наименьшую стоимость среди всех потоков такой же величины). Если же был найден цикл отрицательной стоимости, то посчитать поток <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, который можно пропустить дополнительно через этот цикл (это <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> будет равно минимуму из остаточных пропускных способностей рёбер цикла). Увеличив поток на <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> вдоль каждого ребра цикла, мы, очевидно, не нарушим свойства потока, не изменим величину потока, но уменьшим стоимость этого потока, получив новый поток <img class=tex src="../tex2png/cache/8c4c3d2109377d85c8dfb72f50805ce4.png" alt="f^\prime">, для которого надо повторить весь процесс.<p>Таким образом, чтобы запустить процесс улучшения стоимости потока, нам предварительно нужно найти <b>произвольный поток нужной величины</b> (каким-нибудь стандартным алгоритмом нахождения максимального потока, см., например, <a href="edmonds_karp.html">алгоритм Эдмондса-Карпа</a>). В частности, если требуется найти циркуляцию наименьшей стоимости, то начать можно просто с нулевого потока.<p>Оценим <b>асимптотику</b> алгоритма. Поиск цикла отрицательной стоимости в графе с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами и <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> рёбрами производится за <img class=tex src="../tex2png/cache/c4fa4086adf46462d07aa16071f709ef.png" alt="O(nm)"> (см. <a href="negative_cycle.html">соответствующую статью</a>). Если мы обозначим через <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C"> наибольшее из стоимостей рёбер, через <img class=tex src="../tex2png/cache/8514055a7c7c69a4c367f8f3cc226d9a.png" alt="U"> &mdash; наибольшую из пропускных способностей, то максимальное значение стоимости потока не превосходит <img class=tex src="../tex2png/cache/bd4fa7f67ddd422b811fb9d0108dc851.png" alt="mCU">. Если все стоимости и пропускные способности &mdash; целые числа, то каждая итерация алгоритма уменьшает стоимость потока как минимум на единицу; следовательно, всего алгоритм совершит <img class=tex src="../tex2png/cache/b806c176965979840f454148328a3b3c.png" alt="O(mCU)"> итераций, а итоговая асимптотика составит:<p class=formula><img class=tex src="../tex2png/cache/93fdafa946294501b44acc9993a357b8.png" alt=" O(nm^2CU) "></p><p>Эта асимптотика &mdash; не строго полиномиальна (strong polynomial), поскольку зависит от величин пропускных способностей и стоимостей.<p>Впрочем, если искать не произвольный отрицательный цикл, а использовать какой-то более чёткий подход, то асимптотика может значительно уменьшиться. Например, если каждый раз искать цикл с минимальной средней стоимостью (что также можно производить за <img class=tex src="../tex2png/cache/c4fa4086adf46462d07aa16071f709ef.png" alt="O(nm)">), то время работы всего алгоритма можно оценить строго полиномиальной асимптотикой <img class=tex src="../tex2png/cache/1954b6a2b9bf01ed0fb438b18125792b.png" alt="O(n^2 m^3 \log n)">.<p><h2 style="padding-top:40px;">Реализация</h2><p>Сначала введём структуры данных и функции для хранения графа. Каждое ребро хранится в отдельной структуре <img class=tex src="../tex2png/cache/7d2534953dd5361383f47378efadf1fe.png" alt="\rm edge">, все рёбра лежат в общем списке <img class=tex src="../tex2png/cache/9884aee383622bd8c51314209d04c880.png" alt="\rm edges">, а для каждой вершины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> в векторе <img class=tex src="../tex2png/cache/1d1d6805c277d8cf0a0d24c6dd93d702.png" alt="{\rm g}[i]"> хранятся номера рёбер, выходящих из неё. Такая организация позволяет легко находить номер обратного ребра по номеру прямого ребра &mdash; они оказываются в списке <img class=tex src="../tex2png/cache/9884aee383622bd8c51314209d04c880.png" alt="\rm edges"> соседними, и номер одного можно получить по номеру другого операцией "^1" (она инвертирует младший бит). Добавление ориентированного ребра в граф осуществляет функция <img class=tex src="../tex2png/cache/097925bfdc3d6e3ea54caf185c401d3d.png" alt="\rm add\_edge">, которая добавляет сразу прямое и обратное рёбра.<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> MAXN <span class="sy1">=</span> <span class="nu0">100</span><span class="sy2">*</span><span class="nu0">2</span><span class="sy4">;</span>
<span class="kw4">int</span> n<span class="sy4">;</span>
<span class="kw4">struct</span> edge <span class="br0">&#123;</span>
	<span class="kw4">int</span> v, to, u, f, c<span class="sy4">;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
vector<span class="sy1">&lt;</span>edge<span class="sy1">&gt;</span> edges<span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> g<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> add_edge <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> to, <span class="kw4">int</span> cap, <span class="kw4">int</span> cost<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	edge e1 <span class="sy1">=</span> <span class="br0">&#123;</span> v, to, cap, <span class="nu0">0</span>, cost <span class="br0">&#125;</span><span class="sy4">;</span>
	edge e2 <span class="sy1">=</span> <span class="br0">&#123;</span> to, v, <span class="nu0">0</span>, <span class="nu0">0</span>, <span class="sy2">-</span>cost <span class="br0">&#125;</span><span class="sy4">;</span>
	g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">push_back</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> edges.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	edges.<span class="me1">push_back</span> <span class="br0">&#40;</span>e1<span class="br0">&#41;</span><span class="sy4">;</span>
	g<span class="br0">&#91;</span>to<span class="br0">&#93;</span>.<span class="me1">push_back</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> edges.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	edges.<span class="me1">push_back</span> <span class="br0">&#40;</span>e2<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>В основной программе после чтения графа идёт бесконечный цикл, внутри которого выполняется алгоритм Форда-Беллмана, и если он обнаруживает цикл отрицательной стоимости, то вдоль этого цикла увеличивается поток. Поскольку остаточная сеть может представлять собой несвязный граф, то алгоритм Форда-Беллмана запускается из каждой не достигнутой ещё вершины. В целях оптимизации алгоритм использует очередь (текущая очередь <img class=tex src="../tex2png/cache/96ed1d399dbe3fe731dfc5cf2bb52164.png" alt="\rm q"> и новая очередь <img class=tex src="../tex2png/cache/3253535ccbbb81c80f5cd02ba3897a69.png" alt="\rm nq">), чтобы не перебирать на каждой стадии все рёбра. Вдоль обнаруженного цикла каждый раз проталкивается ровно единица потока, хотя, понятно, в целях оптимизации величину потока можно определять как минимум остаточных пропускных способностей.<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> INF <span class="sy1">=</span> <span class="nu0">1000000000</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">bool</span> found <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span>
&nbsp;
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> d <span class="br0">&#40;</span>n, INF<span class="br0">&#41;</span><span class="sy4">;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> par <span class="br0">&#40;</span>n, <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">==</span> INF<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			d<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
			vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> q, nq<span class="sy4">;</span>
			q.<span class="me1">push_back</span> <span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> it<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> it<span class="sy1">&lt;</span>n <span class="sy3">&amp;&amp;</span> q.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>it<span class="br0">&#41;</span> <span class="br0">&#123;</span>
				nq.<span class="me1">clear</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
				sort <span class="br0">&#40;</span>q.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, q.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
				q.<span class="me1">erase</span> <span class="br0">&#40;</span>unique <span class="br0">&#40;</span>q.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, q.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>, q.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
				<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>q.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
					<span class="kw4">int</span> v <span class="sy1">=</span> q<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="sy4">;</span>
					<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> k<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> k<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>k<span class="br0">&#41;</span> <span class="br0">&#123;</span>
						<span class="kw4">int</span> id <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="sy4">;</span>
						<span class="kw1">if</span> <span class="br0">&#40;</span>edges<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">f</span> <span class="sy1">&lt;</span> edges<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">u</span><span class="br0">&#41;</span>
							<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> edges<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">c</span> <span class="sy1">&lt;</span> d<span class="br0">&#91;</span>edges<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">to</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
								d<span class="br0">&#91;</span>edges<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">to</span><span class="br0">&#93;</span> <span class="sy1">=</span> d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> edges<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">c</span><span class="sy4">;</span>
								par<span class="br0">&#91;</span>edges<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">to</span><span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
								nq.<span class="me1">push_back</span> <span class="br0">&#40;</span>edges<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">to</span><span class="br0">&#41;</span><span class="sy4">;</span>
							<span class="br0">&#125;</span>
					<span class="br0">&#125;</span>
				<span class="br0">&#125;</span>
				swap <span class="br0">&#40;</span>q, nq<span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>q.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				<span class="kw4">int</span> leaf <span class="sy1">=</span> q<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="sy4">;</span>
				vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> path<span class="sy4">;</span>
				<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="sy1">=</span>leaf<span class="sy4">;</span> v<span class="sy3">!</span><span class="sy1">=</span><span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> v<span class="sy1">=</span>par<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span>
					<span class="kw1">if</span> <span class="br0">&#40;</span>find <span class="br0">&#40;</span>path.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, path.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, v<span class="br0">&#41;</span> <span class="sy1">==</span> path.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
						path.<span class="me1">push_back</span> <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
					<span class="kw1">else</span> <span class="br0">&#123;</span>
						path.<span class="me1">erase</span> <span class="br0">&#40;</span>path.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, find <span class="br0">&#40;</span>path.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, path.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, v<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
						<span class="kw1">break</span><span class="sy4">;</span>
					<span class="br0">&#125;</span>
				<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>path.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
					<span class="kw4">int</span> to <span class="sy1">=</span> path<span class="br0">&#91;</span>j<span class="br0">&#93;</span>,  v <span class="sy1">=</span> path<span class="br0">&#91;</span><span class="br0">&#40;</span>j<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy2">%</span>path.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#93;</span><span class="sy4">;</span>
					<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> k<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> k<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>k<span class="br0">&#41;</span>
						<span class="kw1">if</span> <span class="br0">&#40;</span>edges<span class="br0">&#91;</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>k<span class="br0">&#93;</span> <span class="br0">&#93;</span>.<span class="me1">to</span> <span class="sy1">==</span> to<span class="br0">&#41;</span> <span class="br0">&#123;</span>
							<span class="kw4">int</span> id <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="sy4">;</span>
							edges<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">f</span> <span class="sy2">+</span><span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
							edges<span class="br0">&#91;</span>id<span class="sy3">^</span><span class="nu0">1</span><span class="br0">&#93;</span>.<span class="me1">f</span> <span class="sy2">-</span><span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
						<span class="br0">&#125;</span>
				<span class="br0">&#125;</span>
				found <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>found<span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><h2 style="padding-top:40px;">Литература</h2><p><ul><li><a href="http://www.e-maxx-ru.1gb.ru/bookz/files/cormen.djvu">Томас Кормен, Чарльз Лейзерсон, Рональд Ривест, Клиффорд Штайн. <b>Алгоритмы: Построение и анализ</b> [2005]</a><li><a href="../bookz/files/ahuja_flows.djvu">Ravindra Ahuja, Thomas Magnanti, James Orlin. <b>Network flows</b> [1993]</a><li>Andrew Goldberg, Robert Tarjan. <b>Finding Minimum-Cost Circulations by Cancelling Negative Cycles</b> [1989]</ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>