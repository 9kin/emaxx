<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Дерево Штерна-Броко. Ряд Фарея</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 17 Jul 2009 23:00<br>редактировано: 16 Aug 2009 1:59</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="stern_brocot_farey.html#" id="contents-hide">[скрыть]</a><a href="stern_brocot_farey.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Дерево Штерна-Броко. Ряд Фарея</h1><p><h2 style="padding-top:40px;">Дерево Штерна-Броко</h2><p>Дерево Штерна-Броко &mdash; это изящная конструкция, позволяющая построить множество всех неотрицательных дробей. Она была независимо открыта немецким математиком Морицем Штерном (Moritz Stern) в 1858 г. и французским часовщиком Ахиллом Броко (Achille Brocot) в 1861 г. Впрочем, по некоторым данным, эта конструкция была открыта ещё древнегреческим учёным Эратосфеном (Eratosthenes).<p>На <b>нулевой</b> итерации у нас есть две дроби:<p class=formula><img class=tex src="../tex2png/cache/c6c9e964822fe57440f4c2fa82fdc64b.png" alt=" \frac{0}{1}, \frac{1}{0} "></p>(вторая величина, строго говоря, дробью не является; её можно понимать как несократимую дробь, обозначающую бесконечность)<p>Дальше, на каждом <b>последующей</b> итерации берётся этот список дробей и между каждыми двумя соседними дробями <img class=tex src="../tex2png/cache/00b27cc89a05bcc9758d5a5dcfd967dd.png" alt="\frac{a}{b}"> и <img class=tex src="../tex2png/cache/8d4efbc391f6ecdb2af4538db7f718e7.png" alt="\frac{c}{d}"> вставляется их <b>медианта</b>, т.е. дробь <img class=tex src="../tex2png/cache/77851e17cf8caca1d0a72382288a1b14.png" alt="\frac{a+c}{b+d}">.<p>Так, на первой итерации текущее множество будет таким:<p class=formula><img class=tex src="../tex2png/cache/36a17a38e4c5486f77f8df6ed6636b4c.png" alt=" \frac{0}{1}, \frac{1}{1}, \frac{1}{0} "></p><p>На второй:<p class=formula><img class=tex src="../tex2png/cache/2dac42f805732ed1adb7bf6ebb057ce3.png" alt=" \frac{0}{1}, \frac{1}{2}, \frac{1}{1}, \frac{2}{1[...]"></p><p>На третьей:<p class=formula><img class=tex src="../tex2png/cache/dbd3d8af3b163c87eeade083e03da1a1.png" alt=" \frac{0}{1}, \frac{1}{3}, \frac{1}{2}, \frac{2}{3[...]"></p><p>Продолжая этот процесс до <b>бесконечности</b>, утверждается, можно получить множество <b>всех</b> неотрицательных дробей. Более того, все получаемые дроби будут <b>различными</b> (т.е. в текущем множестве каждая дробь встречается не более одного раза), <b>несократимыми</b> (числители и знаменатели будут получаться взаимно простыми). Наконец, все дроби будут автоматически <b>упорядоченными</b> по возрастанию. Доказательство всех этих замечательных свойств дерева Штерна-Броко будет приведено чуть ниже.<p>Осталось только привести изображение самого дерева Штерна-Броко (пока мы описывали его с помощью меняющегося множества). В корне этого бесконечного дерева находится дробь <img class=tex src="../tex2png/cache/4392d79b2f65fd8364d6a429bfcc579a.png" alt="\frac{1}{1}">, а слева и справа от дерева находятся дроби <img class=tex src="../tex2png/cache/ed189bd808c9aeb952ef2d020a47531a.png" alt="\frac{0}{1}"> и <img class=tex src="../tex2png/cache/54f3ac6a75afcdf6cafcd3b1775ae66b.png" alt="\frac{1}{0}">. Любая вершина дерева имеет двух сыновей, каждый из которых получается как медианта своего левого предка и правого предка:<p><img src="stern_brocot.jpg"><p><h3 style="padding-top:15px;">Доказательство</h3><p><b>Упорядоченность</b>. Она доказывается очень просто: заметим, что медианта двух дробей всегда находится между ними, т.е.:<p class=formula><img class=tex src="../tex2png/cache/ec925ed4ac4e11f55aeb4759a4d63173.png" alt=" \frac{a}{b} \le \frac{a+c}{b+d} \le \frac{c}{d} "></p>при условии, что<p class=formula><img class=tex src="../tex2png/cache/521811e32e64ae713d15212cc3d9ff24.png" alt=" \frac{a}{b} \le \frac{c}{d} "></p>Доказывается это просто приведением трёх дробей к общему знаменателю.<p>Поскольку на нулевой итерации упорядоченность имела место, то она будет сохраняться и на каждой новой итерации.<p><b>Несократимость</b>. Для этого покажем, что на любой итерации для любых двух соседних в списке дробей <img class=tex src="../tex2png/cache/00b27cc89a05bcc9758d5a5dcfd967dd.png" alt="\frac{a}{b}"> и <img class=tex src="../tex2png/cache/8d4efbc391f6ecdb2af4538db7f718e7.png" alt="\frac{c}{d}"> выполняется:<p class=formula><img class=tex src="../tex2png/cache/1b48fa19c4ccfcd6d468cbef75d67d25.png" alt=" bc-ad=1 "></p>Действительно, вспоминая <a href="diofant_2_equation.html">Диофантовы уравнения с двумя неизвестными (<img class=tex src="../tex2png/cache/554d64ca626a41a4db134244792f9d2f.png" alt="ax+by=c">)</a>, получаем из этого утверждения, что <img class=tex src="../tex2png/cache/cd590164de4c86e6adc74da336869a4c.png" alt="{\rm gcd}(a,b) = {\rm gcd}(c,d) = 1">, что нам и требуется.<p>Итак, нам надо доказать истинность утверждения <img class=tex src="../tex2png/cache/8a0312025649940ebecc0f1362d8138c.png" alt="bc-ad=1"> на любой итерации. Докажем его также по индукции. На нулевой итерации это свойство выполнялось (в чём нетрудно убедиться). Теперь пусть оно было выполнено на предыдущей итерации, покажем, что оно выполнено на текущей итерации. Для этого надо рассмотреть тройку дробей-соседей в новом списке:<p class=formula><img class=tex src="../tex2png/cache/41e4546852a0b1e09889c991118e7e5e.png" alt=" \frac{a}{b}, \frac{a+c}{b+d}, \frac{c}{d} "></p>Для них условия принимают вид:<p class=formula><img class=tex src="../tex2png/cache/943d83fb3b6cb49f67a46cb0a87afa56.png" alt=" b(a+c) - a(b+d) = 1, "><br><img class=tex src="../tex2png/cache/e5e3fcedd9248897fa3a699c1e1cd3c9.png" alt=" c(b+d) - d(a+c) = 1 "></p>Однако истинность этих условий очевидна, при условии истинности <img class=tex src="../tex2png/cache/8a0312025649940ebecc0f1362d8138c.png" alt="bc-ad=1">. Таким образом, действительно, это свойство выполнено и на текущей итерации, что и требовалось доказать.<p><b>Наличие всех дробей</b>. Доказательство этого свойства тесно связано с алгоритмом нахождения дроби в дереве Штерна-Броко. Учитывая, что в дереве Штерна-Броко все дроби упорядочены, получаем, что для любой вершины дерева в её левом поддереве находятся дроби, меньшие её, а в правом &mdash; большие её. Отсюда получаем и очевидный алгоритм поиска какой-либо дроби в дереве Штерна-Броко: вначале мы находимся в корне; сравниваем нашу дробь с дробью, записанной в текущей вершине: если наша дробь меньше, то переходим в левое поддерево, если наша дробь больше &mdash; переходим в правое, а если совпадает &mdash; нашли дробь, поиск завершён.<p>Чтобы доказать, что бесконечное дерево Штерна-Броко содержит все дроби, достаточно показать, что этот алгоритм поиска дроби завершится за конечное число шагов для любой заданной дроби. Этот алгоритм можно понимать так: у нас есть текущий отрезок <img class=tex src="../tex2png/cache/15a064da95d1518d5ab85842637c7734.png" alt="\left[ \frac{a}{b}; \frac{c}{d} \right]">, в котором мы ищем нашу дробь <img class=tex src="../tex2png/cache/426747e08e24cce24be4eaf0cfc8376a.png" alt="\frac{x}{y}">. Изначально <img class=tex src="../tex2png/cache/e3d9aa0b385eac84301aa2d8278a7cd3.png" alt="\frac{a}{b}=\frac{0}{1}">, <img class=tex src="../tex2png/cache/c917b04946c0dbf2b15395b44d31b41e.png" alt="\frac{c}{d}=\frac{1}{0}">. На каждом шаге дробь <img class=tex src="../tex2png/cache/426747e08e24cce24be4eaf0cfc8376a.png" alt="\frac{x}{y}"> сравнивается с медиантой концов отрезка, т.е. с <img class=tex src="../tex2png/cache/77851e17cf8caca1d0a72382288a1b14.png" alt="\frac{a+c}{b+d}">, и в зависимости от этого мы либо останавливаем поиск, либо переходим в левую или правую часть отрезка. Если бы алгоритм поиска дроби работал бесконечно долго, то следующие условия были бы выполнены на каждой итерации:<p class=formula><img class=tex src="../tex2png/cache/ad2fa3a82ccf9e1f290e63026bc2856c.png" alt=" \frac{a}{b} < \frac{x}{y} < \frac{c}{d} "></p>Но их можно переписать в таком виде:<p class=formula><img class=tex src="../tex2png/cache/b20c86c4ee0126bdff67cbcc8b17a964.png" alt=" bx-ay \ge 1, "><br><img class=tex src="../tex2png/cache/11fde3e375d0814cf2724941bb1be958.png" alt=" cy-dx \ge 1 "></p>(здесь использовалось то, что они целочисленны, поэтому из <img class=tex src="../tex2png/cache/0902c799883be4779a4c6db5a1e1d5f1.png" alt=">0"> следует <img class=tex src="../tex2png/cache/3ee64e4f149d2b2f3271e5e5f1137bf7.png" alt="\ge 1">)<p>Тогда, умножая первое на <img class=tex src="../tex2png/cache/57c252418dce0fd6e5eff85fcbcc6151.png" alt="c+d">, а второе &mdash; на <img class=tex src="../tex2png/cache/ab5c38de1ebdb01035d82c0f541716c3.png" alt="a+b">, и складывая их, получаем:<p class=formula><img class=tex src="../tex2png/cache/ccaaa0d4f7206e140c56d856898e977d.png" alt=" (c+d)(bx-ay) + (a+b)(cy-dx) \ge a+b+c+d "></p>Раскрывая скобки слева и учитывая, что <img class=tex src="../tex2png/cache/8a0312025649940ebecc0f1362d8138c.png" alt="bc-ad=1"> (см. доказательство предыдущего свойства), окончательно получаем:<p class=formula><img class=tex src="../tex2png/cache/5a258105b70faf7af228e08458575361.png" alt=" x+y \ge a+b+c+d "></p>А поскольку на каждой итерации хотя бы одна из переменных <img class=tex src="../tex2png/cache/bd588678e9e4f3f94187538f67e3522f.png" alt="a, b, c, d"> строго возрастает, то процесс поиска дроби <img class=tex src="../tex2png/cache/426747e08e24cce24be4eaf0cfc8376a.png" alt="\frac{x}{y}"> будет содержать не более <img class=tex src="../tex2png/cache/7b70c5c3228ba1cb32db8dc2d89d3c89.png" alt="x+y"> итераций, что и требовалось доказать.<p><h3 style="padding-top:15px;">Алгоритм построения дерева</h3><p>Чтобы построить любое поддерево дерева Штерна-Броко, достаточно знать только левого и правого предков. Изначально, на первом уровне, левым предком является <img class=tex src="../tex2png/cache/ed189bd808c9aeb952ef2d020a47531a.png" alt="\frac{0}{1}">, а правым &mdash; <img class=tex src="../tex2png/cache/54f3ac6a75afcdf6cafcd3b1775ae66b.png" alt="\frac{1}{0}">. По ним можно вычислить дробь в текущей вершине, а затем запуститься от левого и правого сыновей (левому сыну передав себя в качестве правого предка, а правому сыну &mdash; в качестве левого предка).<p>Псевдокод этой процедуры, пытающийся построить всё бесконечное дерево:<p><pre class="notranslate cpp"><span class="kw4">void</span> build <span class="br0">&#40;</span><span class="kw4">int</span> a <span class="sy1">=</span> <span class="nu0">0</span>, <span class="kw4">int</span> b <span class="sy1">=</span> <span class="nu0">1</span>, <span class="kw4">int</span> c <span class="sy1">=</span> <span class="nu0">1</span>, <span class="kw4">int</span> d <span class="sy1">=</span> <span class="nu0">0</span>, <span class="kw4">int</span> level <span class="sy1">=</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> x <span class="sy1">=</span> a<span class="sy2">+</span>c,  y <span class="sy1">=</span> b<span class="sy2">+</span>d<span class="sy4">;</span>
	... вывод текущей дроби x<span class="sy2">/</span>y на уровне дерева level
	build <span class="br0">&#40;</span>a, b, x, y, level <span class="sy2">+</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	build <span class="br0">&#40;</span>x, y, c, d, level <span class="sy2">+</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><h3 style="padding-top:15px;">Алгоритм поиска дроби</h3><p>Алгоритм поиска дроби был уже описан при доказательства того, что дерево Штерна-Броко содержит все дроби, повторим его здесь. Этот алгоритм &mdash; фактически алгоритм бинарного поиска, или алгоритм поиска заданного значения в бинарном дереве поиска. Изначально мы стоим в корне дерева. Стоя в текущей вершине, мы сравниваем нашу дробь с дробью в текущей вершине. Если они совпадают, то процесс останавливаем &mdash; мы нашли дробь в дереве. Иначе, если наша дробь меньше дроби в текущей вершине, то переходим в левого сына, иначе &mdash; в правого.<p>Как было доказано в свойстве о том, что дерево Штерна-Броко содержит все неотрицательные дроби, при поиске дроби <img class=tex src="../tex2png/cache/426747e08e24cce24be4eaf0cfc8376a.png" alt="\frac{x}{y}"> алгоритм совершит не более <img class=tex src="../tex2png/cache/7b70c5c3228ba1cb32db8dc2d89d3c89.png" alt="x+y"> итераций.<p>Приведём реализацию, которая возвращает путь до вершины, содержащей заданную дробь <img class=tex src="../tex2png/cache/426747e08e24cce24be4eaf0cfc8376a.png" alt="\frac{x}{y}">, возвращая его в виде последовательности символов 'L'/'R': если текущий символ равен 'L', то это обозначает переход в дереве в левого сына, а иначе &mdash; в правого (изначально мы стоим в корне дерева, т.е. в вершине с дробью <img class=tex src="../tex2png/cache/4392d79b2f65fd8364d6a429bfcc579a.png" alt="\frac{1}{1}">). На самом деле, такая последовательность символов, существующая и однозначно определяющая любую неотрицательную дробь, называется <b>системой счисления Штерна-Броко</b>.<p><pre class="notranslate cpp">string find <span class="br0">&#40;</span><span class="kw4">int</span> x, <span class="kw4">int</span> y, <span class="kw4">int</span> a <span class="sy1">=</span> <span class="nu0">0</span>, <span class="kw4">int</span> b <span class="sy1">=</span> <span class="nu0">1</span>, <span class="kw4">int</span> c <span class="sy1">=</span> <span class="nu0">1</span>, <span class="kw4">int</span> d <span class="sy1">=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> m <span class="sy1">=</span> a<span class="sy2">+</span>c,  n <span class="sy1">=</span> b<span class="sy2">+</span>d<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>x <span class="sy1">==</span> m <span class="sy3">&amp;&amp;</span> y <span class="sy1">==</span> n<span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="st0">&quot;&quot;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>x <span class="sy2">*</span> n <span class="sy1">&lt;</span> y <span class="sy2">*</span> m<span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="st0">'L'</span> <span class="sy2">+</span> find <span class="br0">&#40;</span>x, y, a, b, m, n<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">else</span>
		<span class="kw1">return</span> <span class="st0">'R'</span> <span class="sy2">+</span> find <span class="br0">&#40;</span>x, y, m, n, c, d<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Иррациональным числам в системе счисления Штерна-Броко будут соответствовать бесконечные последовательности символов; если известна какая-то наперёд заданная точность, то можно ограничиться некоторым префиксом этой бесконечной последовательности. В процессе этого бесконечного поиска иррациональной дроби в дереве Штерна-Броко алгоритм будет каждый раз находить простую дробь (с постепенно возрастающими знаменателями), обеспечивающую лучшее приближение этого иррационального числа (это применение как раз важно в часовой технике, и в связи с этим Ахилл Броко и открыл это дерево).<p><h2 style="padding-top:40px;">Последовательность Фарея</h2><p>Последовательностью Фарея порядка <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> называется множество всех несократимых дробей между 0 и 1, знаменатели которых не превосходят <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, причём дроби упорядочены в порядке возрастания.<p>Эта последовательность названа в честь английского геолога Джона Фарея (John Farey), который попытался в 1816 г. доказать, что в ряде Фарея любая дробь является медиантой двух соседних. Насколько известно, его доказательство было неверным, а правильное доказательство предложил несколько позже Коши (Cauchy). Впрочем, ещё в 1802 г. математик Харос (Haros) в одной из своих работ пришёл практически к тем же результатам.<p>Последовательности Фарея обладают и множеством собственных интересных свойств, однако наиболее очевидна их <b>связь с деревом Штерна-Броко</b>: фактически, последовательность Фарея получается удалением некоторых ветвей из дерева. Или можно говорить, что для получения последовательности Фарея нужно взять множество дробей, получаемое при построении дерева Штерна-Броко на бесконечной итерации, и оставить в этом множестве только дроби со знаменателями, не превосходящими <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> и числителями, не превосходящими знаменатели.<p>Из алгоритма построения дерева Штерна-Броко следует и аналогичный <b>алгоритм</b> для последовательностей Фарея. На нулевой итерации включим в множество только дроби <img class=tex src="../tex2png/cache/ed189bd808c9aeb952ef2d020a47531a.png" alt="\frac{0}{1}"> и <img class=tex src="../tex2png/cache/4392d79b2f65fd8364d6a429bfcc579a.png" alt="\frac{1}{1}">. На каждой следующей итерации мы между каждыми двумя соседним дробями вставляем их медианту, если её знаменатель не превосходит <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Рано или поздно в множестве перестанут происходить какие-либо изменения, и процесс можно останавливать &mdash; мы нашли искомую последовательность Фарея.<p>Вычислим <b>длину</b> последовательности Фарея. Последовательность Фарея порядка <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> содержит все элементы последовательности Фарея порядка <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">, а также все несократимые дроби со знаменателями, равными <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, но это количество, как известно, равно <img class=tex src="../tex2png/cache/8ee5ca0943e68b4c996ccb40ca25ea2f.png" alt="\phi(n)">. Таким образом, длина <img class=tex src="../tex2png/cache/f9478b6170da56c6c97f5b259012f257.png" alt="L_n"> последовательности Фарея порядка <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> выражается по формуле:<p class=formula><img class=tex src="../tex2png/cache/0fe40eb59c003b92edb3ebd82b3847bb.png" alt=" L_n = L_{n-1} + \phi(n) "></p>или, раскрывая рекурсию:<p class=formula><img class=tex src="../tex2png/cache/021d8c60d608e681e0833d46040ed493.png" alt=" L_n = 1 + \sum_{k=1}^n \phi(k) "></p><p><h2 style="padding-top:40px;">Литература</h2><p><ul><li><a href="../bookz/files/graham.djvu">Роналд Грэхем, Дональд Кнут, Орен Паташник. <b>Конкретная математика. Основание информатики</b> [1998]</a></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>