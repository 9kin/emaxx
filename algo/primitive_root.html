<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Первообразный корень</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 16 Jan 2009 0:58<br>редактировано: 20 Aug 2012 23:51</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="primitive_root.html#" id="contents-hide">[скрыть]</a><a href="primitive_root.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Первообразные корни</h1><p><h2 style="padding-top:40px;">Определение</h2><p>Первообразным корнем по модулю <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> (primitive root modulo <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">) называется такое число <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g">, что все его степени по модулю <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> пробегают по всем числам, взаимно простым с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Математически это формулируется таким образом: если <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> является первообразным корнем по модулю <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, то для любого целого <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> такого, что <img class=tex src="../tex2png/cache/586570c5e5b4394f9da49f3c48de7703.png" alt="{\rm gcd}(a,n)=1">, найдётся такое целое <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, что <img class=tex src="../tex2png/cache/0c1a6e402d63f02bc8be29019da2bc3d.png" alt="g^k \equiv a \pmod{n}">.<p>В частности, для случая простого <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> степени первообразного корня пробегают по всем числам от <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"> до <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">.<p><h2 style="padding-top:40px;">Существование</h2><p>Первообразный корень по модулю <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> существует тогда и только тогда, когда <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> является либо степенью нечётного простого, либо удвоенной степенью простого, а также в случаях <img class=tex src="../tex2png/cache/790bfb8396d0037b1d0fa99336087cf2.png" alt="n=1">, <img class=tex src="../tex2png/cache/966c06d45da7b46ef928560dee55a828.png" alt="n=2">, <img class=tex src="../tex2png/cache/e297508edb9a817f5e41158e57713035.png" alt="n=4">.<p>Эта теорема (которая была полностью доказана Гауссом в 1801 г.) приводится здесь без доказательства.<p><h2 style="padding-top:40px;">Связь с <a href="euler_function.html">функцией Эйлера</h2></a><p>Пусть <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> - первообразный корень по модулю <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Тогда можно показать, что наименьшее число <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, для которого <img class=tex src="../tex2png/cache/5d810e7883ab931926aec67cf271f651.png" alt="g^k \equiv 1 \pmod{n}"> (т.е. <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> &mdash; показатель <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> (multiplicative order)), равно <img class=tex src="../tex2png/cache/8ee5ca0943e68b4c996ccb40ca25ea2f.png" alt="\phi(n)">. Более того, верно и обратное, и этот факт будет использован нами ниже в алгоритме нахождения первообразного корня.<p>Кроме того, если по модулю <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> есть хотя бы один первообразный корень, то всего их <img class=tex src="../tex2png/cache/938ed7e267fab5196668aad636367743.png" alt="\phi( \phi(n) )"> (т.к. циклическая группа с <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> элементами имеет <img class=tex src="../tex2png/cache/03a5213217c77995818c6dfc16cd1745.png" alt="\phi(k)"> генераторов).<p><h2 style="padding-top:40px;">Алгоритм нахождения первообразного корня</h2><p>Наивный алгоритм потребует для каждого тестируемого значения <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> времени, чтобы вычислить все его степени и проверить, что они все различны. Это слишком медленный алгоритм, ниже мы с помощью нескольких известных теорем из теории чисел получим более быстрый алгоритм.<p>Выше была приведена теорема о том, что если наименьшее число <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, для которого <img class=tex src="../tex2png/cache/5d810e7883ab931926aec67cf271f651.png" alt="g^k \equiv 1 \pmod{n}"> (т.е. <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> &mdash; показатель <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g">), равно <img class=tex src="../tex2png/cache/8ee5ca0943e68b4c996ccb40ca25ea2f.png" alt="\phi(n)">, то <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> &mdash; первообразный корень. Так как для любого числа <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, взаимно простого с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, выполняется <a href="http://e-maxx.ru/algo/euler_function#4">теорема Эйлера</a> (<img class=tex src="../tex2png/cache/d4bc12d4550e8ef17525bf13a75224c8.png" alt="a^{\phi(n)} \equiv 1 \pmod{n}">), то чтобы проверить, что <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> первообразный корень, достаточно проверить, что для всех чисел <img class=tex src="../tex2png/cache/30956e25578e9cb8f03bd9d36433020c.png" alt="d">, меньших <img class=tex src="../tex2png/cache/8ee5ca0943e68b4c996ccb40ca25ea2f.png" alt="\phi(n)">, выполнялось <img class=tex src="../tex2png/cache/44555dbb44e1e42b88e6cc3d038d23d0.png" alt="g^d \not\equiv 1 \pmod{n}">. Однако пока это слишком медленный алгоритм.<p>Из теоремы Лагранжа следует, что показатель любого числа по модулю <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> является делителем <img class=tex src="../tex2png/cache/8ee5ca0943e68b4c996ccb40ca25ea2f.png" alt="\phi(n)">. Таким образом, достаточно проверить, что для всех собственных делителей <img class=tex src="../tex2png/cache/1c1c16602dc583fea1bdf668f7c8befc.png" alt="d\ |\ \phi(n)"> выполняется <img class=tex src="../tex2png/cache/44555dbb44e1e42b88e6cc3d038d23d0.png" alt="g^d \not\equiv 1 \pmod{n}">. Это уже значительно более быстрый алгоритм, однако можно пойти ещё дальше.<p>Факторизуем число <img class=tex src="../tex2png/cache/07d4dd3d9fbf0cb09e7b2d3156eaeb3b.png" alt="\phi(n) = p_1^{a_1} \ldots p_s^{a_s}">. Докажем, что в предыдущем алгоритме достаточно рассматривать в качестве <img class=tex src="../tex2png/cache/30956e25578e9cb8f03bd9d36433020c.png" alt="d"> лишь числа вида <img class=tex src="../tex2png/cache/f7b1c96525afcfe22e541a34c1deafd1.png" alt="\frac{ \phi(n) }{ p_i }">. Действительно, пусть <img class=tex src="../tex2png/cache/30956e25578e9cb8f03bd9d36433020c.png" alt="d"> &mdash; произвольный собственный делитель <img class=tex src="../tex2png/cache/8ee5ca0943e68b4c996ccb40ca25ea2f.png" alt="\phi(n)">. Тогда, очевидно, найдётся такое <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">, что <img class=tex src="../tex2png/cache/deff45d3393c0927743ef2244d0da41a.png" alt="d\ |\ \frac{ \phi(n) }{ p_j }">, т.е. <img class=tex src="../tex2png/cache/c02b5596b4653119e7f3bd74beb83f04.png" alt="d \cdot k = \frac{ \phi(n) }{ p_j }">. Однако, если бы <img class=tex src="../tex2png/cache/2fabc0dc438b792b29877d9f78ae66c3.png" alt="g^d \equiv 1 \pmod{n}">, то мы получили бы:<p class=formula><img class=tex src="../tex2png/cache/e8405b30a6c4661a7bdbd246ac1b64f8.png" alt=" g^{\frac{ \phi(n) }{ p_j }} \equiv g^{d \cdot k} [...]"></p>т.е. всё равно среди чисел вида <img class=tex src="../tex2png/cache/f7b1c96525afcfe22e541a34c1deafd1.png" alt="\frac{ \phi(n) }{ p_i }"> нашлось бы то, для которого условие не выполнилось, что и требовалось доказать.<p>Таким образом, алгоритм нахождения первообразного корня такой. Находим <img class=tex src="../tex2png/cache/8ee5ca0943e68b4c996ccb40ca25ea2f.png" alt="\phi(n)">, факторизуем его. Теперь перебираем все числа <img class=tex src="../tex2png/cache/8832ae01b30b7eb2da8d3b6967a86c92.png" alt="g = 1 \ldots n">, и для каждого считаем все величины <img class=tex src="../tex2png/cache/a1d9d7bdd5e5e64658e9eeee40463634.png" alt="g^{ \frac{ \phi(n) }{ p_i } } \pmod{n}">. Если для текущего <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> все эти числа оказались отличными от <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1">, то это <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> и является искомым первообразным корнем.<p>Время работы алгоритма (считая, что у числа <img class=tex src="../tex2png/cache/8ee5ca0943e68b4c996ccb40ca25ea2f.png" alt="\phi(n)"> имеется <img class=tex src="../tex2png/cache/520ed41e907d37be141d7481615b4084.png" alt="O \left( \log \phi(n) \right)"> делителей, а возведение в степень выполняется алгоритмом <a href="binary_pow.html">Бинарного возведения в степень</a>, т.е. за <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)">) равно <img class=tex src="../tex2png/cache/7f37fd72430036f7a7a55fbed286ad92.png" alt="O \left( {\rm Ans} \cdot \log \phi(n) \cdot \log n \right)"> плюс время факторизации числа <img class=tex src="../tex2png/cache/8ee5ca0943e68b4c996ccb40ca25ea2f.png" alt="\phi(n)">, где <img class=tex src="../tex2png/cache/4b607591e9fdb6850a755ade5895ecd4.png" alt="\rm Ans"> &mdash; результат, т.е. значение искомого первообразного корня.<p>Про скорость роста первообразных корней с ростом <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> известны лишь приблизительные оценки. Известно, что первообразные корни &mdash; сравнительно небольшие величины. Одна из известных оценок &mdash; оценка Шупа (Shoup), что, в предположении истинности гипотезы Римана, первообразный корень есть <img class=tex src="../tex2png/cache/2e28f2a5fb11a3bc6e0f7f86672ebefd.png" alt="O (\log^6 n)">.<p><h2 style="padding-top:40px;">Реализация</h2><p>Функция powmod() выполняет бинарное возведение в степень по модулю, а функция generator (int p) - находит первообразный корень по простому модулю <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> (факторизация числа <img class=tex src="../tex2png/cache/8ee5ca0943e68b4c996ccb40ca25ea2f.png" alt="\phi(n)"> здесь осуществлена простейшим алгоритмом за <img class=tex src="../tex2png/cache/a470d76d2b6b87b33b052ba8ad1ec04a.png" alt="O( \sqrt{ \phi(n) } )">).<p>Чтобы адаптировать эту функцию для произвольных <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">, достаточно добавить вычисление <a href="euler_function.html">функции Эйлера</a> в переменной <img class=tex src="../tex2png/cache/376f8c911b7864ba9012b2b5a9479cad.png" alt="phi">, а также отсеивать <img class=tex src="../tex2png/cache/80f0f10848f577ce435d7d8d79815f74.png" alt="res">, не являющиеся взаимно простыми с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">.<p><pre class="notranslate cpp"><span class="kw4">int</span> powmod <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b, <span class="kw4">int</span> p<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> res <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>b<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>b <span class="sy3">&amp;</span> <span class="nu0">1</span><span class="br0">&#41;</span>
			res <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>res <span class="sy2">*</span> 1ll <span class="sy2">*</span> a <span class="sy2">%</span> p<span class="br0">&#41;</span>,  <span class="sy2">--</span>b<span class="sy4">;</span>
		<span class="kw1">else</span>
			a <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>a <span class="sy2">*</span> 1ll <span class="sy2">*</span> a <span class="sy2">%</span> p<span class="br0">&#41;</span>,  b <span class="sy1">&gt;&gt;=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">return</span> res<span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> generator <span class="br0">&#40;</span><span class="kw4">int</span> p<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> fact<span class="sy4">;</span>
	<span class="kw4">int</span> phi <span class="sy1">=</span> p<span class="sy2">-</span><span class="nu0">1</span>,  n <span class="sy1">=</span> phi<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> i<span class="sy2">*</span>i<span class="sy1">&lt;=</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>n <span class="sy2">%</span> i <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			fact.<span class="me1">push_back</span> <span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw1">while</span> <span class="br0">&#40;</span>n <span class="sy2">%</span> i <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
				n <span class="sy2">/</span><span class="sy1">=</span> i<span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>n <span class="sy1">&gt;</span> <span class="nu0">1</span><span class="br0">&#41;</span>
		fact.<span class="me1">push_back</span> <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> res<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> res<span class="sy1">&lt;=</span>p<span class="sy4">;</span> <span class="sy2">++</span>res<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">bool</span> ok <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>fact.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy3">&amp;&amp;</span> ok<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			ok <span class="sy3">&amp;</span><span class="sy1">=</span> powmod <span class="br0">&#40;</span>res, phi <span class="sy2">/</span> fact<span class="br0">&#91;</span>i<span class="br0">&#93;</span>, p<span class="br0">&#41;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>ok<span class="br0">&#41;</span>  <span class="kw1">return</span> res<span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>