<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Алгоритм Прима</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 20:55<br>редактировано: 18 Aug 2011 22:50</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="mst_prim.html#" id="contents-hide">[скрыть]</a><a href="mst_prim.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Минимальное остовное дерево. Алгоритм Прима</h1><p>Дан взвешенный неориентированный граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами и <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> рёбрами. Требуется найти такое поддерево этого графа, которое бы соединяло все его вершины, и при этом обладало наименьшим возможным весом (т.е. суммой весов рёбер). Поддерево &mdash; это набор рёбер, соединяющих все вершины, причём из любой вершины можно добраться до любой другой ровно одним простым путём.<p>Такое поддерево называется минимальным остовным деревом или просто <b>минимальным остовом</b>. Легко понять, что любой остов обязательно будет содержать <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> ребро.<p>В <b>естественной постановке</b> эта задача звучит следующим образом: есть <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> городов, и для каждой пары известна стоимость соединения их дорогой (либо известно, что соединить их нельзя). Требуется соединить все города так, чтобы можно было доехать из любого города в другой, а при этом стоимость прокладки дорог была бы минимальной.<p><p><h2 style="padding-top:40px;">Алгоритм Прима</h2><p>Этот алгоритм назван в честь американского математика Роберта Прима (Robert Prim), который открыл этот алгоритм в 1957 г. Впрочем, ещё в 1930 г. этот алгоритм был открыт чешским математиком Войтеком Ярником (Vojt&#283;ch Jarn&#237;k). Кроме того, Эдгар Дейкстра (Edsger Dijkstra) в 1959 г. также изобрёл этот алгоритм, независимо от них.<p><p><h3 style="padding-top:15px;">Описание алгоритма</h3><p>Сам <b>алгоритм</b> имеет очень простой вид. Искомый минимальный остов строится постепенно, добавлением в него рёбер по одному. Изначально остов полагается состоящим из единственной вершины (её можно выбрать произвольно). Затем выбирается ребро минимального веса, исходящее из этой вершины, и добавляется в минимальный остов. После этого остов содержит уже две вершины, и теперь ищется и добавляется ребро минимального веса, имеющее один конец в одной из двух выбранных вершин, а другой &mdash; наоборот, во всех остальных, кроме этих двух. И так далее, т.е. всякий раз ищется минимальное по весу ребро, один конец которого &mdash; уже взятая в остов вершина, а другой конец &mdash; ещё не взятая, и это ребро добавляется в остов (если таких рёбер несколько, можно взять любое). Этот процесс повторяется до тех пор, пока остов не станет содержать все вершины (или, что то же самое, <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> ребро).<p>В итоге будет построен остов, являющийся минимальным. Если граф был изначально не связен, то остов найден не будет (количество выбранных рёбер останется меньше <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">).<p><p><h3 style="padding-top:15px;">Доказательство</h3><p>Пусть граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> был связным, т.е. ответ существует. Обозначим через <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T"> остов, найденный алгоритмом Прима, а через <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S"> &mdash; минимальный остов. Очевидно, что <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T"> действительно является остовом (т.е. поддеревом графа <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">). Покажем, что веса <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S"> и <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T"> совпадают.<p>Рассмотрим первый момент времени, когда в <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T"> происходило добавление ребра, не входящего в оптимальный остов <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">. Обозначим это ребро через <img class=tex src="../tex2png/cache/2bf99a261c50e78801be552f1a6ebeb2.png" alt="e">, концы его &mdash; через <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">, а множество входящих на тот момент в остов вершин &mdash; через <img class=tex src="../tex2png/cache/f4727a593e3ecb8bea258213a2ce0988.png" alt="V"> (согласно алгоритму, <img class=tex src="../tex2png/cache/10b9f63deca505508eeefc90a89efe87.png" alt="a \in V">, <img class=tex src="../tex2png/cache/18ce2fa904bb10417a775ab20f922d93.png" alt="b \not\in V">, либо наоборот). В оптимальном остове <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S"> вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> соединяются каким-то путём <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">; найдём в этом пути любое ребро <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g">, один конец которого лежит в <img class=tex src="../tex2png/cache/f4727a593e3ecb8bea258213a2ce0988.png" alt="V">, а другой &mdash; нет. Поскольку алгоритм Прима выбрал ребро <img class=tex src="../tex2png/cache/2bf99a261c50e78801be552f1a6ebeb2.png" alt="e"> вместо ребра <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g">, то это значит, что вес ребра <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> больше либо равен весу ребра <img class=tex src="../tex2png/cache/2bf99a261c50e78801be552f1a6ebeb2.png" alt="e">.<p>Удалим теперь из <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S"> ребро <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g">, и добавим ребро <img class=tex src="../tex2png/cache/2bf99a261c50e78801be552f1a6ebeb2.png" alt="e">. По только что сказанному, вес остова в результате не мог увеличиться (уменьшиться он тоже не мог, поскольку <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S"> было оптимальным). Кроме того, <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S"> не перестало быть остовом (в том, что связность не нарушилась, нетрудно убедиться: мы замкнули путь <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> в цикл, и потом удалили из этого цикла одно ребро).<p>Итак, мы показали, что можно выбрать оптимальный остов <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S"> таким образом, что он будет включать ребро <img class=tex src="../tex2png/cache/2bf99a261c50e78801be552f1a6ebeb2.png" alt="e">. Повторяя эту процедуру необходимое число раз, мы получаем, что можно выбрать оптимальный остов <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S"> так, чтобы он совпадал с <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">. Следовательно, вес построенного алгоритмом Прима <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T"> минимален, что и требовалось доказать.<p><p><h2 style="padding-top:40px;">Реализации</h2><p>Время работы алгоритма существенно зависит от того, каким образом мы производим поиск очередного минимального ребра среди подходящих рёбер. Здесь могут быть разные подходы, приводящие к разным асимптотикам и разным реализациям.<p><p><h3 style="padding-top:15px;">Тривиальная реализация: алгоритмы за <img class=tex src="../tex2png/cache/1dd544fc4f21dca4fbd96348c6f98f0f.png" alt="O(n m)"> и <img class=tex src="../tex2png/cache/a493054231f305421e08ec492143c2b2.png" alt="O(n^2 + m \log n)"></h3><p>Если искать каждый раз ребро простым просмотром среди всех возможных вариантов, то асимптотически будет требоваться просмотр <img class=tex src="../tex2png/cache/baa7e0765a2f4f8991346c62c1279993.png" alt="O(m)"> рёбер, чтобы найти среди всех допустимых ребро с наименьшим весом. Суммарная асимптотика алгоритма составит в таком случае <img class=tex src="../tex2png/cache/c4fa4086adf46462d07aa16071f709ef.png" alt="O(nm)">, что в худшем случае есть <img class=tex src="../tex2png/cache/5333bf52919bd2805f33a181851ebbf4.png" alt="O(n^3)">, &mdash; слишком медленный алгоритм.<p>Этот алгоритм можно улучшить, если просматривать каждый раз не все рёбра, а только по одному ребру из каждой уже выбранной вершины. Для этого, например, можно отсортировать рёбра из каждой вершины в порядке возрастания весов, и хранить указатель на первое допустимое ребро (напомним, допустимы только те рёбра, которые ведут в множество ещё не выбранных вершин). Тогда, если пересчитывать эти указатели при каждом добавлении ребра в остов, суммарная асимптотика алгоритма будет <img class=tex src="../tex2png/cache/ef2b92f56e929955b48a4f8ccb94f66f.png" alt="O(n^2 + m)">, но предварительно потребуется выполнить сортировку всех рёбер за <img class=tex src="../tex2png/cache/bad1b79ce61ffeb47553f0c677030168.png" alt="O(m \log n)">, что в худшем случае (для плотных графов) даёт асимптотику <img class=tex src="../tex2png/cache/ef47bd4cb586bcaa0d840195d143a1be.png" alt="O(n^2 \log n)">.<p>Ниже мы рассмотрим два немного других алгоритма: для плотных и для разреженных графов, получив в итоге заметно лучшую асимптотику.<p><p><h3 style="padding-top:15px;">Случай плотных графов: алгоритм за <img class=tex src="../tex2png/cache/d7f83a4af3951f243cc25e2d3dcaa215.png" alt="O(n^2)"></h3><p>Подойдём к вопросу поиска наименьшего ребра с другой стороны: для каждой ещё не выбранной будем хранить минимальное ребро, ведущее в уже выбранную вершину.<p>Тогда, чтобы на текущем шаге произвести выбор минимального ребра, надо просто просмотреть эти минимальные рёбра у каждой не выбранной ещё вершины &mdash; асимптотика составит <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">.<p>Но теперь при добавлении в остов очередного ребра и вершины эти указатели надо пересчитывать. Заметим, что эти указатели могут только уменьшаться, т.е. у каждой не просмотренной ещё вершины надо либо оставить её указатель без изменения, либо присвоить ему вес ребра в только что добавленную вершину. Следовательно, эту фазу можно сделать также за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">.<p>Таким образом, мы получили вариант алгоритма Прима с асимптотикой <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)">.<p>В частности, такая реализация особенно удобна для решения так называемой <b>евклидовой задачи о минимальном остове</b>: когда даны <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> точек на плоскости, расстояние между которыми измеряется по стандартной евклидовой метрике, и требуется найти остов минимального веса, соединяющий их все (причём добавлять новые вершины где-либо в других местах запрещается). Эта задача решается описанным здесь алгоритмом за <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)"> времени и <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> памяти, чего не получится добиться <a href="mst_kruskal.html">алгоритмом Крускала</a>.<p>Реализация алгоритма Прима для графа, заданного матрицей смежности <img class=tex src="../tex2png/cache/beaca7ad3bd83d8cabfe8d60a891403a.png" alt="g[][]">:<p><pre class="notranslate cpp"><span class="co1">// входные данные</span>
<span class="kw4">int</span> n<span class="sy4">;</span>
vector <span class="sy1">&lt;</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> g<span class="sy4">;</span>
<span class="kw4">const</span> <span class="kw4">int</span> INF <span class="sy1">=</span> <span class="nu0">1000000000</span><span class="sy4">;</span> <span class="co1">// значение &quot;бесконечность&quot;</span>
&nbsp;
<span class="co1">// алгоритм</span>
vector<span class="sy1">&lt;</span><span class="kw4">bool</span><span class="sy1">&gt;</span> used <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> min_e <span class="br0">&#40;</span>n, INF<span class="br0">&#41;</span>, sel_e <span class="br0">&#40;</span>n, <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
min_e<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> v <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy3">&amp;&amp;</span> <span class="br0">&#40;</span>v <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy3">||</span> min_e<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">&lt;</span> min_e<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
			v <span class="sy1">=</span> j<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>min_e<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">==</span> INF<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;No MST!&quot;</span><span class="sy4">;</span>
		<span class="kw3">exit</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	used<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>sel_e<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
		<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> v <span class="sy1">&lt;&lt;</span> <span class="st0">&quot; &quot;</span> <span class="sy1">&lt;&lt;</span> sel_e<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">&lt;&lt;</span> endl<span class="sy4">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> to<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> to<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>to<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">&lt;</span> min_e<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			min_e<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="sy4">;</span>
			sel_e<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
		<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>На вход подаются число вершин <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> и матрица <img class=tex src="../tex2png/cache/beaca7ad3bd83d8cabfe8d60a891403a.png" alt="g[][]"> размера <img class=tex src="../tex2png/cache/0fc9328e33c84faad487e059a12d8e47.png" alt="n \times n">, в которой отмечены веса рёбер, и стоят числа <img class=tex src="../tex2png/cache/cc70289d7180b24262c58c3c6942aea7.png" alt="INF">, если соответствующее ребро отсутствует. Алгоритм поддерживает три массива: флаг <img class=tex src="../tex2png/cache/4d1d3f6c6a13c74d965e295dc753fddd.png" alt="{\rm used}[i] = {\rm true}"> означает, что вершина <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> включена в остов, величина <img class=tex src="../tex2png/cache/cb7c5d84cef7dd354af96e5056474c6f.png" alt="{\rm min\_e}[i]"> хранит вес наименьшего допустимого ребра из вершины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, а элемент <img class=tex src="../tex2png/cache/94e459e549672382b4543c7cba75ff20.png" alt="{\rm sel\_e}[i]"> содержит конец этого наименьшего ребра (это нужно для вывода рёбер в ответе). Алгоритм делает <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> шагов, на каждом из которых выбирает вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> с наименьшей меткой <img class=tex src="../tex2png/cache/cf80e69ea4e60aebadbbdbc9304394f3.png" alt="{\rm min\_e}">, помечает её <img class=tex src="../tex2png/cache/4ecdf68925044e45b2fd890bdbbe9ef5.png" alt="\rm used">, и затем просматривает все рёбра из этой вершины, пересчитывая их метки.<p><p><h3 style="padding-top:15px;">Случай разреженных графов: алгоритм за <img class=tex src="../tex2png/cache/a283366841cd79d2f5089b4ab7e07bb6.png" alt="O(m \log n)"></h3><p>В описанном выше алгоритме можно увидеть стандартные операции нахождения минимума в множестве и изменение значений в этом множестве. Эти две операции являются классическими, и выполняются многими структурами данных, например, реализованным в языке C++ красно-чёрным деревом set.<p>По смыслу алгоритм остаётся точно таким же, однако теперь мы можем найти минимальное ребро за время <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)">. С другой стороны, время на пересчёт <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> указателей теперь составит <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">, что хуже, чем в вышеописанном алгоритме.<p>Если учесть, что всего будет <img class=tex src="../tex2png/cache/baa7e0765a2f4f8991346c62c1279993.png" alt="O(m)"> пересчётов указателей и <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> поисков минимального ребра, то суммарная асимптотика составит <img class=tex src="../tex2png/cache/bad1b79ce61ffeb47553f0c677030168.png" alt="O(m \log n)"> &mdash; для разреженных графов это лучше, чем оба вышеописанных алгоритма, но на плотных графах этот алгоритм будет медленнее предыдущего.<p>Реализация алгоритма Прима для графа, заданного списками смежности <img class=tex src="../tex2png/cache/87368375d3fa220c7cfe38dfbd4da871.png" alt="g[]">:<p><pre class="notranslate cpp"><span class="co1">// входные данные</span>
<span class="kw4">int</span> n<span class="sy4">;</span>
vector <span class="sy1">&lt;</span> vector <span class="sy1">&lt;</span> pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> <span class="sy1">&gt;</span> g<span class="sy4">;</span>
<span class="kw4">const</span> <span class="kw4">int</span> INF <span class="sy1">=</span> <span class="nu0">1000000000</span><span class="sy4">;</span> <span class="co1">// значение &quot;бесконечность&quot;</span>
&nbsp;
<span class="co1">// алгоритм</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> min_e <span class="br0">&#40;</span>n, INF<span class="br0">&#41;</span>, sel_e <span class="br0">&#40;</span>n, <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
min_e<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
set <span class="sy1">&lt;</span> pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> q<span class="sy4">;</span>
q.<span class="me1">insert</span> <span class="br0">&#40;</span>make_pair <span class="br0">&#40;</span><span class="nu0">0</span>, <span class="nu0">0</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>q.<span class="me1">empty</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;No MST!&quot;</span><span class="sy4">;</span>
		<span class="kw3">exit</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw4">int</span> v <span class="sy1">=</span> q.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy2">-</span><span class="sy1">&gt;</span>second<span class="sy4">;</span>
	q.<span class="me1">erase</span> <span class="br0">&#40;</span>q.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">&#40;</span>sel_e<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
		<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> v <span class="sy1">&lt;&lt;</span> <span class="st0">&quot; &quot;</span> <span class="sy1">&lt;&lt;</span> sel_e<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">&lt;&lt;</span> endl<span class="sy4">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> to <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">first</span>,
			cost <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">second</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>cost <span class="sy1">&lt;</span> min_e<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			q.<span class="me1">erase</span> <span class="br0">&#40;</span>make_pair <span class="br0">&#40;</span>min_e<span class="br0">&#91;</span>to<span class="br0">&#93;</span>, to<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
			min_e<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> cost<span class="sy4">;</span>
			sel_e<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
			q.<span class="me1">insert</span> <span class="br0">&#40;</span>make_pair <span class="br0">&#40;</span>min_e<span class="br0">&#91;</span>to<span class="br0">&#93;</span>, to<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>На вход подаются число вершин <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> и <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> списков смежности: <img class=tex src="../tex2png/cache/c143026334a39328e865e722e32faa53.png" alt="g[i]"> &mdash; это список всех рёбер, исходящих из вершины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, в виде пар (второй конец ребра, вес ребра). Алгоритм поддерживает два массива: величина <img class=tex src="../tex2png/cache/cb7c5d84cef7dd354af96e5056474c6f.png" alt="{\rm min\_e}[i]"> хранит вес наименьшего допустимого ребра из вершины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, а элемент <img class=tex src="../tex2png/cache/94e459e549672382b4543c7cba75ff20.png" alt="{\rm sel\_e}[i]"> содержит конец этого наименьшего ребра (это нужно для вывода рёбер в ответе). Кроме того, поддерживается очередь <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> из всех вершин в порядке увеличения их меток <img class=tex src="../tex2png/cache/cf80e69ea4e60aebadbbdbc9304394f3.png" alt="{\rm min\_e}">. Алгоритм делает <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> шагов, на каждом из которых выбирает вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> с наименьшей меткой <img class=tex src="../tex2png/cache/cf80e69ea4e60aebadbbdbc9304394f3.png" alt="{\rm min\_e}"> (просто извлекая её из начала очереди), и затем просматривает все рёбра из этой вершины, пересчитывая их метки (при пересчёте мы удаляем из очереди старую величину, и затем кладём обратно новую).<p><p><h3 style="padding-top:15px;">Аналогия с алгоритмом Дейкстры</h3><p>В двух описанных только что алгоритмах прослеживается вполне чёткая аналогия с <a href="dijkstra.html">алгоритмом Дейкстры</a>: он имеет такую же структуру (<img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> фаза, на каждой из которых сначала выбирается оптимальное ребро, добавляется в ответ, а затем пересчитываются значения для всех не выбранных ещё вершин). Более того, алгоритм Дейкстры тоже имеет два варианта реализации: за <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)"> и <img class=tex src="../tex2png/cache/bad1b79ce61ffeb47553f0c677030168.png" alt="O(m \log n)"> (мы, конечно, здесь не учитываем возможность использования сложных структур данных для достижения ещё меньших асимптотик).<p>Если взглянуть на алгоритмы Прима и Дейкстры более формально, то получается, что они вообще идентичны друг другу, за исключением <b>весовой функции</b> вершин: если в алгоритме Дейкстры у каждой вершины поддерживается длина кратчайшего пути (т.е. сумма весов некоторых рёбер), то в алгоритме Прима каждой вершине приписывается только вес минимального ребра, ведущего в множество уже взятых вершин.<p>На уровне реализации это означает, что после добавления очередной вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> в множество выбранных вершин, когда мы начинаем просматривать все рёбра <img class=tex src="../tex2png/cache/2f71535f4ca1feaf0a836a12914b1d88.png" alt="(v,to)"> из этой вершины, то в алгоритме Прима указатель <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to"> обновляется весом ребра <img class=tex src="../tex2png/cache/2f71535f4ca1feaf0a836a12914b1d88.png" alt="(v,to)">, а в алгоритме Дейкстры &mdash; метка расстояния <img class=tex src="../tex2png/cache/055ebcf2759a1e84a08f5a359acfc850.png" alt="d[to]"> обновляется суммой метки <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]"> и веса ребра <img class=tex src="../tex2png/cache/2f71535f4ca1feaf0a836a12914b1d88.png" alt="(v,to)">. В остальном эти два алгоритма можно считать идентичными (хоть они и решают совсем разные задачи).<p><p><h2 style="padding-top:40px;">Свойства минимальных остовов</h2><p><ul><p><li><b>Максимальный</b> остов также можно искать алгоритмом Прима (например, заменив все веса рёбер на противоположные: алгоритм не требует неотрицательности весов рёбер).<p><li>Минимальный остов <b>единственен</b>, если веса всех рёбер различны. В противном случае, может существовать несколько минимальных остовов (какой именно будет выбран алгоритмом Прима, зависит от порядка просмотра рёбер/вершин с одинаковыми весами/указателями)<p><li>Минимальный остов также является остовом, <b>минимальным по произведению</b> всех рёбер (предполагается, что все веса положительны). В самом деле, если мы заменим веса всех рёбер на их логарифмы, то легко заметить, что в работе алгоритма ничего не изменится, и будут найдены те же самые рёбра.<p><li>Минимальный остов является остовом с минимальным весом <b>самого тяжёлого ребра</b>. Яснее всего это утверждение понятно, если рассмотреть работу <a href="mst_kruskal.html">алгоритма Крускала</a>.<p><li><b>Критерий минимальности</b> остова: остов является минимальным тогда и только тогда, когда для любого ребра, не принадлежащего остову, цикл, образуемый этим ребром при добавлении к остову, не содержит рёбер тяжелее этого ребра. В самом деле, если для какого-то ребра оказалось, что оно легче некоторых рёбер образуемого цикла, то можно получить остов с меньшим весом (добавив это ребро в остов, и удалив самое тяжелое ребро из цикла). Если же это условие не выполнилось ни для одного ребра, то все эти рёбра не улучшают вес остова при их добавлении.<p></ul><p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>