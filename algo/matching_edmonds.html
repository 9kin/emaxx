<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Алгоритм Эдмондса нахождения наибольшего паросочетания</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 2 Mar 2009 17:45<br>редактировано: 6 Dec 2012 11:58</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="matching_edmonds.html#" id="contents-hide">[скрыть]</a><a href="matching_edmonds.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Алгоритм Эдмондса нахождения наибольшего паросочетания в произвольных графах</h1><p>Дан неориентированный невзвешенный граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами. Требуется найти в нём наибольшее паросочетание, т.е. такое наибольшее (по мощности) множество <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> его рёбер, что никакие два ребра из выбранных не инцидентны друг другу (т.е. не имеют общих вершин).<p>В отличие от случая двудольного графа (см. <a href="kuhn_matching.html">Алгоритм Куна</a>), в графе <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> могут присутствовать циклы нечётной длины, что значительно усложняет поиск увеличивающих путей.<p>Приведём сначала теорему Бержа, из которой следует, что, как и в случае двудольных графов, наибольшее паросочетание можно находить при помощи увеличивающих путей.<p><p><h2 style="padding-top:40px;">Увеличивающие пути. Теорема Бержа</h2><p>Пусть зафиксировано некоторое паросочетание <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M">. Тогда простая цепь <img class=tex src="../tex2png/cache/013747b2ee0d6b1d390802944ca77849.png" alt="P = (v_1, v_2, \ldots, v_k)"> называется чередующейся цепью, если в ней рёбра по очереди принадлежат - не принадлежат паросочетанию <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M">. Чередующаяся цепь называется увеличивающей, если её первая и последняя вершины не принадлежат паросочетанию. Иными словами, простая цепь <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> является увеличивающей тогда и только тогда, когда вершина <img class=tex src="../tex2png/cache/828b35679270f3c556d21ad48ddae7d9.png" alt="v_1 \not\in M">, ребро <img class=tex src="../tex2png/cache/1d773c406f684f7fee385e8fc435a0b0.png" alt="(v_2,v_3) \in M">, ребро <img class=tex src="../tex2png/cache/2732f50f34991133ef3ac56d8d4adcb2.png" alt="(v_4,v_5) \in M">, ..., ребро <img class=tex src="../tex2png/cache/ef839b0de07d014af11b665e0377c05b.png" alt="(v_{k-2},v_{k-1}) \in M">, и вершина <img class=tex src="../tex2png/cache/2dad81d67ce8f80abf0c7cb2dc5f3e4e.png" alt="v_k \not\in M">.<p><img src="edmonds_1.png"><p><b>Теорема Бержа</b> (Claude Berge, 1957 г.). Паросочетание <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> является наибольшим тогда и только тогда, когда для него не существует увеличивающей цепи.<p><b>Доказательство необходимости</b>. Пусть для паросочетания <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> существует увеличивающая цепь <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">. Покажем, как перейти к паросочетанию большей мощности. Выполним чередование паросочетания <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> вдоль этой цепи <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">, т.е. включим в паросочетание рёбра <img class=tex src="../tex2png/cache/6a18333261045c1772f55279a2d5a011.png" alt="(v_1,v_2)">, <img class=tex src="../tex2png/cache/99359031732c371caf9fac31d1a3ce94.png" alt="(v_3,v_4)">, ..., <img class=tex src="../tex2png/cache/4a2c9bbfca48012b3e6d9951ce624fce.png" alt="(v_{k-1},v_k)">, и удалим из паросочетания рёбра <img class=tex src="../tex2png/cache/e3777b973c3eb50cd9c4d59ec1b2ef54.png" alt="(v_2,v_3)">, <img class=tex src="../tex2png/cache/1a4464cd9451eb0389cb9b099ddff154.png" alt="(v_4,v_5)">, ..., <img class=tex src="../tex2png/cache/89b8eb3d8029d032451225ec2a722c19.png" alt="(v_{k-2},v_{k-1})">. В результате, очевидно, будет получено корректное паросочетание, мощность которого будет на единицу выше, чем у паросочетания <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> (т.к. мы добавили <img class=tex src="../tex2png/cache/ae551d0f59150dd84fb953f54c88c317.png" alt="k/2"> рёбер, а удалили <img class=tex src="../tex2png/cache/ba8e819003b7ee904d41b850fd51889a.png" alt="k/2-1"> ребро).<p><b>Доказательство достаточности</b>. Пусть для паросочетания <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> не существует увеличивающей цепи, докажем, что оно является наибольшим. Пусть <img class=tex src="../tex2png/cache/367cdcd6ba06b99fac76c758798e8a6a.png" alt="\overline M"> &mdash; наибольшее паросочетание. Рассмотрим симметрическую разность <img class=tex src="../tex2png/cache/0844aa36b2646baf1d0d29da809543cb.png" alt="\overline G = M \oplus \overline M"> (т.е. множество рёбер, принадлежащих либо <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M">, либо <img class=tex src="../tex2png/cache/367cdcd6ba06b99fac76c758798e8a6a.png" alt="\overline M">, но не обоим одновременно). Покажем, что <img class=tex src="../tex2png/cache/f3aa7f4b4162301162526ede5c42daac.png" alt="\overline G"> содержит одинаковое число рёбер из <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> и <img class=tex src="../tex2png/cache/367cdcd6ba06b99fac76c758798e8a6a.png" alt="\overline M"> (т.к. мы исключили из <img class=tex src="../tex2png/cache/f3aa7f4b4162301162526ede5c42daac.png" alt="\overline G"> только общие для них рёбра, то отсюда будет следовать и <img class=tex src="../tex2png/cache/a3a8700b7729705f107498713e36d494.png" alt="|M| = |\overline M|">). Заметим, что <img class=tex src="../tex2png/cache/f3aa7f4b4162301162526ede5c42daac.png" alt="\overline G"> состоит только из простых цепей и циклов (т.к. иначе одной вершине были бы инцидентны сразу два ребра какого-либо паросочетания, что невозможно). Далее, циклы не могут иметь нечётную длину (по той же самой причине). Цепь в <img class=tex src="../tex2png/cache/f3aa7f4b4162301162526ede5c42daac.png" alt="\overline G"> также не может иметь нечётную длину (иначе бы она являлась увеличивающей цепью для <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M">, что противоречит условию, или для <img class=tex src="../tex2png/cache/367cdcd6ba06b99fac76c758798e8a6a.png" alt="\overline M">, что противоречит его максимальности). Наконец, в чётных циклах и цепях чётной длины в <img class=tex src="../tex2png/cache/f3aa7f4b4162301162526ede5c42daac.png" alt="\overline G"> рёбра поочерёдно входят в <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> и <img class=tex src="../tex2png/cache/367cdcd6ba06b99fac76c758798e8a6a.png" alt="\overline M">, что и означает, что в <img class=tex src="../tex2png/cache/f3aa7f4b4162301162526ede5c42daac.png" alt="\overline G"> входит одинаковое количество рёбер от <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> и <img class=tex src="../tex2png/cache/367cdcd6ba06b99fac76c758798e8a6a.png" alt="\overline M">. Как уже упоминалось выше, отсюда следует, что <img class=tex src="../tex2png/cache/a3a8700b7729705f107498713e36d494.png" alt="|M| = |\overline M|">, т.е. <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> является наибольшим паросочетанием.<p>Теорема Бержа даёт основу для алгоритма Эдмондса &mdash; поиск увеличивающих цепей и чередование вдоль них, пока увеличивающие цепи находятся.<p><p><h2 style="padding-top:40px;">Алгоритм Эдмондса. Сжатие цветков</h2><p>Основная проблема заключается в том, как находить увеличивающий путь. Если в графе имеются циклы нечётной длины, то просто запускать обход в глубину/ширину нельзя.<p>Можно привести простой контрпример, когда при запуске из одной из вершин алгоритм, не обрабатывающий особо циклы нечётной длины (фактически, <a href="kuhn_matching.html">Алгоритм Куна</a>) не найдёт увеличивающий путь, хотя должен. Это цикл длины 3 с висящим на нём ребром, т.е. граф 1-2, 2-3, 3-1, 2-4, и ребро 2-3 взято в паросочетание. Тогда при запуске из вершины 1, если обход пойдёт сначала в вершину 2, то он "упрётся" в вершину 3, вместо того чтобы найти увеличивающую цепь 1-3-2-4. Правда, на этом примере при запуске из вершины 4 алгоритм Куна всё же найдёт эту увеличивающую цепь.<p><img src="edmonds_2.png"><p>Тем не менее, можно построить граф, на котором при определённом порядке в списках смежности алгоритм Куна зайдёт в тупик. В качестве примера можно привести такой граф с 6 вершинами и 7 рёбрами: 1-2, 1-6, 2-6, 2-4, 4-3, 1-5, 4-5. Если применить здесь алгоритм Куна, то он найдёт паросочетание 1-6, 2-4, после чего он должен будет обнаружить увеличивающую цепь 5-1-6-2-4-3, однако может так и не обнаружить её (если из вершины 5 он пойдёт сначала в 4, и только потом в 1, а при запуске из вершины 3 он из вершины 2 пойдёт сначала в 1, и только затем в 6).<p><img src="edmonds_3.png"><p>Как мы увидели на этом примере, вся проблема в том, что при попадании в цикл нечётной длины обход может пойти по циклу в неправильном направлении. На самом деле, нас интересуют только "насыщенные" циклы, т.е. в которых имеется <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> насыщенных рёбер, где длина цикла равна <img class=tex src="../tex2png/cache/6620051a02a7de64aa067247c920c1aa.png" alt="2k+1">. В таком цикле есть ровно одна вершина, не насыщенная рёбрами этого цикла, назовём её <b>базой</b> (base). К базовой вершине подходит чередующийся путь чётной (возможно, нулевой) длины, начинающийся в свободной (т.е. не принадлежащей паросочетанию) вершине, и этот путь называется <b>стеблем</b> (stem). Наконец, подграф, образованный "насыщенным" нечётным циклом, называется <b>цветком</b> (blossom).<p><img src="edmonds_4.png"><p>Идея алгоритма Эдмондса (Jack Edmonds, 1965 г.) - в <b>сжатии цветков</b> (blossom shrinking). Сжатие цветка &mdash; это сжатие всего нечётного цикла в одну псевдо-вершину (соответственно, все рёбра, инцидентные вершинам этого цикла, становятся инцидентными псевдо-вершине). Алгоритм Эдмондса ищет в графе все цветки, сжимает их, после чего в графе не остаётся "плохих" циклов нечётной длины, и на таком графе (называемом "поверхностным" (surface) графом) уже можно искать увеличивающую цепь простым обходом в глубину/ширину. После нахождения увеличивающей цепи в поверхностном графе необходимо "развернуть" цветки, восстановив тем самым увеличивающую цепь в исходном графе.<p>Однако неочевидно, что после сжатия цветка не нарушится структура графа, а именно, что если в графе <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> существовала увеличивающая цепь, то она существует и в графе <img class=tex src="../tex2png/cache/f3aa7f4b4162301162526ede5c42daac.png" alt="\overline G">, полученном после сжатия цветка, и наоборот.<p><b>Теорема Эдмондса</b>. В графе <img class=tex src="../tex2png/cache/f3aa7f4b4162301162526ede5c42daac.png" alt="\overline G"> существует увеличивающая цепь тогда и только тогда, когда существует увеличивающая цепь в <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">.<p><b>Доказательство</b>. Итак, пусть граф <img class=tex src="../tex2png/cache/f3aa7f4b4162301162526ede5c42daac.png" alt="\overline G"> был получен из графа <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> сжатием одного цветка (обозначим через <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B"> цикл цветка, и через <img class=tex src="../tex2png/cache/da25e9d2792bc6c796bbedb9fbe95a4c.png" alt="\overline B"> соответствующую сжатую вершину), докажем утверждение теоремы. Вначале заметим, что достаточно рассматривать случай, когда база цветка является свободной вершиной (не принадлежащей паросочетанию). Действительно, в противном случае в базе цветка оканчивается чередующийся путь чётной длины, начинающийся в свободной вершине. Прочередовав паросочетание вдоль этого пути, мощность паросочетания не изменится, а база цветка станет свободной вершиной. Итак, при доказательстве можно считать, что база цветка является свободной вершиной.<p><b>Доказательство необходимости</b>. Пусть путь <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> является увеличивающим в графе <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">. Если он не проходит через <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B">, то тогда, очевидно, он будет увеличивающим и в графе <img class=tex src="../tex2png/cache/f3aa7f4b4162301162526ede5c42daac.png" alt="\overline G">. Пусть <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> проходит через <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B">. Тогда можно не теряя общности считать, что путь <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> представляет собой некоторый путь <img class=tex src="../tex2png/cache/3122f48f5edf548c3d6dc9ec4b8d33bc.png" alt="P_1">, не проходящий по вершинам <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B">, плюс некоторый путь <img class=tex src="../tex2png/cache/83ce9474dc01fcd3fabaf5370a97449d.png" alt="P_2">, проходящий по вершинам <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B"> и, возможно, другим вершинам. Но тогда путь <img class=tex src="../tex2png/cache/b96c19a8736436c6728c400bbcf059dd.png" alt="P_1 + \overline B"> будет являться увеличивающим путём в графе <img class=tex src="../tex2png/cache/f3aa7f4b4162301162526ede5c42daac.png" alt="\overline G">, что и требовалось доказать.<p><b>Доказательство достаточности</b>. Пусть путь <img class=tex src="../tex2png/cache/f354387d5aa24751954164480f020063.png" alt="\overline P"> является увеличивающим путём в графе <img class=tex src="../tex2png/cache/f3aa7f4b4162301162526ede5c42daac.png" alt="\overline G">. Снова, если путь <img class=tex src="../tex2png/cache/f354387d5aa24751954164480f020063.png" alt="\overline P"> не проходит через <img class=tex src="../tex2png/cache/da25e9d2792bc6c796bbedb9fbe95a4c.png" alt="\overline B">, то путь <img class=tex src="../tex2png/cache/f354387d5aa24751954164480f020063.png" alt="\overline P"> без изменений является увеличивающим путём в <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">, поэтому этот случай мы рассматривать не будем.<p>Рассмотрим отдельно случай, когда <img class=tex src="../tex2png/cache/f354387d5aa24751954164480f020063.png" alt="\overline P"> начинается со сжатого цветка <img class=tex src="../tex2png/cache/da25e9d2792bc6c796bbedb9fbe95a4c.png" alt="\overline B">, т.е. имеет вид <img class=tex src="../tex2png/cache/a9bacf7039c495af05e2e1e6ac36957f.png" alt="(\overline B, c, \ldots)">. Тогда в цветке <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B"> найдётся соответствующая вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, которая связана (ненасыщенным) ребром с <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">. Осталось только заметить, что из базы цветка всегда найдётся чередующийся путь чётной длины до вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Учитывая всё вышесказанное, получаем, что путь <img class=tex src="../tex2png/cache/5e6feea9fd79c7d1a3c58b15647ae507.png" alt="P = (b, \ldots, v, c, ...)"> является увеличивающим путём в графе <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">.<p>Пусть теперь путь <img class=tex src="../tex2png/cache/f354387d5aa24751954164480f020063.png" alt="\overline P"> проходит через псевдо-вершину <img class=tex src="../tex2png/cache/da25e9d2792bc6c796bbedb9fbe95a4c.png" alt="\overline B">, но не начинается и не заканчивается в ней. Тогда в <img class=tex src="../tex2png/cache/f354387d5aa24751954164480f020063.png" alt="\overline P"> есть два ребра, проходящих через <img class=tex src="../tex2png/cache/da25e9d2792bc6c796bbedb9fbe95a4c.png" alt="\overline B">, пусть это <img class=tex src="../tex2png/cache/f38d2a123f23b798ab93927fe22baf25.png" alt="(a, \overline B)"> и <img class=tex src="../tex2png/cache/23392d6935e057e098e9f54a3ec16e01.png" alt="(\overline B, c)">. Одно из них обязательно должно принадлежать паросочетанию <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M">, однако, т.к. база цветка не насыщена, а все остальные вершины цикла цветка <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B"> насыщены рёбрами цикла, то мы приходим к противоречию. Таким образом, этот случай просто невозможен.<p>Итак, мы рассмотрели все случаи и в каждом из них показали справедливость теоремы Эдмондса.<p><b>Общая схема алгоритма Эдмондса</b> принимает следующий вид:<p><pre class="notranslate cpp"><span class="kw4">void</span> edmonds<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>вершина i не в паросочетании<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> last_v <span class="sy1">=</span> find_augment_path <span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>last_v <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
				выполнить чередование вдоль пути из i в last_v<span class="sy4">;</span>
		<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> find_augment_path <span class="br0">&#40;</span><span class="kw4">int</span> root<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	обход в ширину<span class="sy4">:</span>
		<span class="kw4">int</span> v <span class="sy1">=</span> текущая_вершина<span class="sy4">;</span>
		перебрать все рёбра из v
			если обнаружили цикл нечётной длины, сжать его
			если пришли в свободную вершину, <span class="kw1">return</span>
			если пришли в несвободную вершину, то добавить
				в очередь смежную ей в паросочетании
	<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h2 style="padding-top:40px;">Эффективная реализация</h2><p>Сразу оценим асимптотику. Всего имеется <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> итераций, на каждой из которых выполняется обход в ширину за <img class=tex src="../tex2png/cache/baa7e0765a2f4f8991346c62c1279993.png" alt="O(m)">, кроме того, могут происходить операции сжатия цветков &mdash; их может быть <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">. Таким образом, если мы научимся сжимать цветок за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">, то общая асимптотика алгоритма составит <img class=tex src="../tex2png/cache/a1e9a0b539021f45de4d4b87f3dca6fd.png" alt="O(n \cdot (m + n^2)) = O(n^3)">.<p>Основную сложность представляют операции сжатия цветков. Если выполнять их, непосредственно объединяя списки смежности в один и удаляя из графа лишние вершины, то асимптотика сжатия одного цветка будет <img class=tex src="../tex2png/cache/baa7e0765a2f4f8991346c62c1279993.png" alt="O(m)">, кроме того, возникнут сложности при "разворачивании" цветков.<p>Вместо этого будем для каждой вершины графа <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> поддерживать указатель на базу цветка, которому она принадлежит (или на себя, если вершина не принадлежит никакому цветку). Нам надо решить две задачи: сжатие цветка за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> при его обнаружении, а также удобное сохранение всей информации для последующего чередования вдоль увеличивающего пути.<p>Итак, одна итерация алгоритма Эдмондса представляет собой обход в ширину, выполняемый из заданной свободной вершины <img class=tex src="../tex2png/cache/40e0e810bf54145c555375778ebb3918.png" alt="\rm root">. Постепенно будет строиться дерево обхода в ширину, причём путь в нём до любой вершины будет являться чередующимся путём, начинающимся со свободной вершины <img class=tex src="../tex2png/cache/40e0e810bf54145c555375778ebb3918.png" alt="\rm root">. Для удобства программирования будем класть в очередь только те вершины, расстояние до которых в дереве путей чётно (будем называть такие вершины чётными &mdash; т.е. это корень дерева, и вторые концы рёбер в паросочетании). Само дерево будем хранить в виде массива предков <img class=tex src="../tex2png/cache/879a909924d3e1ba7229352d9e853a3e.png" alt="\rm p[]">, в котором для каждой нечётной вершины (т.е. до которой расстояние в дереве путей нечётно, т.е. это первые концы рёбер в паросочетании) будем хранить предка - чётную вершину. Таким образом, для восстановления пути из дерева нам надо поочерёдно пользоваться массивами <img class=tex src="../tex2png/cache/879a909924d3e1ba7229352d9e853a3e.png" alt="\rm p[]"> и <img class=tex src="../tex2png/cache/d8ff7947eeb135dab22e31be367447f4.png" alt="\rm match[]">, где <img class=tex src="../tex2png/cache/d8ff7947eeb135dab22e31be367447f4.png" alt="\rm match[]"> &mdash; для каждой вершины содержит смежную ей в паросочетании, или <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1">, если таковой нет.<p>Теперь становится понятно, как обнаруживать циклы нечётной длины. Если мы из текущей вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> в процессе обхода в ширину приходим в такую вершину <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">, являющуюся корнем <img class=tex src="../tex2png/cache/40e0e810bf54145c555375778ebb3918.png" alt="\rm root"> или принадлежащую паросочетанию и дереву путей (т.е. <img class=tex src="../tex2png/cache/db8f980d3ab1047cfbb8888197ae291e.png" alt="\rm p[match[]]"> от которой не равно -1), то мы обнаружили цветок. Действительно, при выполнении этих условий и вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, и вершина <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> являются чётными вершинами. Расстояние от них до их наименьшего общего предка имеет одну чётность, поэтому найденный нами цикл имеет нечётную длину.<p>Научимся <b>сжимать цикл</b>. Итак, мы обнаружили нечётный цикл при рассмотрении ребра <img class=tex src="../tex2png/cache/fae7fc7228760232ded84ec7bb795757.png" alt="(v,u)">, где <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> и <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> &mdash; чётные вершины. Найдём их наименьшего общего предка <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">, он и будет базой цветка. Нетрудно заметить, что база тоже является чётной вершиной (поскольку у нечётных вершин в дереве путей есть только один сын). Однако надо заметить, что <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> &mdash; это, возможно, псевдовершина, поэтому мы фактически найдём базу цветка, являющегося наименьшим общим предком вершин <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> и <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">. Реализуем сразу нахождение наименьшего общего предка (нас вполне устраивает асимптотика <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">):<p><pre class="notranslate cpp"><span class="kw4">int</span> lca <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">bool</span> used<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="br0">&#123;</span> <span class="nu0">0</span> <span class="br0">&#125;</span><span class="sy4">;</span>
	<span class="co1">// поднимаемся от вершины a до корня, помечая все чётные вершины</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		a <span class="sy1">=</span> base<span class="br0">&#91;</span>a<span class="br0">&#93;</span><span class="sy4">;</span>
		used<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>match<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span> <span class="co1">// дошли до корня</span>
		a <span class="sy1">=</span> p<span class="br0">&#91;</span>match<span class="br0">&#91;</span>a<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="co1">// поднимаемся от вершины b, пока не найдём помеченную вершину</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		b <span class="sy1">=</span> base<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>used<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="br0">&#41;</span>  <span class="kw1">return</span> b<span class="sy4">;</span>
		b <span class="sy1">=</span> p<span class="br0">&#91;</span>match<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Теперь нам надо выявить сам цикл &mdash; пройтись от вершин <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> и <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> до базы <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> цветка. Будет более удобно, если мы пока просто пометим в каком-то специальном массиве (назовём его <img class=tex src="../tex2png/cache/ac10754a958b4a2a4e7a635e4d440ec7.png" alt="\rm blossom[]">) вершины, принадлежащие текущему цветку. После этого нам надо будет симитировать обход в ширину из псевдо-вершины &mdash; для этого достаточно положить в очередь обхода в ширину все вершины, лежащие на цикле цветка. Тем самым мы избежим явного объединения списков смежности.<p>Однако остаётся ещё одна проблема: корректное восстановление путей по окончании обхода в ширину. Для него мы сохраняли массив предков <img class=tex src="../tex2png/cache/879a909924d3e1ba7229352d9e853a3e.png" alt="\rm p[]">. Но после сжатия цветков возникает единственная проблема: обход в ширину продолжился сразу из всех вершин цикла, в том числе и нечётных, а массив предков у нас предназначался для восстановления путей по чётным вершинам. Более того, когда в сжатом графе найдётся увеличивающая цепь, проходящая через цветок, она вообще будет проходить по этому циклу в таком направлении, что в дереве путей это будет представляться движением вниз. Однако все эти проблемы изящно решаются таким манёвром: при сжатии цикла, проставим предков для всех его чётных вершин (кроме базы), чтобы эти "предки" указывали на соседнюю вершину в цикле. Для вершин <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> и <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, если они также не базы, направим указатели предков друг на друга. В результате, если при восстановлении увеличивающего пути мы придём в цикл цветка в нечётную вершину, путь по предкам будет восстановлен корректно, и приведёт в базу цветка (из которой он уже дальше будет восстанавливаться нормально).<p><img src="edmonds_5.png"><p>Итак, мы готовы реализовать сжатие цветка:<p><pre class="notranslate cpp"><span class="kw4">int</span> v, u<span class="sy4">;</span> <span class="co1">// ребро (v,u), при рассмотрении которого был обнаружен цветок</span>
<span class="kw4">int</span> b <span class="sy1">=</span> lca <span class="br0">&#40;</span>v, u<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw3">memset</span> <span class="br0">&#40;</span>blossom, <span class="nu0">0</span>, <span class="kw3">sizeof</span> blossom<span class="br0">&#41;</span><span class="sy4">;</span>
mark_path <span class="br0">&#40;</span>v, b, u<span class="br0">&#41;</span><span class="sy4">;</span>
mark_path <span class="br0">&#40;</span>u, b, v<span class="br0">&#41;</span><span class="sy4">;</span></pre><p>где функция <img class=tex src="../tex2png/cache/3f91442a9452a944345e141f447cdbd4.png" alt="\rm mark\_path()"> проходит по пути от вершины до базы цветка, проставляет в специальном массиве <img class=tex src="../tex2png/cache/ac10754a958b4a2a4e7a635e4d440ec7.png" alt="\rm blossom[]"> для них <img class=tex src="../tex2png/cache/d04c5eb60a53293d4878d3c73c349aa6.png" alt="\rm true"> и проставляет предков для чётных вершин. Параметр <img class=tex src="../tex2png/cache/ca2269d5365abbce5082b6b01f10a940.png" alt="\rm children"> &mdash; сын для самой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> (с помощью этого параметра мы замкнём цикл в предках).<p><pre class="notranslate cpp"><span class="kw4">void</span> mark_path <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> b, <span class="kw4">int</span> children<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>base<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		blossom<span class="br0">&#91;</span>base<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> blossom<span class="br0">&#91;</span>base<span class="br0">&#91;</span>match<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
		p<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> children<span class="sy4">;</span>
		children <span class="sy1">=</span> match<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy4">;</span>
		v <span class="sy1">=</span> p<span class="br0">&#91;</span>match<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Наконец, реализуем основную функцию &mdash; <img class=tex src="../tex2png/cache/6d412e03836603a1c20fe0228abedd0a.png" alt="\rm find\_path ~ (int ~ root)">, которая будет искать увеличивающий путь из свободной вершины <img class=tex src="../tex2png/cache/40e0e810bf54145c555375778ebb3918.png" alt="\rm root"> и возвращать последнюю вершину этого пути, либо <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1">, если увеличивающий путь не найден.<p>Вначале произведём инициализацию:<p><pre class="notranslate cpp"><span class="kw4">int</span> find_path <span class="br0">&#40;</span><span class="kw4">int</span> root<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw3">memset</span> <span class="br0">&#40;</span>used, <span class="nu0">0</span>, <span class="kw3">sizeof</span> used<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw3">memset</span> <span class="br0">&#40;</span>p, <span class="sy2">-</span><span class="nu0">1</span>, <span class="kw3">sizeof</span> p<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		base<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span></pre><p>Далее идёт обход в ширину. Рассматривая очередное ребро <img class=tex src="../tex2png/cache/dca0fc215fd057cc0b0d328e204940b7.png" alt="(v, to)">, у нас есть несколько вариантов:<p><ul><p><li>Ребро несуществующее. Под этим мы подразумеваем, что <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> и <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to"> принадлежат одной сжатой псевдо-вершине (<img class=tex src="../tex2png/cache/8cdcdb7d1f7475ddf4ac169682e5b2f6.png" alt="{\rm base}[v] == {\rm base}[to]">), поэтому в текущем поверхностном графе этого ребра нет. Кроме этого случая, есть ещё один случай: когда ребро <img class=tex src="../tex2png/cache/dca0fc215fd057cc0b0d328e204940b7.png" alt="(v, to)"> уже принадлежит текущему паросочетанию; т.к. мы считаем, что вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> является чётной вершиной, то проход по этому ребру означает в дереве путей подъём к предку вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, что недопустимо.<p><pre class="notranslate cpp"><span class="kw1">if</span> <span class="br0">&#40;</span>base<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">==</span> base<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy3">||</span> match<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">==</span> to<span class="br0">&#41;</span>  <span class="kw1">continue</span><span class="sy4">;</span></pre><p><li>Ребро замыкает цикл нечётной длины, т.е. обнаруживается цветок. Как уже упоминалось выше, цикл нечётной длины обнаруживается при выполнении условия:<p><pre class="notranslate cpp"><span class="kw1">if</span> <span class="br0">&#40;</span>to <span class="sy1">==</span> root <span class="sy3">||</span> match<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> p<span class="br0">&#91;</span>match<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span></pre><p>В этом случае нужно выполнить сжатие цветка. Выше уже подробно разбирался этот процесс, здесь приведём его реализацию:<p><pre class="notranslate cpp"><span class="kw4">int</span> curbase <span class="sy1">=</span> lca <span class="br0">&#40;</span>v, to<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw3">memset</span> <span class="br0">&#40;</span>blossom, <span class="nu0">0</span>, <span class="kw3">sizeof</span> blossom<span class="br0">&#41;</span><span class="sy4">;</span>
mark_path <span class="br0">&#40;</span>v, curbase, to<span class="br0">&#41;</span><span class="sy4">;</span>
mark_path <span class="br0">&#40;</span>to, curbase, v<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>blossom<span class="br0">&#91;</span>base<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		base<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> curbase<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			used<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
			q<span class="br0">&#91;</span>qt<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span></pre><p><li>Иначе &mdash; это "обычное" ребро, поступаем как и в обычном поиске в ширину. Единственная тонкость &mdash; при проверке, что эту вершину мы ещё не посещали, надо смотреть не в массив <img class=tex src="../tex2png/cache/4ecdf68925044e45b2fd890bdbbe9ef5.png" alt="\rm used">, а в массив <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> &mdash; именно он заполняется для посещённых нечётных вершин. Если мы в вершину <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to"> ещё не заходили, и она оказалась ненасыщенной, то мы нашли увеличивающую цепь, заканчивающуюся на вершине <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to">, возвращаем её.<p><pre class="notranslate cpp"><span class="kw1">if</span> <span class="br0">&#40;</span>p<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	p<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>match<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> to<span class="sy4">;</span>
	to <span class="sy1">=</span> match<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="sy4">;</span>
	used<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
	q<span class="br0">&#91;</span>qt<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> to<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p></ul><p>Итак, полная реализация функции <img class=tex src="../tex2png/cache/6e8cff5111677a97437cbd096b62df30.png" alt="\rm find\_path()">:<p><pre class="notranslate cpp"><span class="kw4">int</span> find_path <span class="br0">&#40;</span><span class="kw4">int</span> root<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw3">memset</span> <span class="br0">&#40;</span>used, <span class="nu0">0</span>, <span class="kw3">sizeof</span> used<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw3">memset</span> <span class="br0">&#40;</span>p, <span class="sy2">-</span><span class="nu0">1</span>, <span class="kw3">sizeof</span> p<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		base<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
&nbsp;
	used<span class="br0">&#91;</span>root<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
	<span class="kw4">int</span> qh<span class="sy1">=</span><span class="nu0">0</span>, qt<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span>
	q<span class="br0">&#91;</span>qt<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> root<span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>qh <span class="sy1">&lt;</span> qt<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> v <span class="sy1">=</span> q<span class="br0">&#91;</span>qh<span class="sy2">++</span><span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> to <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>base<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">==</span> base<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy3">||</span> match<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">==</span> to<span class="br0">&#41;</span>  <span class="kw1">continue</span><span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>to <span class="sy1">==</span> root <span class="sy3">||</span> match<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> p<span class="br0">&#91;</span>match<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				<span class="kw4">int</span> curbase <span class="sy1">=</span> lca <span class="br0">&#40;</span>v, to<span class="br0">&#41;</span><span class="sy4">;</span>
				<span class="kw3">memset</span> <span class="br0">&#40;</span>blossom, <span class="nu0">0</span>, <span class="kw3">sizeof</span> blossom<span class="br0">&#41;</span><span class="sy4">;</span>
				mark_path <span class="br0">&#40;</span>v, curbase, to<span class="br0">&#41;</span><span class="sy4">;</span>
				mark_path <span class="br0">&#40;</span>to, curbase, v<span class="br0">&#41;</span><span class="sy4">;</span>
				<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
					<span class="kw1">if</span> <span class="br0">&#40;</span>blossom<span class="br0">&#91;</span>base<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
						base<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> curbase<span class="sy4">;</span>
						<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
							used<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
							q<span class="br0">&#91;</span>qt<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
						<span class="br0">&#125;</span>
					<span class="br0">&#125;</span>
			<span class="br0">&#125;</span>
			<span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>p<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				p<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
				<span class="kw1">if</span> <span class="br0">&#40;</span>match<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
					<span class="kw1">return</span> to<span class="sy4">;</span>
				to <span class="sy1">=</span> match<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="sy4">;</span>
				used<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
				q<span class="br0">&#91;</span>qt<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> to<span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Наконец, приведём определения всех глобальных массивов, и реализацию основной программы нахождения наибольшего паросочетания:<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> MAXN <span class="sy1">=</span> ...<span class="sy4">;</span> <span class="co1">// максимально возможное число вершин во входном графе</span>
&nbsp;
<span class="kw4">int</span> n<span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> g<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">int</span> match<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, p<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, base<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, q<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">bool</span> used<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, blossom<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
...
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	... чтение графа ...
&nbsp;
	<span class="kw3">memset</span> <span class="br0">&#40;</span>match, <span class="sy2">-</span><span class="nu0">1</span>, <span class="kw3">sizeof</span> match<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>match<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> v <span class="sy1">=</span> find_path <span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw1">while</span> <span class="br0">&#40;</span>v <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				<span class="kw4">int</span> pv <span class="sy1">=</span> p<span class="br0">&#91;</span>v<span class="br0">&#93;</span>,  ppv <span class="sy1">=</span> match<span class="br0">&#91;</span>pv<span class="br0">&#93;</span><span class="sy4">;</span>
				match<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> pv,  match<span class="br0">&#91;</span>pv<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
				v <span class="sy1">=</span> ppv<span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p><p><h2 style="padding-top:40px;">Оптимизация: предварительное построение паросочетания</h2><p>Как и в случае <a href="kuhn_matching.html">Алгоритма Куна</a>, перед выполнением алгоритма Эдмондса можно каким-нибудь простым алгоритмом построить предварительное паросочетание. Например, таким жадным алгоритмом:<pre class="notranslate cpp"><span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>match<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>match<span class="br0">&#91;</span>g<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				match<span class="br0">&#91;</span>g<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
				match<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> g<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="sy4">;</span>
				<span class="kw1">break</span><span class="sy4">;</span>
			<span class="br0">&#125;</span></pre><p>Такая оптимизация значительно (до нескольких раз) ускорит работу алгоритма на случайных графах.<p><p><h2 style="padding-top:40px;">Случай двудольного графа</h2><p>В двудольных графах отсутствуют циклы нечётной длины, и, следовательно, код, выполняющий сжатие цветков, никогда не выполнится. Удалив мысленно все части кода, обрабатывающие сжатие цветков, мы получим <a href="kuhn_matching.html">Алгоритм Куна</a> практически в чистом виде. Таким образом, на двудольных графах алгоритм Эдмондса вырождается в <a href="kuhn_matching.html">алгоритм Куна</a> и работает за <img class=tex src="../tex2png/cache/a6b2398465a599d7b0ac3127f16f0244.png" alt="O (n m)">.<p><p><h2 style="padding-top:40px;">Дальнейшая оптимизация</h2><p>Во всех вышеописанных операциях с цветками легко угадываются операции с непересекающимися множествами, которые можно выполнять намного эффективнее (см. <a href="dsu.html">Система непересекающихся множеств</a>). Если переписать алгоритм с использованием этой структуры, то асимптотика алгоритма понизится до <img class=tex src="../tex2png/cache/a6b2398465a599d7b0ac3127f16f0244.png" alt="O (n m)">. Таким образом, для произвольных графов мы получили ту же асимптотическую оценку, что и в случае двудольных графов (алгоритм Куна), но заметно более сложным алгоритмом.<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>