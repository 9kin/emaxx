<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Z-функция строки и её вычисление</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 11 Jun 2008 10:35<br>редактировано: 26 Apr 2012 2:00</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="z_function.html#" id="contents-hide">[скрыть]</a><a href="z_function.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Z-функция строки и её вычисление </h1><p>Пусть дана строка <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Тогда <b>Z-функция</b> ("зет-функция") от этой строки &mdash; это массив длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ый элемент которого равен наибольшему числу символов, начиная с позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, совпадающих с первыми символами строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">.<p>Иными словами, <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]"> &mdash; это наибольший общий префикс строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> и её <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-го суффикса.<p><b>Примечание</b>. В данной статье, во избежание неопределённости, мы будем считать строку 0-индексированной &mdash; т.е. первый символ строки имеет индекс <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0">, а последний &mdash; <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">.<p>Первый элемент Z-функции, <img class=tex src="../tex2png/cache/f3d91ab957722ffd550030138b21249b.png" alt="z[0]">, обычно считают неопределённым. В данной статье мы будем считать, что он равен нулю (хотя ни в алгоритме, ни в приведённой реализации это ничего не меняет).<p>В данной статье приводится алгоритм вычисления Z-функции за время <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)">, а также различные применения этого алгоритма.<p><p><h2 style="padding-top:40px;"> Примеры </h2><p>Приведём для примера подсчитанную Z-функцию для нескольких строк:<p><ul><p><li><img class=tex src="../tex2png/cache/d6c69068f7126dab79b9c4ae124c292b.png" alt=""aaaaa"">:<p><p class=formula><img class=tex src="../tex2png/cache/a7a6c3c7db2d82d2f1e6926fae2261dd.png" alt=" z[0] = 0, "><br><img class=tex src="../tex2png/cache/33d7cbebcd6ceeb5e9daa625a290593f.png" alt=" z[1] = 4, "><br><img class=tex src="../tex2png/cache/b63df3c904f15bfe764ffc4592d8cb5e.png" alt=" z[2] = 3, "><br><img class=tex src="../tex2png/cache/20dede8d75beffc131da497c9dbdb4cf.png" alt=" z[3] = 2, "><br><img class=tex src="../tex2png/cache/bcd53dbad568d777b57372931ab7b9e4.png" alt=" z[4] = 1. "></p><p><li><img class=tex src="../tex2png/cache/43a4a02b124960bad94db7994482ff8f.png" alt=""aaabaab"">:<p><p class=formula><img class=tex src="../tex2png/cache/a7a6c3c7db2d82d2f1e6926fae2261dd.png" alt=" z[0] = 0, "><br><img class=tex src="../tex2png/cache/3425d0beb9dadfe5a1c0086e16fdf521.png" alt=" z[1] = 2, "><br><img class=tex src="../tex2png/cache/59746ac325c3a795ad30a112b95bfbb0.png" alt=" z[2] = 1, "><br><img class=tex src="../tex2png/cache/ce8386c0f6d261afadd8c3c92739c26c.png" alt=" z[3] = 0, "><br><img class=tex src="../tex2png/cache/2e480503f0b44bc45e72004ff726ede4.png" alt=" z[4] = 2, "><br><img class=tex src="../tex2png/cache/ede30e209d67a6d912bcf01d5e77b27e.png" alt=" z[5] = 1, "><br><img class=tex src="../tex2png/cache/ad5c22476c38fe4a9a6f5b43b6ae4b6e.png" alt=" z[6] = 0. "></p><p><li><img class=tex src="../tex2png/cache/25d637173ebd78202312970ad4e82040.png" alt=""abacaba"">:<p><p class=formula><img class=tex src="../tex2png/cache/a7a6c3c7db2d82d2f1e6926fae2261dd.png" alt=" z[0] = 0, "><br><img class=tex src="../tex2png/cache/07ab55208f4958ccab967a61054e137b.png" alt=" z[1] = 0, "><br><img class=tex src="../tex2png/cache/59746ac325c3a795ad30a112b95bfbb0.png" alt=" z[2] = 1, "><br><img class=tex src="../tex2png/cache/ce8386c0f6d261afadd8c3c92739c26c.png" alt=" z[3] = 0, "><br><img class=tex src="../tex2png/cache/8abd7282917dc507b85ec88029d578a4.png" alt=" z[4] = 3, "><br><img class=tex src="../tex2png/cache/c9aa4fa70af3fd882586d9058c9e65b6.png" alt=" z[5] = 0, "><br><img class=tex src="../tex2png/cache/9f229c30d8c56e3de4110cad48ed9592.png" alt=" z[6] = 1. "></p><p></ul><p><p><h2 style="padding-top:40px;"> Тривиальный алгоритм </h2><p>Формальное определение можно представить в виде следующей элементарной реализации за <img class=tex src="../tex2png/cache/4cd2772b06262896a7cf8a9d3c989ea4.png" alt="O (n^2)">:<p><pre class="notranslate cpp">vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> z_function_trivial <span class="br0">&#40;</span>string s<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> s.<span class="me1">length</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> z <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">while</span> <span class="br0">&#40;</span>i <span class="sy2">+</span> z<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&lt;</span> n <span class="sy3">&amp;&amp;</span> s<span class="br0">&#91;</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">==</span> s<span class="br0">&#91;</span>i<span class="sy2">+</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#41;</span>
			<span class="sy2">++</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw1">return</span> z<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Мы просто для каждой позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> перебираем ответ для неё <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]">, начиная с нуля, и до тех пор, пока мы не обнаружим несовпадение или не дойдём до конца строки.<p>Разумеется, эта реализация слишком неэффективна, перейдём теперь к построению эффективного алгоритма.<p><p><h2 style="padding-top:40px;"> Эффективный алгоритм вычисления Z-функции </h2><p>Чтобы получить эффективный алгоритм, будем вычислять значения <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]"> по очереди &mdash; от <img class=tex src="../tex2png/cache/f139289eb1f84cc9579e92a95127828f.png" alt="i=1"> до <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">, и при этом постараемся при вычислении очередного значения <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]"> максимально использовать уже вычисленные значения.<p>Назовём для краткости подстроку, совпадающую с префиксом строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, <b>отрезком совпадения</b>. Например, значение искомой Z-функции <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]"> &mdash; это длиннейший отрезок совпадения, начинающийся в позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> (и заканчиваться он будет в позиции <img class=tex src="../tex2png/cache/ee897009bcd7115d5cb730bbe3fcc702.png" alt="i + z[i] - 1">).<p>Для этого будем поддерживать <b>координаты <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> самого правого отрезка совпадения</b>, т.е. из всех обнаруженных отрезков будем хранить тот, который оканчивается правее всего. В некотором смысле, индекс <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> &mdash; это такая граница, до которой наша строка уже была просканирована алгоритмом, а всё остальное &mdash; пока ещё не известно.<p>Тогда если текущий индекс, для которого мы хотим посчитать очередное значение Z-функции, &mdash; это <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, мы имеем один из двух вариантов:<p><ul><p><li><img class=tex src="../tex2png/cache/6f0f72bd3c789e099a682350167fd333.png" alt="i > r"> &mdash; т.е. текущая позиция лежит <b>за пределами</b> того, что мы уже успели обработать.<p>Тогда будем искать <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]"> <b>тривиальным алгоритмом</b>, т.е. просто пробуя значения <img class=tex src="../tex2png/cache/f2291ea218f0cc5e644173e7c2623aae.png" alt="z[i]=0">, <img class=tex src="../tex2png/cache/3e45fea8d48349417d8f999e98395c43.png" alt="z[i]=1">, и т.д. Заметим, что в итоге, если <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]"> окажется <img class=tex src="../tex2png/cache/0902c799883be4779a4c6db5a1e1d5f1.png" alt=">0">, то мы будем обязаны обновить координаты самого правого отрезка <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> &mdash; т.к. <img class=tex src="../tex2png/cache/ee897009bcd7115d5cb730bbe3fcc702.png" alt="i + z[i] - 1"> гарантированно окажется больше <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">.<p><li><img class=tex src="../tex2png/cache/57881cc557940d4267652ffd3cdaac9c.png" alt="i \le r"> &mdash; т.е. текущая позиция лежит внутри отрезка совпадения <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]">.<p>Тогда мы можем использовать уже подсчитанные <b>предыдущие</b> значения Z-функции, чтобы проинициализировать значение <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]"> не нулём, а каким-то возможно бОльшим числом.<p>Для этого заметим, что подстроки <img class=tex src="../tex2png/cache/5ffb0bc5ca9770c3aaa4f968127640c2.png" alt="s[l \ldots r]"> и <img class=tex src="../tex2png/cache/687e16ef4aa77e1936f6640edcc3dcee.png" alt="s[0 \ldots r-l]"> <b>совпадают</b>. Это означает, что в качестве начального приближения для <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]"> можно взять соответствующее ему значение из отрезка <img class=tex src="../tex2png/cache/687e16ef4aa77e1936f6640edcc3dcee.png" alt="s[0 \ldots r-l]">, а именно, значение <img class=tex src="../tex2png/cache/56ed752766b7830373a1d4c9ac064c89.png" alt="z[i-l]">.<p>Однако значение <img class=tex src="../tex2png/cache/56ed752766b7830373a1d4c9ac064c89.png" alt="z[i-l]"> могло оказаться слишком большим: таким, что при применении его к позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> оно "вылезет" за пределы границы <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">. Этого допустить нельзя, т.к. про символы правее <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> мы ничего не знаем, и они могут отличаться от требуемых.<p>Приведём <b>пример</b> такой ситуации, на примере строки:<p><p class=formula><img class=tex src="../tex2png/cache/9dc785c9e96d3a93f14b859f052ded8c.png" alt=" "aaaabaa" "></p><p>Когда мы дойдём до последней позиции (<img class=tex src="../tex2png/cache/53f80d02c38f803a27453c149795cd24.png" alt="i=6">), текущим самым правым отрезком будет <img class=tex src="../tex2png/cache/a619d0352d41927638a9a6116666e16c.png" alt="[5;6]">. Позиции <img class=tex src="../tex2png/cache/4865d5147ae3eb875ffc560f11594965.png" alt="6"> с учётом этого отрезка будет соответствовать позиция <img class=tex src="../tex2png/cache/1d70e72ce1001239e50ac10a8d7a0881.png" alt="6-5=1">, ответ в которой равен <img class=tex src="../tex2png/cache/fa16309946cc1b84f1318d25a81277db.png" alt="z[1] = 3">. Очевидно, что таким значением инициализировать <img class=tex src="../tex2png/cache/137684e3ca4857f092dc1f6c450a5392.png" alt="z[6]"> нельзя, оно совершенно некорректно. Максимум, каким значением мы могли проинициализировать &mdash; это <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1">, поскольку это наибольшее значение, которое не вылазит за пределы отрезка <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]">.<p>Таким образом, в качестве <b>начального приближения</b> для <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]"> безопасно брать только такое выражение:<p><p class=formula><img class=tex src="../tex2png/cache/d31cd0c566748bed8116debb66e51201.png" alt=" z_0[i] = \min (r-i+1, z[i-l]). "></p><p>Проинициализировав <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]"> таким значением <img class=tex src="../tex2png/cache/9d4127be8bc7e936b76bef0e9d984518.png" alt="z_0[i]">, мы снова дальше действуем <b>тривиальным алгоритмом</b> &mdash; потому что после границы <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">, вообще говоря, могло обнаружиться продолжение отрезка совпадение, предугадать которое одними лишь предыдущими значениями Z-функции мы не могли.<p></ul><p>Таким образом, весь алгоритм представляет из себя два случая, которые фактически различаются только <b>начальным значением</b> <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]">: в первом случае оно полагается равным нулю, а во втором &mdash; определяется по предыдущим значениям по указанной формуле. После этого обе ветки алгоритма сводятся к выполнению <b>тривиального алгоритма</b>, стартующего сразу с указанного начального значения.<p>Алгоритм получился весьма простым. Несмотря на то, что при каждом <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> в нём так или иначе выполняется тривиальный алгоритм &mdash; мы достигли существенного прогресса, получив алгоритм, работающий за линейное время. Почему это так, рассмотрим ниже, после того, как приведём реализацию алгоритма.<p><p><h2 style="padding-top:40px;"> Реализация </h2><p>Реализация получается весьма лаконичной:<p><pre class="notranslate cpp">vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> z_function <span class="br0">&#40;</span>string s<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> s.<span class="me1">length</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> z <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span>, l<span class="sy1">=</span><span class="nu0">0</span>, r<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy1">&lt;=</span> r<span class="br0">&#41;</span>
			z<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> min <span class="br0">&#40;</span>r<span class="sy2">-</span>i<span class="sy2">+</span><span class="nu0">1</span>, z<span class="br0">&#91;</span>i<span class="sy2">-</span>l<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">while</span> <span class="br0">&#40;</span>i<span class="sy2">+</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&lt;</span> n <span class="sy3">&amp;&amp;</span> s<span class="br0">&#91;</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">==</span> s<span class="br0">&#91;</span>i<span class="sy2">+</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#41;</span>
			<span class="sy2">++</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>i<span class="sy2">+</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy2">-</span><span class="nu0">1</span> <span class="sy1">&gt;</span> r<span class="br0">&#41;</span>
			l <span class="sy1">=</span> i,  r <span class="sy1">=</span> i<span class="sy2">+</span>z<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> z<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Прокомментируем эту реализацию.<p>Всё решение оформлено в виде функции, которая по строке возвращает массив длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> &mdash; вычисленную Z-функцию.<p>Массив <img class=tex src="../tex2png/cache/d2e042dfcfdd9d928629625573c6ce28.png" alt="z[]"> изначально заполняется нулями. Текущий самый правый отрезок совпадения полагается равным <img class=tex src="../tex2png/cache/27cb9a9943a376ca429eee596b22791f.png" alt="[0;0]">, т.е. заведомо маленький отрезок, в который не попадёт ни одно <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">.<p>Внутри цикла по <img class=tex src="../tex2png/cache/5827ef17648fddb4efc8623550df436f.png" alt="i = 1 \ldots n-1"> мы сначала по описанному выше алгоритму определяем начальное значение <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]"> &mdash; оно либо останется нулём, либо вычислится на основе приведённой формулы.<p>После этого выполняется тривиальный алгоритм, который пытается увеличить значение <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]"> настолько, насколько это возможно.<p>В конце выполняется обновление текущего самого правого отрезка совпадения <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]">, если, конечно, это обновление требуется &mdash; т.е. если <img class=tex src="../tex2png/cache/a3ec5bde32981de4aab3fb024d40317a.png" alt="i+z[i]-1 > r">.<p><p><h2 style="padding-top:40px;"> Асимптотика алгоритма </h2><p>Докажем, что приведённый выше алгоритм работает за линейное относительно длины строки время, т.е. за <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)">.<p>Доказательство очень простое.<p>Нас интересует вложенный цикл <img class=tex src="../tex2png/cache/d5788ebb507c45e342eabc412e75d049.png" alt="\rm while"> &mdash; т.к. всё остальное &mdash; лишь константные операции, выполняемые <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"> раз.<p>Покажем, что <b>каждая итерация</b> этого цикла <img class=tex src="../tex2png/cache/d5788ebb507c45e342eabc412e75d049.png" alt="\rm while"> приведёт к увеличению правой границы <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> на единицу.<p>Для этого рассмотрим обе ветки алгоритма:<p><ul><p><li><img class=tex src="../tex2png/cache/6f0f72bd3c789e099a682350167fd333.png" alt="i > r"><p>В этом случае либо цикл <img class=tex src="../tex2png/cache/d5788ebb507c45e342eabc412e75d049.png" alt="\rm while"> не сделает ни одной итерации (если <img class=tex src="../tex2png/cache/bf2648c966d7b85fbfa408f362ce445c.png" alt="s[0] \ne s[i]">), либо же сделает несколько итераций, продвигаясь каждый раз на один символ вправо, начиная с позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, а после этого &mdash; правая граница <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> обязательно обновится.<p>Поскольку <img class=tex src="../tex2png/cache/6f0f72bd3c789e099a682350167fd333.png" alt="i > r">, то мы получаем, что действительно каждая итерация этого цикла увеличивает новое значение <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> на единицу.<p><li><img class=tex src="../tex2png/cache/57881cc557940d4267652ffd3cdaac9c.png" alt="i \le r"><p>В этом случае мы по приведённой формуле инициализируем значение <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]"> некоторым числом <img class=tex src="../tex2png/cache/cd0b7fdc03320c3813651e8d44aa7887.png" alt="z_0">. Сравним это начальное значение <img class=tex src="../tex2png/cache/cd0b7fdc03320c3813651e8d44aa7887.png" alt="z_0"> с величиной <img class=tex src="../tex2png/cache/678b7186537be319921e7ccf494748bb.png" alt="r-i+1">, получаем три варианта:<p><ul><p><li><img class=tex src="../tex2png/cache/1a77583f4aaa1b683bc97f38af52eb36.png" alt="z_0 < r-i+1"><p>Докажем, что в этом случае ни одной итерации цикл <img class=tex src="../tex2png/cache/d5788ebb507c45e342eabc412e75d049.png" alt="\rm while"> не сделает.<p>Это легко доказать, например, от противного: если бы цикл <img class=tex src="../tex2png/cache/d5788ebb507c45e342eabc412e75d049.png" alt="\rm while"> сделал хотя бы одну итерацию, это бы означало, что определённое нами значение <img class=tex src="../tex2png/cache/cd0b7fdc03320c3813651e8d44aa7887.png" alt="z_0"> было неточным, меньше настоящей длины совпадения. Но т.к. строки <img class=tex src="../tex2png/cache/5ffb0bc5ca9770c3aaa4f968127640c2.png" alt="s[l \ldots r]"> и <img class=tex src="../tex2png/cache/687e16ef4aa77e1936f6640edcc3dcee.png" alt="s[0 \ldots r-l]"> совпадают, то это означает, что в позиции <img class=tex src="../tex2png/cache/56ed752766b7830373a1d4c9ac064c89.png" alt="z[i-l]"> стоит неправильное значение: меньше, чем должно быть.<p>Таким образом, в этом варианте из корректности значения <img class=tex src="../tex2png/cache/56ed752766b7830373a1d4c9ac064c89.png" alt="z[i-l]"> и из того, что оно меньше <img class=tex src="../tex2png/cache/678b7186537be319921e7ccf494748bb.png" alt="r-i+1">, следует, что это значение совпадает с искомым значением <img class=tex src="../tex2png/cache/465a7bdd87cd231dadca50964dd2156e.png" alt="z[i]">.<p><li><img class=tex src="../tex2png/cache/a17bbe1fad3675d2dba4d4b8b5629fd4.png" alt="z_0 = r-i+1"><p>В этом случае цикл <img class=tex src="../tex2png/cache/d5788ebb507c45e342eabc412e75d049.png" alt="\rm while"> может совершить несколько итераций, однако каждая из них будет приводить к увеличению нового значения <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> на единицу: потому что первым же сравниваемым символом будет <img class=tex src="../tex2png/cache/d6f725b0cf9e8a38873e43336c92019b.png" alt="s[r+1]">, который вылазит за пределы отрезка <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]">.<p><li><img class=tex src="../tex2png/cache/85ebe9a69a338db6bde1ec8539ac9cdb.png" alt="z_0 > r-i+1"><p>Этот вариант принципиально невозможен, в силу определения <img class=tex src="../tex2png/cache/cd0b7fdc03320c3813651e8d44aa7887.png" alt="z_0">.<p></ul><p></ul><p>Таким образом, мы доказали, что каждая итерация вложенного цикла приводит к продвижению указателя <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> вправо. Т.к. <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> не могло оказаться больше <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">, это означает, что всего этот цикл сделает не более <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> итерации.<p>Поскольку вся остальная часть алгоритма, очевидно, работает за <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)">, то мы доказали, что и весь алгоритм вычисления Z-функции выполняется за линейное время.<p><p><p><h2 style="padding-top:40px;"> Применения </h2><p>Рассмотрим несколько применений Z-функции при решении конкретных задач.<p>Применения эти будут во многом аналогичным применениям <a href="prefix_function.html">префикс-функции</a>.<p><p><h3 style="padding-top:15px;"> Поиск подстроки в строке </h3><p>Во избежании путаницы, назовём одну строку <b>текстом</b> <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">, другую &mdash; <b>образцом</b> <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">. Таким образом, задача заключается в том, чтобы найти все вхождения образца <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> в текст <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">.<p>Для решения этой задачи образуем строку <img class=tex src="../tex2png/cache/f6f3db2530faace8d28c2764245b2768.png" alt="s = p + \# + t">, т.е. к образцу припишем текст через символ-разделитель (который не встречается нигде в самих строках).<p>Посчитаем для полученной строки Z-функцию. Тогда для любого <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> в отрезке <img class=tex src="../tex2png/cache/c83427e2861ed4e61a931ae12a3944d8.png" alt="[0; length(t)-1]"> по соответствующему значению <img class=tex src="../tex2png/cache/92047c871731a58e64c726b2a183e9be.png" alt="z[i + length(p) + 1]"> можно понять, входит ли образец <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> в текст <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">, начиная с позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">: если это значение Z-функции равно <img class=tex src="../tex2png/cache/ea517679a36d55b03c2c0527b3e212b8.png" alt="length(p)">, то да, входит, иначе &mdash; нет.<p>Таким образом, асимптотика решения получилась <img class=tex src="../tex2png/cache/7cb4aa4a9f9e739be7228cf153e74458.png" alt="O (length(t) + length(p))">. Потребление памяти имеет ту же асимптотику.<p><p><h3 style="padding-top:15px;"> Количество различных подстрок в строке </h3><p>Дана строка <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Требуется посчитать количество её различных подстрок.<p>Будем решать эту задачу итеративно. А именно, научимся, зная текущее количество различных подстрок, пересчитывать это количество при добавлении в конец одного символа.<p>Итак, пусть <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> &mdash; текущее количество различных подстрок строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, и мы добавляем в конец символ <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">. Очевидно, в результате могли появиться некоторые новые подстроки, оканчивавшиеся на этом новом символе <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> (а именно, все подстроки, оканчивающиеся на этом символе, но не встречавшиеся раньше).<p>Возьмём строку <img class=tex src="../tex2png/cache/7f7a4efd50e7091200c3c4233d2a1448.png" alt="t=s+c"> и инвертируем её (запишем символы в обратном порядке). Наша задача &mdash; посчитать, сколько у строки <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> таких префиксов, которые не встречаются в ней более нигде. Но если мы посчитаем для строки <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> Z-функцию и найдём её максимальное значение <img class=tex src="../tex2png/cache/d7b0c6235878d6505e3ec2304f622551.png" alt="z_{\rm max}">, то, очевидно, в строке <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> встречается (не в начале) её префикс длины <img class=tex src="../tex2png/cache/d7b0c6235878d6505e3ec2304f622551.png" alt="z_{\rm max}">, но не большей длины. Понятно, префиксы меньшей длины уже точно встречаются в ней.<p>Итак, мы получили, что число новых подстрок, появляющихся при дописывании символа <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">, равно <img class=tex src="../tex2png/cache/5f56e06150e2316cc0c64148b2059a2b.png" alt="len - z_{\rm max}">, где <img class=tex src="../tex2png/cache/50a069f00cb79de2927015fc1ef559aa.png" alt="len"> &mdash; текущая длина строки после приписывания символа <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">.<p>Следовательно, асимптотика решения для строки длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> составляет <img class=tex src="../tex2png/cache/4cd2772b06262896a7cf8a9d3c989ea4.png" alt="O (n^2)">.<p>Стоит заметить, что совершенно аналогично можно пересчитывать за <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"> количество различных подстрок и при дописывании символа в начало, а также при удалении символа с конца или с начала.<p><p><h3 style="padding-top:15px;"> Сжатие строки </h3><p>Дана строка <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Требуется найти самое короткое её "сжатое" представление, т.е. найти такую строку <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> наименьшей длины, что <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> можно представить в виде конкатенации одной или нескольких копий <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">.<p>Для решения посчитаем Z-функцию строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, и найдём первую позицию <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> такую, что <img class=tex src="../tex2png/cache/b493ebbde4bfff023f2c7158b8907cbe.png" alt="i + z[i] = n">, и при этом <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> делится на <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">. Тогда строку <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> можно сжать до строки длины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">.<p>Доказательство такого решения практически не отличается от доказательства решения с помощью <a href="prefix_function.html">префикс-функции</a>.<p><p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Список задач, которые можно решить, используя Z-функцию:<p><ul><p><li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=396">UVA #455 <b>"Periodic Strings"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p><li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1963=">UVA #11022 <b>"String Factoring"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>