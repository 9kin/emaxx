<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Лемма Бернсайда. Теорема Пойа</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 4 Nov 2008 11:48<br>редактировано: 2 Jun 2009 10:54</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="burnside_polya.html#" id="contents-hide">[скрыть]</a><a href="burnside_polya.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Лемма Бернсайда. Теорема Пойа</h1><p><h2 style="padding-top:40px;">Лемма Бернсайда</h2><p>Эта лемма была сформулирована и доказана <b>Бернсайдом</b> (Burnside) в 1897 г., однако было установлено, что эта формула была ранее открыта <b>Фробениусом</b> (Frobenius) в 1887 г., а ещё раньше - <b>Коши</b> (Cauchy) в 1845 г. Поэтому эта формула иногда называется леммой Бернсайда, а иногда - теоремой Коши-Фробениуса.<p>Лемма Бернсайда позволяет посчитать количество классов эквивалентности в некотором множестве, основываясь на некоторой его внутренней симметрии.<p><h3 style="padding-top:15px;">Объекты и представления</h3><p>Проведём чёткую грань между количеством объектов и количеством представлений.<p>Одним и тем же объектам могут соответствовать различные представления, но, разумеется, любое представление соответствует ровно одному объекту. Следовательно, множество всех представлений разбивается на классы эквивалентности. Наша задача &mdash; в подсчёте именно числа объектов, или, что то же самое, количества классов эквивалентности.<p><h3 style="padding-top:15px;">Пример задачи: раскраска бинарных деревьев</h3><p>Допустим, мы рассматриваем следующую задачу. Требуется посчитать количество способов раскрасить корневые бинарные деревья с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами в 2 цвета, если у каждой вершины мы не различаем правого и левого сына.<p>Множество объектов здесь &mdash; это множество различных в этом понимании раскрасок деревьев.<p>Определим теперь множество представлений. Каждой раскраске поставим в соответствие задающую её функцию <img class=tex src="../tex2png/cache/418a1d86dab3c90ab1dbc6cd23cb11da.png" alt="f(v)">, где <img class=tex src="../tex2png/cache/a18bf4c54b90d9ba8b3fd48cc2abb524.png" alt="v = 1 \ldots n">, а <img class=tex src="../tex2png/cache/c3814ec0be139c0306baf16f4345dff3.png" alt="f(v)=0 \ldots 1">. Тогда множество представлений &mdash; это множество различных функций такого вида, и размер его, очевидно, равен <img class=tex src="../tex2png/cache/f26be6eff0bc0813c49c4125743c6e55.png" alt="2^n">. В то же время, на этом множестве представлений мы ввели разбиение на классы эквивалентности. <p>Например, пусть <img class=tex src="../tex2png/cache/bcda88883794933f7b1fcfe9f0ddaa2d.png" alt="n=3">, а дерево таково: корень &mdash; вершина 1, а вершины 2 и 3 &mdash; её сыновья. Тогда следующие функции <img class=tex src="../tex2png/cache/1f61c75bc3066dabd9982f029dd1da3b.png" alt="f_1"> и <img class=tex src="../tex2png/cache/703ea045144a19504640b199daf295fe.png" alt="f_2"> считаются эквивалентными:<p><p class=formula><img class=tex src="../tex2png/cache/0be5ed7e2df25a4a794d41cfb527e699.png" alt=" \matrix{
f_1(1)=0 & f_2(1)=0 \cr
f_1(2)=1 & f_2[...]"></p><p><h3 style="padding-top:15px;">Инвариантные перестановки</h3><p>Почему эти две функции <img class=tex src="../tex2png/cache/1f61c75bc3066dabd9982f029dd1da3b.png" alt="f_1"> и <img class=tex src="../tex2png/cache/703ea045144a19504640b199daf295fe.png" alt="f_2"> принадлежат одному классу эквивалентности? Интуитивно это понятно &mdash; потому что мы можем переставить местами сыновей вершины 1, т.е. вершины 2 и 3, а после такого преобразования функции <img class=tex src="../tex2png/cache/1f61c75bc3066dabd9982f029dd1da3b.png" alt="f_1"> и <img class=tex src="../tex2png/cache/703ea045144a19504640b199daf295fe.png" alt="f_2"> совпадут. Но формально это означает, что найдётся такая <b>инвариантная перестановка</b> <img class=tex src="../tex2png/cache/c3fa15d88e1f1538bca2b2a502cac196.png" alt="\pi"> (т.е. которая по условию задачи не меняет сам объект, а только его представление), такая, что:<p><p class=formula><img class=tex src="../tex2png/cache/b20b55271ec42ca335544214baa10a38.png" alt=" f_2 \pi \equiv f_1 "></p><p>Итак, исходя из условия задачи, мы можем найти все инвариантные перестановки, т.е. применяя которые мы не не переходим из одного класса эквивалентности в другой. Тогда, чтобы проверить, являются ли две функции <img class=tex src="../tex2png/cache/1f61c75bc3066dabd9982f029dd1da3b.png" alt="f_1"> и <img class=tex src="../tex2png/cache/703ea045144a19504640b199daf295fe.png" alt="f_2"> эквивалентными (т.е. соответствуют ли они на самом деле одному объекту), надо для каждой инвариантной перестановки <img class=tex src="../tex2png/cache/c3fa15d88e1f1538bca2b2a502cac196.png" alt="\pi"> проверить, не выполнится ли условие: <img class=tex src="../tex2png/cache/39d11e307f69de5de6a087f867a28321.png" alt="f_2 \pi \equiv f_1"> (или, что то же самое, <img class=tex src="../tex2png/cache/0dc89bb2527d07c43bb672bf804cb7a5.png" alt="f_1 \pi \equiv f_2">). Если хотя бы для одной перестановки обнаружилось это равенство, то <img class=tex src="../tex2png/cache/1f61c75bc3066dabd9982f029dd1da3b.png" alt="f_1"> и <img class=tex src="../tex2png/cache/703ea045144a19504640b199daf295fe.png" alt="f_2"> эквивалентны, иначе они не эквивалентны.<p>Нахождение всех таких инвариантных перестановок, относительно которых наша задача инвариантна &mdash; это ключевой шаг для применения как леммы Бернсайда, так и теоремы Пойа. Понятно, что эти инвариантные перестановки зависят от конкретной задачи, и их нахождение &mdash; процесс чисто эвристический, основанный на интуитивных соображениях. Впрочем, в большинстве случаев достаточно вручную найти несколько "основных" перестановок, из которых все остальные перестановки могут быть получены их всевозможными произведениями (и эту, исключительно механическую, часть работы можно переложить на компьютер; более подробно это будет рассмотрено ниже на примере конкретной задачи).<p>Нетрудно понять, что инвариантные перестановки образуют <b>группу</b> &mdash; поскольку произведение любых инвариантных перестановок тоже является инвариантной перестановкой. Обозначим <b>группу инвариантных перестановок</b> через <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">.<p><h3 style="padding-top:15px;">Формулировка леммы</h3><p>Для формулировки осталось напомнить одно понятие из алгебры. <b>Неподвижной точкой</b> <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> для перестановки <img class=tex src="../tex2png/cache/c3fa15d88e1f1538bca2b2a502cac196.png" alt="\pi"> называется такой элемент, который инвариантен относительно этой перестановки: <img class=tex src="../tex2png/cache/b33a5c9e2a43b264ed1e91ae80ea88e2.png" alt="f \equiv f \pi">. Например, в нашем примере неподвижными точками будут являться те функции <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f">, которые соответствуют раскраскам, не меняющимся при применении к ним перестановки <img class=tex src="../tex2png/cache/c3fa15d88e1f1538bca2b2a502cac196.png" alt="\pi"> (не меняющимся именно в формальном смысле равенства двух функций). Обозначим через <img class=tex src="../tex2png/cache/e7699fc360674c9299880a6a07810555.png" alt="I(\pi)"> <b>количество неподвижных точек</b> для перестановки <img class=tex src="../tex2png/cache/c3fa15d88e1f1538bca2b2a502cac196.png" alt="\pi">.<p>Тогда <b>лемма Бернсайда</b> звучит следующим образом: количество классов эквивалетности равно сумме количеств неподвижных точек по всем перестановкам из группы <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">, делённой на размер этой группы:<p><p class=formula><img class=tex src="../tex2png/cache/31a66ddd737b7653b85b233f3a1f5fe7.png" alt=" {\rm ClassesCount} = \frac{1}{|G|} \sum_{\pi \in [...]"></p><p>Хотя лемма Бернсайда сама по себе не так удобна для применения на практике (пока непонятно, как быстро искать величину <img class=tex src="../tex2png/cache/e7699fc360674c9299880a6a07810555.png" alt="I(\pi)">), она наиболее ясно раскрывает математическую суть, на которой основана идея подсчёта классов эквивалентности.<p><h3 style="padding-top:15px;">Доказательство леммы Бернсайда</h3><p>Описанное здесь доказательство леммы Бернсайда не так важно для её понимания и применения на практике, поэтому его можно пропустить при первом чтении.<p>Приведённое здесь доказательство является самым простым из известных и не использует теорию групп. Это доказательство было опубликовано Богартом (Bogart) и Кеннетом (Kenneth) в 1991 г.<p>Итак, нам нужно доказать следующее утверждение:<p><p class=formula><img class=tex src="../tex2png/cache/8924cf4baef5ac483adac26d0bbafd9f.png" alt=" {\rm ClassesCount} |G| = \sum_{\pi \in G} I(\pi) "></p><p>Величина, стоящая справа &mdash; это не что иное, как количество "инвариантных пар" <img class=tex src="../tex2png/cache/5a6e2e5ad10a662760ebfc5ca884e397.png" alt="(f, \pi)">, т.е. таких пар, что <img class=tex src="../tex2png/cache/adada188ee31cf7addd7dfb390811d75.png" alt="f \pi \equiv f">. Очевидно, что в формуле мы имеем право изменить порядок суммирования - сделать внешнюю сумму по элементам f, а внутри неё поставить величину <img class=tex src="../tex2png/cache/f35a421a4698c8edd3c66db389f96b73.png" alt="J(f)"> &mdash; количество перестановок, относительно которых f инвариантна:<p><p class=formula><img class=tex src="../tex2png/cache/f1eb0662efd9a0db4cf5e14e09ca55af.png" alt=" {\rm ClassesCount} |G| = \sum_{f} J(f) "></p><p>Для доказательства этой формулы составим таблицу, столбцы которой будут подписаны всеми значениями <img class=tex src="../tex2png/cache/87fce7c1b08ec1bf7a0d6c116c4c586f.png" alt="f_i">, строки &mdash; всеми перестановками <img class=tex src="../tex2png/cache/caaa427d435e1ac6c07ab8f63c7c7e1c.png" alt="\pi_j">, а в клетках таблицы будут стоять произведения <img class=tex src="../tex2png/cache/adabd2eed6dc71db0a36c9dfe369f0d3.png" alt="f_i \pi_j">. Тогда, если мы будем рассматривать столбцы этой таблицы как множества, то некоторые из них могут совпасть, и это будет как означать, что соответствующие этим столбцам <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> также эквивалентны. Таким образом, количество различных как множество столбцов равно искомой величине <img class=tex src="../tex2png/cache/cce2b3fb29379cb4c33862c376e3ad34.png" alt="\rm ClassesCount">. Кстати говоря, с точки зрения теории групп столбец таблицы, подписанный некоторым элементом <img class=tex src="../tex2png/cache/87fce7c1b08ec1bf7a0d6c116c4c586f.png" alt="f_i"> &mdash; это орбита этого элемента; для эквивалентных элементов, очевидно, орбиты совпадают, и число различных орбит даёт именно <img class=tex src="../tex2png/cache/cce2b3fb29379cb4c33862c376e3ad34.png" alt="\rm ClassesCount">.<p>Итак, столбцы таблицы сами распадаются на классы эквивалентности; зафиксируем теперь какой-либо класс и рассмотрим столбцы в нём. Во-первых, заметим, что в этих столбцах могут стоять только элементы <img class=tex src="../tex2png/cache/87fce7c1b08ec1bf7a0d6c116c4c586f.png" alt="f_i"> одного класса эквивалентности (иначе получилось бы, что некоторым эквивалентным преобразованием <img class=tex src="../tex2png/cache/caaa427d435e1ac6c07ab8f63c7c7e1c.png" alt="\pi_j"> мы перешли в другой класс эквивалентности, что невозможно). Во-вторых, каждый элемент <img class=tex src="../tex2png/cache/87fce7c1b08ec1bf7a0d6c116c4c586f.png" alt="f_i"> будет встречаться одинаковое число раз во всех столбцах (это также следует из того, что столбцы соответствуют эквивалентным элементам). Отсюда можно сделать вывод, что все столбцы внутри одного класса эквивалентности совпадают друг с другом как мультимножества.<p>Теперь зафиксируем произвольный элемент <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f">. С одной стороны, он встречается в своём столбце ровно <img class=tex src="../tex2png/cache/f35a421a4698c8edd3c66db389f96b73.png" alt="J(f)"> раз (по самому определению <img class=tex src="../tex2png/cache/f35a421a4698c8edd3c66db389f96b73.png" alt="J(f)">). С другой стороны, все столбцы внутри одного класса эквивалентности одинаковы как мультимножества. Следовательно, внутри каждого столбца данного класса эквивалентности любой элемент <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> встречается ровно <img class=tex src="../tex2png/cache/6fd94d8db985f9089eaefafaf0ca2046.png" alt="J(g)"> раз.<p>Таким образом, если мы возьмём произвольным образом от каждого класса эквивалентности по одному столбцу и просуммируем количество элементов в них, то получим, с одной стороны, <img class=tex src="../tex2png/cache/ff7a50a949768970e04f06981918dfa2.png" alt="{\rm ClassesCount} |G|"> (это получается, просто умножив количество столбцов на их размер), а с другой стороны &mdash; сумму величин <img class=tex src="../tex2png/cache/f35a421a4698c8edd3c66db389f96b73.png" alt="J(f)"> по всем <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> (это следует из всех предыдущих рассуждений):<p><p class=formula><img class=tex src="../tex2png/cache/f1eb0662efd9a0db4cf5e14e09ca55af.png" alt=" {\rm ClassesCount} |G| = \sum_{f} J(f) "></p><p>что и требовалось доказать.<p><h2 style="padding-top:40px;">Теорема Пойа. Простейший вариант</h2><p>Теорема <b>Пойа</b> (Polya) является обобщением леммы Бернсайда, к тому же предоставляющая более удобный инструмент для нахождения количества классов эквивалентности. Следует отметить, что ещё до Пойа эта теорема была открыта и доказана Редфилдом (Redfield) в 1927 г., однако его публикация прошла незамеченной математиками того времени. Пойа независимо пришёл к тому же результату лишь в 1937 г., и его публикация была более удачной.<p>Здесь мы рассмотрим формулу, получающуюся как частный случай теоремы Пойа, и которую очень удобно использовать для вычислений на практике. Общая теорема Пойа в данной статье рассматриваться не будет.<p>Обозначим через <img class=tex src="../tex2png/cache/f9d17c607a73904049f641e03f975b0b.png" alt="C(\pi)"> количество циклов в перестановке <img class=tex src="../tex2png/cache/c3fa15d88e1f1538bca2b2a502cac196.png" alt="\pi">. Тогда выполняется следующая формула (<b>частный случай теоремы Пойа</b>):<p><p class=formula><img class=tex src="../tex2png/cache/672c02e9978a242fb1414fb77176eef9.png" alt=" {\rm ClassesCount} = \frac{1}{|G|} \sum_{\pi \in [...]"></p><p>где <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> &mdash; количество значений, которые может принимать каждый элемент представления <img class=tex src="../tex2png/cache/418a1d86dab3c90ab1dbc6cd23cb11da.png" alt="f(v)">. Например, в нашей задаче-примере (раскраска корневого бинарного дерева в 2 цвета) <img class=tex src="../tex2png/cache/4eee04dc9a729aa9a9562138e64d6a9d.png" alt="k = 2">.<p><h3 style="padding-top:15px;">Доказательство</h3><p>Эта формула является прямым следствием леммы Бернсайда. Чтобы получить её, нам надо просто найти явное выражение для величины <img class=tex src="../tex2png/cache/e7699fc360674c9299880a6a07810555.png" alt="I(\pi)">, фигурирующую в лемме (напомним, это количество неподвижных точек перестановки <img class=tex src="../tex2png/cache/c3fa15d88e1f1538bca2b2a502cac196.png" alt="\pi">).<p>Итак, рассмотрим некоторую перестановку <img class=tex src="../tex2png/cache/c3fa15d88e1f1538bca2b2a502cac196.png" alt="\pi"> и некоторый элемент <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f">. Под действием перестановки <img class=tex src="../tex2png/cache/c3fa15d88e1f1538bca2b2a502cac196.png" alt="\pi"> элементы <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> передвигаются, как известно, по циклам перестановки. Заметим, что так как в результате должно получаться <img class=tex src="../tex2png/cache/b33a5c9e2a43b264ed1e91ae80ea88e2.png" alt="f \equiv f \pi">, то внутри каждого цикла перестановки должны находиться одинаковые элементы <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f">. В то же время, для разных циклов никакой связи между значениями элементов не возникает. Таким образом, для каждого цикла перестановки <img class=tex src="../tex2png/cache/c3fa15d88e1f1538bca2b2a502cac196.png" alt="\pi"> мы выбираем по одному значению (среди <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> вариантов), и тем самым мы получим все представления <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f">, инвариантные относительно этой перестановки, т.е.:<p><p class=formula><img class=tex src="../tex2png/cache/a3e5ba1ace447a09f89067708025eca2.png" alt=" I(\pi) = k ^ {C(\pi)} "></p><p>где <img class=tex src="../tex2png/cache/f9d17c607a73904049f641e03f975b0b.png" alt="C(\pi)"> &mdash; количество циклов перестановки.<p><h2 style="padding-top:40px;">Пример задачи: Ожерелья</h2><p>Задача "ожерелья" &mdash; это одна из классических комбинаторных задач. Требуется посчитать количество различных ожерелий из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> бусинок, каждая из которых может быть покрашена в один из <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> цветов. При сравнении двух ожерелий их можно поворачивать, но не переворачивать (т.е. разрешается сделать циклический сдвиг).<p>В этой задаче мы можем сразу найти группу инвариантных перестановок. Очевидно, она будет состоять из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> перестановок:<p><p class=formula><img class=tex src="../tex2png/cache/a9074b2f09a28c3f03848d826dee4db4.png" alt=" \pi_0 = 1\ 2\ 3\ \ldots\ n "><br><img class=tex src="../tex2png/cache/f905357ad7c1f7d53ffeaacf843a6097.png" alt=" \pi_1 = 2\ 3\ \ldots\ n\ 1 "><br><img class=tex src="../tex2png/cache/ec6c30c2f8102e02a0f284cb67348ea4.png" alt=" \pi_2 = 3\ \ldots\ n\ 1\ 2 "><br><img class=tex src="../tex2png/cache/3ee865b5cc661e7f1c429bc56246d9cf.png" alt=" \ldots "><br><img class=tex src="../tex2png/cache/8a22fbcd3b0f6f1e7f8325a3a55a425b.png" alt=" \pi_{n-1} = n\ 1\ 2\ \ldots\ (n-1) "></p><p>Найдём явную формулу для вычисления <img class=tex src="../tex2png/cache/b5334f4af10fb6971800dc3d4ccad154.png" alt="C(\pi_i)">. Во-первых, заметим, что перестановки имеют такой вид, что в <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой перестановке на <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">-ой позиции стоит <img class=tex src="../tex2png/cache/9a24a1a6fff9bf29cc0f8b96d5eed7f4.png" alt="i+j"> (взятое по модулю <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, если оно больше <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">). Если мы будем рассматривать циклическую структуру <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой перестановки, то увидим, что единица переходит в <img class=tex src="../tex2png/cache/5a151a6243dcc76e5e73bbf6dd8ef3e9.png" alt="1+i">, <img class=tex src="../tex2png/cache/5a151a6243dcc76e5e73bbf6dd8ef3e9.png" alt="1+i"> переходит в <img class=tex src="../tex2png/cache/69d3a54d126934cb46286f688fd6c3b8.png" alt="1+2i">, <img class=tex src="../tex2png/cache/69d3a54d126934cb46286f688fd6c3b8.png" alt="1+2i"> &mdash; в <img class=tex src="../tex2png/cache/77337a267a09bf2af23bade2c5cad584.png" alt="1+3i">, и т.д., пока не придём в число <img class=tex src="../tex2png/cache/2b67432c66246e849226209ceb5c4cca.png" alt="1 + kn">; для остальных элементов выполняются похожие утверждения. Отсюда можно понять, что все циклы имеют одинаковую длину, равную <img class=tex src="../tex2png/cache/5d3b91d2e81ef7616ea19c9c682ebe96.png" alt="{\rm lcm}(i,n) / i">, т.е. <img class=tex src="../tex2png/cache/759e322c3325f4aa4db0dafbd4254d23.png" alt="n / {\rm gcd}(i,n)"> ("gcd" &mdash; наибольший общий делитель, "lcm" &mdash; наименьшее общее кратное). Тогда количество циклов в <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой перестановке будет равно просто <img class=tex src="../tex2png/cache/bbac9caed8d120bcf65ef900716f035e.png" alt="{\rm gcd}(i,n)">.<p>Подставляя найденные значения в теорему Пойа, получаем <b>решение</b>:<p><p class=formula><img class=tex src="../tex2png/cache/e0b152e43f0be6d9e7053898f3c06c3a.png" alt=" {\rm Ans} = \frac{1}{n} \sum_{i=1}^{n} k ^ {{\rm [...]"></p><p>Можно оставить формулу в таком виде, а можно её свернуть ещё больше. Перейдём от суммы по всем <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> к сумме только по делителям <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Действительно, в нашей сумме будет много одинаковых слагаемых: если <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> не является делителем <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, то таковой делитель найдётся после вычисления <img class=tex src="../tex2png/cache/bbac9caed8d120bcf65ef900716f035e.png" alt="{\rm gcd}(i,n)">. Следовательно, для каждого делителя <img class=tex src="../tex2png/cache/a05131f9fd73ffae7121e74d3f34c7f9.png" alt="d|n"> его слагаемое <img class=tex src="../tex2png/cache/fd9595c92c7179e65b855624ff413c63.png" alt="k^{{\rm gcd}(d,n)} = k^d"> учтётся несколько раз, т.е. сумму можно представить в таком виде:<p><p class=formula><img class=tex src="../tex2png/cache/bf7e43830530d3b2afa67c0da7a33e81.png" alt=" {\rm Ans} = \frac{1}{n} \sum_{d|n} C_d k^d "></p><p>где <img class=tex src="../tex2png/cache/d89bf8f6f1591794041e9517f1aa4ff2.png" alt="C_d"> &mdash; это количество таких чисел <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, что <img class=tex src="../tex2png/cache/0faab43f8e08f0dce2702de248bd0369.png" alt="{\rm gcd}(i,n) = d">. Найдём явное выражение для этого количества. Любое такое число <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> имеет вид: <img class=tex src="../tex2png/cache/21a08df6e0ca5d8656bbe492baca143e.png" alt="i=dj">, где <img class=tex src="../tex2png/cache/23048ff8e12ad66337a24cfc56103eb2.png" alt="{\rm gcd}(j,n/d) = 1"> (иначе было бы <img class=tex src="../tex2png/cache/710ed56962ad42c9a7e232656d332632.png" alt="{\rm gcd}(i,n) > d">). Вспоминая <a href="euler_function.html">функцию Эйлера</a>, мы находим, что количество таких <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> &mdash; это величина функции Эйлера <img class=tex src="../tex2png/cache/b230cc66afd7c6121af47c4a58ba4994.png" alt="\phi(n/d)">. Таким образом, <img class=tex src="../tex2png/cache/9b3f7d112ec638e6044f3b01996b364a.png" alt="C_d = \phi(n/d)">, и окончательно получаем <b>формулу</b>:<p><p class=formula><img class=tex src="../tex2png/cache/ad458f2bd2699770aebbace01f10d35d.png" alt=" {\rm Ans} = \frac{1}{n} \sum_{d|n} \phi \left( \f[...]"></p><p><h2 style="padding-top:40px;">Применение леммы Бернсайда совместно с программными вычислениями</h2><p>Далеко не всегда удаётся чисто аналитическим путём получить явную формулу для количества классов эквивалентности. Во многих задачах количество перестановок, входящих в группу, может быть слишком большим для ручных вычислений, и вычислить аналитически количество циклов в них не представляется возможным.<p>В таком случае следует вручную найти несколько "основных" перестановок, которых будет достаточно для порождения всей группы <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">. Далее можно написать программу, которая сгенерирует все перестановки группы <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">, посчитает в каждой из них количество циклов и подставит их в формулу.<p>Рассмотрим для примера <b>задачу о количестве раскрасок тора</b>. Имеется прямоугольный клетчатый лист бумаги <img class=tex src="../tex2png/cache/ed0e13f7024ff254a4fccd689fe21ad3.png" alt="n \times m"> <img class=tex src="../tex2png/cache/ce56dc023cc39cd87a56298a90c9dd34.png" alt="(n < m)">, некоторые из клеток покрашены в чёрный цвет. Затем из этого листа получают цилиндр, склеивая две стороны с длинами <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m">. Затем из цилиндра получают тор, склеивая две окружности (базы цилиндра) без перекручивания. Требуется посчитать количество различных торов (лист был изначально покрашен произвольно), считая, что линии склеивания неразличимы, а тор можно поворачивать и переворачивать.<p>В данной задаче представлением можно считать лист бумаги <img class=tex src="../tex2png/cache/ed0e13f7024ff254a4fccd689fe21ad3.png" alt="n \times m">, некоторые клетки которого покрашены в чёрный цвет. Нетрудно понять, что следующие виды преобразований сохраняют класс эквивалентности: циклический сдвиг строк листа, циклический сдвиг столбцов листа, поворот листа на 180 градусов; также интуитивно можно понять, что этих трёх видов преобразований достаточно для порождения всей группы инвариантных преобразований. Если мы каким-либо образом занумеруем клетки поля, то мы можем записать три перестановки <img class=tex src="../tex2png/cache/3004a92c72fcce1f45bc5afc7f7e1503.png" alt="p_1">, <img class=tex src="../tex2png/cache/55e7fe9f49847b40636ecb9b2bb094a2.png" alt="p_2">, <img class=tex src="../tex2png/cache/4907325b95d05d8255927a2de5429323.png" alt="p_3">, соответствующие этим видам преобразований. Дальше остаётся только сгенерировать все перестановки, получающиеся как произведения этой. Очевидно, что все такие перестановки имеют вид <img class=tex src="../tex2png/cache/a82e8bb93f83c7609785392304624927.png" alt="p_1^{i_1} p_2^{i_2} p_3^{i_3}">, где <img class=tex src="../tex2png/cache/ac4044418151dfb3d75b08f18071c875.png" alt="i_1 = 0 \ldots m-1">, <img class=tex src="../tex2png/cache/8de02b89b62b37bb0b5e70de98b672ab.png" alt="i_2 = 0 \ldots n-1">, <img class=tex src="../tex2png/cache/d024cce87f387c8ecbcb037ac47669f5.png" alt="i_3 = 0 \ldots 1">.<p>Таким образом, мы можем написать реализацию решения этой задачи:<p><pre class="notranslate cpp"><span class="kw4">void</span> mult <span class="br0">&#40;</span>vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> a, <span class="kw4">const</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> aa <span class="br0">&#40;</span>a<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> aa<span class="br0">&#91;</span>b<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> cnt_cycles <span class="br0">&#40;</span>vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> a<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> res <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="sy2">++</span>res<span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> j<span class="sy1">=</span>i<span class="sy4">;</span> a<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="sy3">!</span><span class="sy1">=</span><span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> <span class="br0">&#41;</span> <span class="br0">&#123;</span>
				<span class="kw4">size_t</span> nj <span class="sy1">=</span> a<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="sy4">;</span>
				a<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
				j <span class="sy1">=</span> nj<span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
	<span class="kw1">return</span> res<span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n, m<span class="sy4">;</span>
	<span class="kw3">cin</span> <span class="sy1">&gt;&gt;</span> n <span class="sy1">&gt;&gt;</span> m<span class="sy4">;</span>
&nbsp;
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> p <span class="br0">&#40;</span>n<span class="sy2">*</span>m<span class="br0">&#41;</span>,  p1 <span class="br0">&#40;</span>n<span class="sy2">*</span>m<span class="br0">&#41;</span>,  p2 <span class="br0">&#40;</span>n<span class="sy2">*</span>m<span class="br0">&#41;</span>,  p3 <span class="br0">&#40;</span>n<span class="sy2">*</span>m<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy2">*</span>m<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		p<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
		p1<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="br0">&#40;</span>i <span class="sy2">%</span> n <span class="sy2">+</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy2">%</span> n <span class="sy2">+</span> i <span class="sy2">/</span> n <span class="sy2">*</span> n<span class="sy4">;</span>
		p2<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="br0">&#40;</span>i <span class="sy2">/</span> n <span class="sy2">+</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy2">%</span> m <span class="sy2">*</span> n <span class="sy2">+</span> i <span class="sy2">%</span> n<span class="sy4">;</span>
		p3<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="br0">&#40;</span>m <span class="sy2">-</span> <span class="nu0">1</span> <span class="sy2">-</span> i <span class="sy2">/</span> n<span class="br0">&#41;</span> <span class="sy2">*</span> n <span class="sy2">+</span> <span class="br0">&#40;</span>n <span class="sy2">-</span> <span class="nu0">1</span> <span class="sy2">-</span> i <span class="sy2">%</span> n<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw4">int</span> sum <span class="sy1">=</span> <span class="nu0">0</span>,  cnt <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	set <span class="sy1">&lt;</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> s<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i1<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i1<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i1<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i2<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i2<span class="sy1">&lt;</span>m<span class="sy4">;</span> <span class="sy2">++</span>i2<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i3<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i3<span class="sy1">&lt;</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>i3<span class="br0">&#41;</span> <span class="br0">&#123;</span>
				<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>s.<span class="me1">count</span><span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
					s.<span class="me1">insert</span> <span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy4">;</span>
					<span class="sy2">++</span>cnt<span class="sy4">;</span>
					sum <span class="sy2">+</span><span class="sy1">=</span> <span class="nu0">1</span> <span class="sy1">&lt;&lt;</span> cnt_cycles<span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy4">;</span>
				<span class="br0">&#125;</span>
				mult <span class="br0">&#40;</span>p, p3<span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
			mult <span class="br0">&#40;</span>p, p2<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
		mult <span class="br0">&#40;</span>p, p1<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> sum <span class="sy2">/</span> cnt<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>