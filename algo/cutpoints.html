<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Поиск точек сочленения</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 5 Jul 2008 22:26<br>редактировано: 6 Dec 2012 1:41</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="cutpoints.html#" id="contents-hide">[скрыть]</a><a href="cutpoints.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Поиск точек сочленения</h1><p>Пусть дан связный неориентированный граф. <b>Точкой сочленения</b> (или точкой артикуляции, англ. "cut vertex" или "articulation point") называется такая вершина, удаление которой делает граф несвязным.<p>Опишем алгоритм, основанный на поиске в глубину, работающий за <img class=tex src="../tex2png/cache/d20d4ea468976eeb83adea753c1fd674.png" alt="O(n+m)">, где <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> &mdash; количество вершин, <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> &mdash; рёбер.<p><p><h2 style="padding-top:40px;">Алгоритм</h2><p>Запустим обход в глубину из произвольной вершины графа; обозначим её через <img class=tex src="../tex2png/cache/40e0e810bf54145c555375778ebb3918.png" alt="\rm root">. Заметим следующий <b>факт</b> (который несложно доказать):<p><ul><p><li>Пусть мы находимся в обходе в глубину, просматривая сейчас все рёбра из вершины <img class=tex src="../tex2png/cache/bb215b0852e2f46778cf5471088d14f8.png" alt="v \ne {\rm root}">. Тогда, если текущее ребро <img class=tex src="../tex2png/cache/2f71535f4ca1feaf0a836a12914b1d88.png" alt="(v,to)"> таково, что из вершины <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to"> и из любого её потомка в дереве обхода в глубину нет обратного ребра в какого-либо предка вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, то вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> является точкой сочленения. В противном случае, т.е. если обход в глубину просмотрел все рёбра из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, и не нашёл удовлетворяющего вышеописанным условиям ребра, то вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> не является точкой сочленения. (В самом деле, мы этим условием проверяем, нет ли другого пути из <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> в <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to">)<p><li>Рассмотрим теперь оставшийся случай: <img class=tex src="../tex2png/cache/110f23ac57a93cf3f5ba3746f11d55ef.png" alt="v = {\rm root}">. Тогда эта вершина является точкой сочленения тогда и только тогда, когда эта вершина имеет более одного сына в дереве обхода в глубину. (В самом деле, это означает, что, пройдя из <img class=tex src="../tex2png/cache/40e0e810bf54145c555375778ebb3918.png" alt="\rm root"> по произвольному ребру, мы не смогли обойти весь граф, откуда сразу следует, что <img class=tex src="../tex2png/cache/40e0e810bf54145c555375778ebb3918.png" alt="\rm root"> &mdash; точка сочленения).<p></ul><p>(Ср. формулировку этого критерия с формулировкой критерия для <a href="bridge_searching.html">алгоритма поиска мостов</a>.)<p>Теперь осталось научиться проверять этот факт для каждой вершины эффективно. Для этого воспользуемся "временами входа в вершину", вычисляемыми <a href="dfs.html">алгоритмом поиска в глубину</a>.<p>Итак, пусть <img class=tex src="../tex2png/cache/2d830e71aff0814b8aa3d42124ec9dfb.png" alt="tin[v]"> &mdash; это время захода поиска в глубину в вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Теперь введём массив <img class=tex src="../tex2png/cache/c747353f9543d5d792489fcee7ff737d.png" alt="fup[v]">, который и позволит нам отвечать на вышеописанные запросы. Время <img class=tex src="../tex2png/cache/c747353f9543d5d792489fcee7ff737d.png" alt="fup[v]"> равно минимуму из времени захода в саму вершину <img class=tex src="../tex2png/cache/2d830e71aff0814b8aa3d42124ec9dfb.png" alt="tin[v]">, времён захода в каждую вершину <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">, являющуюся концом некоторого обратного ребра <img class=tex src="../tex2png/cache/280a9f96777575fe759d7ab0102ae1ed.png" alt="(v,p)">, а также из всех значений <img class=tex src="../tex2png/cache/a34ea9edd56d195a7dbdc722d58b8ca0.png" alt="fup[to]"> для каждой вершины <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to">, являющейся непосредственным сыном <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> в дереве поиска:<p><p class=formula><img class=tex src="../tex2png/cache/ec0a7c417df6f6cbc5ef762cd909127f.png" alt=" fup[v] = \min \cases{
tin[v], & \cr
tin[p], & {[...]"></p><p>(здесь "back edge" &mdash; обратное ребро, "tree edge" &mdash; ребро дерева)<p>Тогда, из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> или её потомка есть обратное ребро в её предка тогда и только тогда, когда найдётся такой сын <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to">, что <img class=tex src="../tex2png/cache/4668070cee8195bb489b9cd83880c777.png" alt="fup[to] < tin[v]">.<p>Таким образом, если для текущего ребра <img class=tex src="../tex2png/cache/2f71535f4ca1feaf0a836a12914b1d88.png" alt="(v,to)"> (принадлежащего дереву поиска) выполняется <img class=tex src="../tex2png/cache/c4cf8fb1cc6cdf5f96a0d86bb40fe5ca.png" alt="fup[to] \ge tin[v]">, то вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> является точкой сочленения. Для начальной вершины <img class=tex src="../tex2png/cache/110f23ac57a93cf3f5ba3746f11d55ef.png" alt="v = {\rm root}"> критерий другой: для этой вершины надо посчитать число непосредственных сыновей в дереве обхода в глубину.<p><p><h2 style="padding-top:40px;">Реализация</h2><p>Если говорить о самой реализации, то здесь нам нужно уметь различать три случая: когда мы идём по ребру дерева поиска в глубину, когда идём по обратному ребру, и когда пытаемся пойти по ребру дерева в обратную сторону. Это, соответственно, случаи <img class=tex src="../tex2png/cache/03b3b76b6aaa98e192434fcfb43b8fd2.png" alt="used[to]=false">, <img class=tex src="../tex2png/cache/a28adb925d996e6273469770655e6025.png" alt="used[to]=true ~ \&\& ~ to \ne parent">, и <img class=tex src="../tex2png/cache/b44e606054db96833dd49f901df1089d.png" alt="to=parent">. Таким образом, нам надо передавать в функцию поиска в глубину вершину-предка текущей вершины.<p><pre class="notranslate cpp">vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> g<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">bool</span> used<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">int</span> timer, tin<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, fup<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> dfs <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> p <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	used<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
	tin<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> fup<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> timer<span class="sy2">++</span><span class="sy4">;</span>
	<span class="kw4">int</span> children <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> to <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>to <span class="sy1">==</span> p<span class="br0">&#41;</span>  <span class="kw1">continue</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>used<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span>
			fup<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> min <span class="br0">&#40;</span>fup<span class="br0">&#91;</span>v<span class="br0">&#93;</span>, tin<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">else</span> <span class="br0">&#123;</span>
			dfs <span class="br0">&#40;</span>to, v<span class="br0">&#41;</span><span class="sy4">;</span>
			fup<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> min <span class="br0">&#40;</span>fup<span class="br0">&#91;</span>v<span class="br0">&#93;</span>, fup<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>fup<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">&gt;=</span> tin<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy3">&amp;&amp;</span> p <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
				IS_CUTPOINT<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="sy2">++</span>children<span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>p <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> children <span class="sy1">&gt;</span> <span class="nu0">1</span><span class="br0">&#41;</span>
		IS_CUTPOINT<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n<span class="sy4">;</span>
	... чтение n и g ...
&nbsp;
	<span class="me1">timer</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		used<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span>
	dfs <span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Здесь константе <img class=tex src="../tex2png/cache/f60813472f21f2839a771339816c6804.png" alt="\rm MAXN"> должно быть задано значение, равное максимально возможному числу вершин во входном графе.<p>Функция <img class=tex src="../tex2png/cache/c02dbe86f312ec106021dcec15864c5c.png" alt="{\rm IS\_CUTPOINT}(v)"> в коде &mdash; это некая функция, которая будет реагировать на то, что вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> является точкой сочленения, например, выводить эту вершины на экран (надо учитывать, что для одной и той же вершины эта функция может быть вызвана несколько раз).<p><p><h2 style="padding-top:40px;">Задачи в online judges</h2><p>Список задач, в которых требуется искать точки сочленения:<p><ul><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=13&page=show_problem&problem=1140">UVA #10199 <b>"Tourist Guide"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=5&page=show_problem&problem=251">UVA #315 <b>"Network"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a></ul><p><p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>