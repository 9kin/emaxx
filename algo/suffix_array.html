<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Суффиксный массив</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 22 Jun 2008 13:37<br>редактировано: 1 Oct 2012 12:46</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="suffix_array.html#" id="contents-hide">[скрыть]</a><a href="suffix_array.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Суффиксный массив </h1><p>Дана строка <img class=tex src="../tex2png/cache/0697d6e9689fa1f0f0cf71d3a81c61e0.png" alt="s[0 \ldots n-1]"> длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">.<p><img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ым <b>суффиксом</b> строки называется подстрока <img class=tex src="../tex2png/cache/85e46e70be2dd41f5bf34c3be9ad6c6a.png" alt="s[i \ldots n-1]">, <img class=tex src="../tex2png/cache/4c4774df26fa3ba9766d58b6c7474f71.png" alt="i=0 \ldots n-1">.<p>Тогда <b>суффиксным массивом</b> строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> называется перестановка индексов суффиксов <img class=tex src="../tex2png/cache/9ff50b5f8fed0fbedd5d2edbbbd08679.png" alt="p[0 \ldots n-1]">, <img class=tex src="../tex2png/cache/e8f4fad19b8d85ed98637540f6e69db3.png" alt="p[i] \in [0;n-1]">, которая задаёт порядок суффиксов в порядке лексикографической сортировки. Иными словами, нужно выполнить сортировку всех суффиксов заданной строки.<p>Например, для строки <img class=tex src="../tex2png/cache/a9c6ee9950594c7b5613327466d7e806.png" alt="s=abaab"> суффиксный массив будет равен:<p><p class=formula><img class=tex src="../tex2png/cache/003b2f83347c306e6ccc4ed65b61a347.png" alt=" (2,3,0,4,1) "><p></p><p><h2 style="padding-top:40px;"> Построение за <img class=tex src="../tex2png/cache/a11776a13135ae4d7d1007f97b9b95c4.png" alt="O (n \log n)"> </h2><p>Строго говоря, описываемый ниже алгоритм будет выполнять сортировку не суффиксов, а <b>циклических сдвигов</b> строки. Однако из этого алгоритма легко получить и алгоритм сортировки суффиксов: достаточно приписать в конец строки произвольный символ, который заведомо меньше любого символа, из которого может состоять строка (например, это может быть доллар или шарп; в языке C в этих целях можно использовать уже имеющийся нулевой символ).<p>Сразу заметим, что поскольку мы сортируем циклические сдвиги, то и подстроки мы будем рассматривать <b>циклические</b>: под подстрокой <img class=tex src="../tex2png/cache/1da9aede35685d45e082c44a363fe070.png" alt="s[i \ldots j]">, когда <img class=tex src="../tex2png/cache/dd61558730f28cc2b28d7f514d2f6c31.png" alt="i > j">, понимается подстрока <img class=tex src="../tex2png/cache/c6ae5521942d8312724f71a41cf27571.png" alt="s[i \ldots n-1] + s[0 \ldots j]">. Кроме того, предварительно все индексы берутся по модулю длины строки (в целях упрощения формул я буду опускать явные взятия индексов по модулю).<p>Рассматриваемый нами алгоритм состоит из примерно <img class=tex src="../tex2png/cache/6839f55793e4e69dcc7f4ca7caed0770.png" alt="\log n"> фаз. На <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ой фазе (<img class=tex src="../tex2png/cache/ea4699f48f120ab4d54fa0e064bd91c9.png" alt="k = 0 \ldots \lceil \log n \rceil">) сортируются циклические подстроки длины <img class=tex src="../tex2png/cache/a631b6ee74bdfc6711813da7ca95a648.png" alt="2^k">. На последней, <img class=tex src="../tex2png/cache/03effa12c104c5aeccb4b45e5f5d249a.png" alt="\lceil \log n \rceil">-ой фазе, будут сортироваться подстроки длины <img class=tex src="../tex2png/cache/defd18f561fd55b56602435d7e318952.png" alt="2^{\lceil \log n \rceil} > n">, что эквивалентно сортировке циклических сдвигов.<p>На каждой фазе алгоритм помимо перестановки <img class=tex src="../tex2png/cache/9ff50b5f8fed0fbedd5d2edbbbd08679.png" alt="p[0 \ldots n-1]"> индексов циклических подстрок будет поддерживать для каждой циклической подстроки, начинающейся в позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> с длиной <img class=tex src="../tex2png/cache/a631b6ee74bdfc6711813da7ca95a648.png" alt="2^k">, <b>номер <img class=tex src="../tex2png/cache/f32ed290849269d380c1c6a66e03871d.png" alt="c[i]"> класса эквивалентности</b>, которому эта подстрока принадлежит. В самом деле, среди подстрок могут быть одинаковые, и алгоритму понадобится информация об этом. Кроме того, номера <img class=tex src="../tex2png/cache/f32ed290849269d380c1c6a66e03871d.png" alt="c[i]"> классов эквивалентности будем давать таким образом, чтобы они сохраняли и информацию о порядке: если один суффикс меньше другого, то и номер класса он должен получить меньший. Классы будем для удобства нумеровать с нуля. Количество классов эквивалентности будем хранить в переменной <img class=tex src="../tex2png/cache/a41c265c26f4c2791a90a37d3e8dccce.png" alt="\rm classes">.<p>Приведём <b>пример</b>. Рассмотрим строку <img class=tex src="../tex2png/cache/541c29ebff120cbadc3875734f1a22f3.png" alt="s=aaba">. Значения массивов <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]"> и <img class=tex src="../tex2png/cache/d9e2aa831637d909843d3ec6bd160813.png" alt="c[]"> на каждой стадии с нулевой по вторую таковы:<p><p class=formula><img class=tex src="../tex2png/cache/b552590d87133a6efaf56d021b120bf7.png" alt=" \matrix{
0: & p=(0,1,3,2) & c=(0,0,1,0) \cr
1: [...]"></p><p>Стоит отметить, что в массиве <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]"> возможны неоднозначности. Например, на нулевой фазе массив мог равняться: <img class=tex src="../tex2png/cache/60eba6a6f1216211289229c99ea56e59.png" alt="p=(3,1,0,2)">. То, какой именно вариант получится, зависит от конкретной реализации алгоритма, но все варианты одинаково правильны. В то же время, в массиве <img class=tex src="../tex2png/cache/d9e2aa831637d909843d3ec6bd160813.png" alt="c[]"> никаких неоднозначностей быть не могло.<p>Перейдём теперь к построению <b>алгоритма</b>. Входные данные:<p><pre class="notranslate cpp"><span class="kw4">char</span> <span class="sy2">*</span>s<span class="sy4">;</span> <span class="co1">// входная строка</span>
<span class="kw4">int</span> n<span class="sy4">;</span> <span class="co1">// длина строки</span>
&nbsp;
<span class="co1">// константы</span>
<span class="kw4">const</span> <span class="kw4">int</span> maxlen <span class="sy1">=</span> ...<span class="sy4">;</span> <span class="co1">// максимальная длина строки</span>
<span class="kw4">const</span> <span class="kw4">int</span> alphabet <span class="sy1">=</span> <span class="nu0">256</span><span class="sy4">;</span> <span class="co1">// размер алфавита, &lt;= maxlen</span></pre><p>На <b>нулевой фазе</b> мы должны отсортировать циклические подстроки длины <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1">, т.е. отдельные символы строки, и разделить их на классы эквивалентности (просто одинаковые символы должны быть отнесены к одному классу эквивалентности). Это можно сделать тривиально, например, сортировкой подсчётом. Для каждого символа посчитаем, сколько раз он встретился. Потом по этой информации восстановим массив <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]">. После этого, проходом по массиву <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]"> и сравнением символов, строится массив <img class=tex src="../tex2png/cache/d9e2aa831637d909843d3ec6bd160813.png" alt="c[]">.<p><pre class="notranslate cpp"><span class="kw4">int</span> p<span class="br0">&#91;</span>maxlen<span class="br0">&#93;</span>, cnt<span class="br0">&#91;</span>maxlen<span class="br0">&#93;</span>, c<span class="br0">&#91;</span>maxlen<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw3">memset</span> <span class="br0">&#40;</span>cnt, <span class="nu0">0</span>, alphabet <span class="sy2">*</span> <span class="kw3">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	<span class="sy2">++</span>cnt<span class="br0">&#91;</span>s<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>alphabet<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	cnt<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> cnt<span class="br0">&#91;</span>i<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	p<span class="br0">&#91;</span><span class="sy2">--</span>cnt<span class="br0">&#91;</span>s<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
c<span class="br0">&#91;</span>p<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw4">int</span> classes <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>s<span class="br0">&#91;</span>p<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> s<span class="br0">&#91;</span>p<span class="br0">&#91;</span>i<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#41;</span>  <span class="sy2">++</span>classes<span class="sy4">;</span>
	c<span class="br0">&#91;</span>p<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> classes<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Далее, пусть мы выполнили <img class=tex src="../tex2png/cache/658627816b5be3d0859b8d0d52d03fd5.png" alt="k-1">-ю фазу (т.е. вычислили значения массивов <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]"> и <img class=tex src="../tex2png/cache/d9e2aa831637d909843d3ec6bd160813.png" alt="c[]"> для неё), теперь научимся за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> выполнять <b>следующую, <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ю, фазу</b>. Поскольку фаз всего <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)">, это даст нам требуемый алгоритм с временем <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">.<p>Для этого заметим, что циклическая подстрока длины <img class=tex src="../tex2png/cache/a631b6ee74bdfc6711813da7ca95a648.png" alt="2^k"> состоит из двух подстрок длины <img class=tex src="../tex2png/cache/97c42e4ca4ce993e5a52c7ece2343aaa.png" alt="2^{k-1}">, которые мы можем сравнивать между собой за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)">, используя информацию с предыдущей фазы &mdash; номера <img class=tex src="../tex2png/cache/d9e2aa831637d909843d3ec6bd160813.png" alt="c[]"> классов эквивалентности. Таким образом, для подстроки длины <img class=tex src="../tex2png/cache/a631b6ee74bdfc6711813da7ca95a648.png" alt="2^k">, начинающейся в позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, вся необходимая информация содержится в паре чисел <img class=tex src="../tex2png/cache/7d3622c6b869befe0a3e699e99cd3e0f.png" alt="(c[i], c[i+2^{k-1}])"> (повторимся, мы используем массив <img class=tex src="../tex2png/cache/d9e2aa831637d909843d3ec6bd160813.png" alt="c[]"> с предыдущей фазы).<p><p class=formula><img class=tex src="../tex2png/cache/ae516e531e52b79fe882b86e620fd1b3.png" alt=" \ldots \overbrace{ \underbrace{ s_i \ldots s_{i+2[...]"></p><p>Это даёт нам весьма простое решение: <b>отсортировать</b> подстроки длины <img class=tex src="../tex2png/cache/a631b6ee74bdfc6711813da7ca95a648.png" alt="2^k"> просто <b>по</b> этим <b>парам чисел</b>, это и даст нам требуемый порядок, т.е. массив <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]">. Однако обычная сортировка, выполняющаяся за время <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">, нас не устроит &mdash; это даст алгоритм построения суффиксного массива с временем <img class=tex src="../tex2png/cache/c230b655c4512e68886f06f776c0f949.png" alt="O(n \log^2 n)"> (зато этот алгоритм несколько проще в написании, чем описываемый ниже).<p>Как быстро выполнить такую сортировку пар? Поскольку элементы пар не превосходят <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, то можно выполнить сортировку подсчётом. Однако для достижения лучшей скрытой в асимптотике константы вместо сортировки пар придём к сортировке просто чисел.<p>Воспользуемся здесь приёмом, на котором основана так называемая <b>цифровая сортировка</b>: чтобы отсортировать пары, отсортируем их сначала по вторым элементам, а затем &mdash; по первым элементам (но уже обязательно стабильной сортировкой, т.е. не нарушающей относительного порядка элементов при равенстве). Однако отдельно вторые элементы уже упорядочены &mdash; этот порядок задан в массиве <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]"> от предыдущей фазы. Тогда, чтобы упорядочить пары по вторым элементам, надо просто от каждого элемента массива <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]"> отнять <img class=tex src="../tex2png/cache/97c42e4ca4ce993e5a52c7ece2343aaa.png" alt="2^{k-1}"> &mdash; это даст нам порядок сортировки пар по вторым элементам (ведь <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]"> даёт упорядочение подстрок длины <img class=tex src="../tex2png/cache/97c42e4ca4ce993e5a52c7ece2343aaa.png" alt="2^{k-1}">, и при переходе к строке вдвое большей длины эти подстроки становятся их вторыми половинками, поэтому от позиции второй половинки отнимается длина первой половинки).<p>Таким образом, с помощью всего лишь вычитаний от элементов массива <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]"> мы производим сортировку по вторым элементам пар. Теперь надо произвести стабильную сортировку по первым элементам пар, её уже можно выполнить за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> с помощью сортировки подсчётом.<p>Осталось только пересчитать номера <img class=tex src="../tex2png/cache/d9e2aa831637d909843d3ec6bd160813.png" alt="c[]"> классов эквивалентности, но их уже легко получить, просто пройдя по полученной новой перестановке <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]"> и сравнивая соседние элементы (опять же, сравнивая как пары двух чисел).<p>Приведём <b>реализацию</b> выполнения всех фаз алгоритма, кроме нулевой. Вводятся дополнительно временные массивы <img class=tex src="../tex2png/cache/ba321c7c801fdde9ddf231fb127d9c8f.png" alt="pn"> и <img class=tex src="../tex2png/cache/f8663f30934f4e67a0305f82e1cf83ca.png" alt="cn"> (<img class=tex src="../tex2png/cache/ba321c7c801fdde9ddf231fb127d9c8f.png" alt="pn"> &mdash; содержит перестановку в порядке сортировки по вторым элементам пар, <img class=tex src="../tex2png/cache/f8663f30934f4e67a0305f82e1cf83ca.png" alt="cn"> &mdash; новые номера классов эквивалентности).<p><pre class="notranslate cpp"><span class="kw4">int</span> pn<span class="br0">&#91;</span>maxlen<span class="br0">&#93;</span>, cn<span class="br0">&#91;</span>maxlen<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> h<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>h<span class="br0">&#41;</span><span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>h<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		pn<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> p<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">-</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>h<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>pn<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span>  pn<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> n<span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw3">memset</span> <span class="br0">&#40;</span>cnt, <span class="nu0">0</span>, classes <span class="sy2">*</span> <span class="kw3">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="sy2">++</span>cnt<span class="br0">&#91;</span>c<span class="br0">&#91;</span>pn<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>classes<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		cnt<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> cnt<span class="br0">&#91;</span>i<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>n<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&gt;=</span><span class="nu0">0</span><span class="sy4">;</span> <span class="sy2">--</span>i<span class="br0">&#41;</span>
		p<span class="br0">&#91;</span><span class="sy2">--</span>cnt<span class="br0">&#91;</span>c<span class="br0">&#91;</span>pn<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> pn<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
	cn<span class="br0">&#91;</span>p<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	classes <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> mid1 <span class="sy1">=</span> <span class="br0">&#40;</span>p<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">+</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>h<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy2">%</span> n,  mid2 <span class="sy1">=</span> <span class="br0">&#40;</span>p<span class="br0">&#91;</span>i<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy2">+</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>h<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy2">%</span> n<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>c<span class="br0">&#91;</span>p<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> c<span class="br0">&#91;</span>p<span class="br0">&#91;</span>i<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy3">||</span> c<span class="br0">&#91;</span>mid1<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> c<span class="br0">&#91;</span>mid2<span class="br0">&#93;</span><span class="br0">&#41;</span>
			<span class="sy2">++</span>classes<span class="sy4">;</span>
		cn<span class="br0">&#91;</span>p<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> classes<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw3">memcpy</span> <span class="br0">&#40;</span>c, cn, n <span class="sy2">*</span> <span class="kw3">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Этот алгоритм требует <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)"> времени и <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> памяти. Впрочем, если учитывать ещё размер <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> алфавита, то время работы становится <img class=tex src="../tex2png/cache/36370917fd805f22e9b4915fe7c1532e.png" alt="O((n+k) \log n)">, а размер памяти &mdash; <img class=tex src="../tex2png/cache/05381d948ead2de5f00368ec60563daf.png" alt="O(n+k)">.<p><p><h2 style="padding-top:40px;"> Применения </h2><p><p><h3 style="padding-top:15px;"> Нахождение наименьшего циклического сдвига строки </h3><p>Вышеописанный алгоритм производит сортировку циклических сдвигов (если к строке не приписывать доллар), а потому <img class=tex src="../tex2png/cache/13298d26b66ed695fab4fc3fc1f1dbd0.png" alt="p[0]"> даст искомую позицию наименьшего циклического сдвига. Время работы &mdash; <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">.<p><p><h3 style="padding-top:15px;"> Поиск подстроки в строке </h3><p>Пусть требуется в тексте <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> искать строку <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> в режиме онлайн (т.е. заранее строку <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> нужно считать неизвестной). Построим суффиксный массив для текста <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> за <img class=tex src="../tex2png/cache/a812e922c7da34ea16a6a6cff9221ae6.png" alt="O (|t| \log |t|)">. Теперь подстроку <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> будем искать следующим образом: заметим, что искомое вхождение должно быть префиксом какого-либо суффикса <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">. Поскольку суффиксы у нас упорядочены (это даёт нам суффиксный массив), то подстроку <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> можно искать бинарным поиском по суффиксам строки. Сравнение текущего суффикса и подстроки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> внутри бинарного поиска можно производить тривиально, за <img class=tex src="../tex2png/cache/4b0323d726590bcb3041eefd32f23888.png" alt="O(|p|)">. Тогда асимптотика поиска подстроки в тексте становится <img class=tex src="../tex2png/cache/0cd9b7ae3211ce9e2077fd36b43b9bf6.png" alt="O(|p| \log |t|)">.<p><p><h3 style="padding-top:15px;"> Сравнение двух подстрок строки </h3><p>Требуется по заданной строке <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, произведя некоторый её препроцессинг, научиться за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> отвечать на запросы сравнения двух произвольных подстрок (т.е. проверка, что первая подстрока равна/меньше/больше второй).<p>Построим суффиксный массив за <img class=tex src="../tex2png/cache/14b8e5f86f8d6046862dc334a68eb03a.png" alt="O (|s| \log |s|)">, при этом сохраним промежуточные результаты: нам понадобятся массивы <img class=tex src="../tex2png/cache/d9e2aa831637d909843d3ec6bd160813.png" alt="c[]"> от каждой фазы. Поэтому памяти потребуется тоже <img class=tex src="../tex2png/cache/14b8e5f86f8d6046862dc334a68eb03a.png" alt="O (|s| \log |s|)">.<p>Используя эту информацию, мы можем за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> сравнивать любые две подстроки длины, равной степени двойки: для этого достаточно сравнить номера классов эквивалентности из соответствующей фазы. Теперь надо обобщить этот способ на подстроки произвольной длины.<p>Пусть теперь поступил очередной запрос сравнения двух подстрок длины <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> с началами в индексах <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">. Найдём наибольшую длину блока, помещающегося внутри подстроки такой длины, т.е. наибольшее <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> такое, что <img class=tex src="../tex2png/cache/52a402176269d72ac18c08f15425e6de.png" alt="2^k \le l">. Тогда сравнение двух подстрок можно заменить сравнением двух пар перекрывающихся блоков длины <img class=tex src="../tex2png/cache/a631b6ee74bdfc6711813da7ca95a648.png" alt="2^k">: сначала надо сравнить два блока, начинающихся в позициях <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">, а при равенстве &mdash; сравнить два блока, заканчивающихся в позициях <img class=tex src="../tex2png/cache/cda8303e461b97c2f860152dc48a9618.png" alt="i+l-1"> и <img class=tex src="../tex2png/cache/4cfdb88551f1a47864c3d6731b3b1cce.png" alt="j+l-1">:<p><p class=formula><img class=tex src="../tex2png/cache/a53b18ed921ac3f96534ea5531fcace9.png" alt=" \ldots \overbrace{ \underbrace{ s_i \ldots s_{i+l[...]"><br><img class=tex src="../tex2png/cache/a8c229d133c957aca2b6557f91de8f0a.png" alt=" \ldots \overbrace{ s_i \ldots \underbrace{ s_{i+l[...]"></p><p>Таким образом, реализация получается примерно такой (здесь считается, что вызывающая процедура сама вычисляет <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, поскольку сделать это за константное время не так легко (по-видимому, быстрее всего &mdash; предпосчётом), но в любом случае это не имеет отношения к применению суффиксного массива):<p><pre class="notranslate cpp"><span class="kw4">int</span> compare <span class="br0">&#40;</span><span class="kw4">int</span> i, <span class="kw4">int</span> j, <span class="kw4">int</span> l, <span class="kw4">int</span> k<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> a <span class="sy1">=</span> make_pair <span class="br0">&#40;</span>c<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span>, c<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="sy2">+</span>l<span class="sy2">-</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>k<span class="br0">&#41;</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> b <span class="sy1">=</span> make_pair <span class="br0">&#40;</span>c<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>, c<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="sy2">+</span>l<span class="sy2">-</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>k<span class="br0">&#41;</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">return</span> a <span class="sy1">==</span> b <span class="sy4">?</span> <span class="nu0">0</span> <span class="sy4">:</span> a <span class="sy1">&lt;</span> b <span class="sy4">?</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy4">:</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h3 style="padding-top:15px;"> Наибольший общий префикс двух подстрок: способ с дополнительной памятью </h3><p>Требуется по заданной строке <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, произведя некоторый её препроцессинг, научиться за <img class=tex src="../tex2png/cache/dcaa4ec7e17d6b1116ff2b78b84b57fe.png" alt="O(\log |s|)"> отвечать на запросы наибольшего общего префикса (longest common prefix, lcp) для двух произвольных суффиксов с позициями <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">.<p>Способ, описываемый здесь, требует <img class=tex src="../tex2png/cache/14b8e5f86f8d6046862dc334a68eb03a.png" alt="O (|s| \log |s|)"> дополнительной памяти; другой способ, использующий линейный объём памяти, но неконстантное время ответа на запрос, описан в следующем разделе.<p>Построим суффиксный массив за <img class=tex src="../tex2png/cache/14b8e5f86f8d6046862dc334a68eb03a.png" alt="O (|s| \log |s|)">, при этом сохраним промежуточные результаты: нам понадобятся массивы <img class=tex src="../tex2png/cache/d9e2aa831637d909843d3ec6bd160813.png" alt="c[]"> от каждой фазы. Поэтому памяти потребуется тоже <img class=tex src="../tex2png/cache/14b8e5f86f8d6046862dc334a68eb03a.png" alt="O (|s| \log |s|)">.<p>Пусть теперь поступил очередной запрос: пара индексов <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">. Воспользуемся тем, что мы можем за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> сравнивать любые две подстроки длины, являющейся степенью двойки. Для этого будем перебирать степень двойки (от большей к меньшей), и для текущей степени проверять: если подстроки такой длины совпадают, то к ответу прибавить эту степень двойки, а наибольший общий префикс продолжим искать справа от одинаковой части, т.е. к <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> надо прибавить текущую степень двойки.<p>Реализация:<p><pre class="notranslate cpp"><span class="kw4">int</span> lcp <span class="br0">&#40;</span><span class="kw4">int</span> i, <span class="kw4">int</span> j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> ans <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> k<span class="sy1">=</span>log_n<span class="sy4">;</span> k<span class="sy1">&gt;=</span><span class="nu0">0</span><span class="sy4">;</span> <span class="sy2">--</span>k<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>c<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">==</span> c<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			ans <span class="sy2">+</span><span class="sy1">=</span> <span class="nu0">1</span><span class="sy1">&lt;&lt;</span>k<span class="sy4">;</span>
			i <span class="sy2">+</span><span class="sy1">=</span> <span class="nu0">1</span><span class="sy1">&lt;&lt;</span>k<span class="sy4">;</span>
			j <span class="sy2">+</span><span class="sy1">=</span> <span class="nu0">1</span><span class="sy1">&lt;&lt;</span>k<span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="kw1">return</span> ans<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Здесь через <img class=tex src="../tex2png/cache/9e00c89de5a3a4ca489d4f82b6c129f4.png" alt="\rm log\_n"> обозначена константа, равная логарифму <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> по основанию 2, округлённому вниз.<p><p><h3 style="padding-top:15px;"> Наибольший общий префикс двух подстрок: способ без дополнительной памяти. Наибольший общий префикс двух соседних суффиксов </h3><p>Требуется по заданной строке <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, произведя некоторый её препроцессинг, научиться отвечать на запросы наибольшего общего префикса (longest common prefix, lcp) для двух произвольных суффиксов с позициями <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">.<p>В отличие от предыдущего метода, описываемый здесь будет выполнять препроцессинг строки за <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)"> времени с <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> памяти. Результатом этого препроцессинга будет являться массив (который сам по себе является важным источником информации о строке, и потому использоваться для решения других задач). Ответы же на запрос будут производиться как результат выполнения запроса RMQ (минимум на отрезке, range minimum query) в этом массиве, поэтому при разных реализациях можно получить как логарифмическое, так и константное времена работы.<p>Базой для этого алгоритма является следующая идея: найдём каким-нибудь образом наибольшие общие префиксы для каждой <b>соседней в порядке сортировки пары суффиксов</b>. Иными словами, построим массив <img class=tex src="../tex2png/cache/7ccb12a81f3611ba7af3f10d0ab280e7.png" alt="{\rm lcp}[0 \ldots n-2]">, где <img class=tex src="../tex2png/cache/9ef59b64bf22fbd516bcf192980782d8.png" alt="{\rm lcp}[i]"> равен наибольшему общему префиксу суффиксов <img class=tex src="../tex2png/cache/6fa33a48f7fff7f52d08a07ab012145a.png" alt="p[i]"> и <img class=tex src="../tex2png/cache/d006fba63190eb9a53a092d42694a3da.png" alt="p[i+1]">. Этот массив даст нам ответ для любых двух соседних суффиксов строки. Тогда ответ для любых двух суффиксов, не обязательно соседних, можно получить по этому массиву. В самом деле, пусть поступил запрос с некоторыми номерами суффиксов <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">. Найдём эти индексы в суффиксном массиве, т.е. пусть <img class=tex src="../tex2png/cache/2b3831d7d2edca0658a067b684887d60.png" alt="k_1"> и <img class=tex src="../tex2png/cache/daa41655761beb69365ffeafd21fc329.png" alt="k_2"> &mdash; их позиции в массиве <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]"> (упорядочим их, т.е. пусть <img class=tex src="../tex2png/cache/8b594fffc98656c30b585412a614bd77.png" alt="k_1 < k_2">). Тогда ответом на данный запрос будет минимум в массиве <img class=tex src="../tex2png/cache/71fac3aeb9fa1e3e719cb67acd7c467c.png" alt="\rm lcp">, взятый на отрезке <img class=tex src="../tex2png/cache/53c0b0104384de40187b428af79df862.png" alt="[k_1; k_2-1]">. В самом деле, переход от суффикса <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> к суффиксу <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> можно заменить целой цепочкой переходов, начинающейся с суффикса <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и заканчивающейся в суффиксе <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">, но включающей в себя все промежуточные суффиксы, находящиеся в порядке сортировки между ними.<p>Таким образом, если мы имеем такой массив <img class=tex src="../tex2png/cache/71fac3aeb9fa1e3e719cb67acd7c467c.png" alt="\rm lcp">, то ответ на любой запрос наибольшего общего префикса сводится к запросу <b>минимума на отрезке</b> массива <img class=tex src="../tex2png/cache/71fac3aeb9fa1e3e719cb67acd7c467c.png" alt="\rm lcp">. Эта классическая задача минимума на отрезке (range minimum query, RMQ) имеет множество решений с различными асимптотиками, описанные <a href="rmq.html">здесь</a>.<p>Итак, основная наша задача &mdash; <b>построение</b> этого массива <img class=tex src="../tex2png/cache/71fac3aeb9fa1e3e719cb67acd7c467c.png" alt="\rm lcp">. Строить его мы будем по ходу алгоритма построения суффиксного массива: на каждой текущей итерации будем строить массив <img class=tex src="../tex2png/cache/71fac3aeb9fa1e3e719cb67acd7c467c.png" alt="\rm lcp"> для циклических подстрок текущей длины.<p>После нулевой итерации массив <img class=tex src="../tex2png/cache/71fac3aeb9fa1e3e719cb67acd7c467c.png" alt="\rm lcp">, очевидно, должен быть нулевым.<p>Пусть теперь мы выполнили <img class=tex src="../tex2png/cache/658627816b5be3d0859b8d0d52d03fd5.png" alt="k-1">-ю итерацию, получили от неё массив <img class=tex src="../tex2png/cache/8eb9e994d03b18f6e538689583b537dd.png" alt="\rm lcp^\prime">, и должны на текущей <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-й итерации пересчитать этот массив, получив новое его значение <img class=tex src="../tex2png/cache/71fac3aeb9fa1e3e719cb67acd7c467c.png" alt="\rm lcp">. Как мы помним, в алгоритме построения суффиксного массива циклические подстроки длины <img class=tex src="../tex2png/cache/a631b6ee74bdfc6711813da7ca95a648.png" alt="2^k"> разбивались пополам на две подстроки длины <img class=tex src="../tex2png/cache/97c42e4ca4ce993e5a52c7ece2343aaa.png" alt="2^{k-1}">; воспользуемся этим же приёмом и для построения массива <img class=tex src="../tex2png/cache/71fac3aeb9fa1e3e719cb67acd7c467c.png" alt="\rm lcp">.<p>Итак, пусть на текущей итерации алгоритм вычисления суффиксного массива выполнил свою работу, нашёл новое значение перестановки <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]"> подстрок. Будем теперь идти по этому массиву и смотреть пары соседних подстрок: <img class=tex src="../tex2png/cache/6fa33a48f7fff7f52d08a07ab012145a.png" alt="p[i]"> и <img class=tex src="../tex2png/cache/d006fba63190eb9a53a092d42694a3da.png" alt="p[i+1]">, <img class=tex src="../tex2png/cache/92ddeeb4cc9748e71f271c03fd3c7986.png" alt="i=0 \ldots n-2">. Разбивая каждую подстроку пополам, мы получаем две различных ситуации: 1) первые половинки подстрок в позициях <img class=tex src="../tex2png/cache/6fa33a48f7fff7f52d08a07ab012145a.png" alt="p[i]"> и <img class=tex src="../tex2png/cache/d006fba63190eb9a53a092d42694a3da.png" alt="p[i+1]"> различаются, и 2) первые половинки совпадают (напомним, такое сравнение можно легко производить, просто сравнивая номера классов <img class=tex src="../tex2png/cache/d9e2aa831637d909843d3ec6bd160813.png" alt="c[]"> с предыдущей итерации). Рассмотрим каждый из этих случаев отдельно.<p>1) Первые половинки подстрок различались. Заметим, что тогда на предыдущем шаге эти первые половинки необходимо были соседними. В самом деле, классы эквивалентности не могли исчезать (а могут только появляться), поэтому все различные подстроки длины <img class=tex src="../tex2png/cache/97c42e4ca4ce993e5a52c7ece2343aaa.png" alt="2^{k-1}"> дадут (в качестве первых половинок) на текущей итерации различные подстроки длины <img class=tex src="../tex2png/cache/a631b6ee74bdfc6711813da7ca95a648.png" alt="2^k">, и в том же порядке. Таким образом, для определения <img class=tex src="../tex2png/cache/9ef59b64bf22fbd516bcf192980782d8.png" alt="{\rm lcp}[i]"> в этом случае надо просто взять соответствующее значение из массива <img class=tex src="../tex2png/cache/8eb9e994d03b18f6e538689583b537dd.png" alt="\rm lcp^\prime">.<p>2) Первые половинки совпадали. Тогда вторые половинки могли как совпадать, так и различаться; при этом, если они различаются, то они совсем не обязательно должны были быть соседними на предыдущей итерации. Поэтому в этом случае нет простого способа определить <img class=tex src="../tex2png/cache/9ef59b64bf22fbd516bcf192980782d8.png" alt="{\rm lcp}[i]">. Для его определения надо поступить так же, как мы и собираемся потом вычислять наибольший общий префикс для любых двух суффиксов: надо выполнить запрос минимума (RMQ) на соответствующем отрезке массива <img class=tex src="../tex2png/cache/8eb9e994d03b18f6e538689583b537dd.png" alt="\rm lcp^\prime">.<p>Оценим <b>асимптотику</b> такого алгоритма. Как мы видели при разборе этих двух случаев, только второй случай даёт увеличение числа классов эквивалентности. Иными словами, можно говорить о том, что каждый новый класс эквивалентности появляется вместе с одним запросом RMQ. Поскольку всего классов эквивалентности может быть до <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, то и искать минимум мы должны за асимптотику <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)">. А для этого надо использовать уже какую-то структуру данных для минимума на отрезке; эту структуру данных надо будет строить заново на каждой итерации (которых всего <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)">). Хорошим вариантом структуры данных будет <b><a href="segment_tree.html">Дерево отрезков</b></a>: его можно построить за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">, а потом выполнять запросы за <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)">, что как раз и даёт нам итоговую асимптотику <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">.<p><b>Реализация:</b><p><pre class="notranslate cpp"><span class="kw4">int</span> lcp<span class="br0">&#91;</span>maxlen<span class="br0">&#93;</span>, lcpn<span class="br0">&#91;</span>maxlen<span class="br0">&#93;</span>, lpos<span class="br0">&#91;</span>maxlen<span class="br0">&#93;</span>, rpos<span class="br0">&#91;</span>maxlen<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw3">memset</span> <span class="br0">&#40;</span>lcp, <span class="nu0">0</span>, <span class="kw3">sizeof</span> lcp<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> h<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>h<span class="br0">&#41;</span><span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>h<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		rpos<span class="br0">&#91;</span>c<span class="br0">&#91;</span>p<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>n<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&gt;=</span><span class="nu0">0</span><span class="sy4">;</span> <span class="sy2">--</span>i<span class="br0">&#41;</span>
		lpos<span class="br0">&#91;</span>c<span class="br0">&#91;</span>p<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
&nbsp;
	... все действия по построению суфф. массива, кроме последней строки <span class="br0">&#40;</span><span class="kw3">memcpy</span><span class="br0">&#41;</span> ...
&nbsp;
	<span class="me1">rmq_build</span> <span class="br0">&#40;</span>lcp, n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> a <span class="sy1">=</span> p<span class="br0">&#91;</span>i<span class="br0">&#93;</span>,  b <span class="sy1">=</span> p<span class="br0">&#91;</span>i<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>c<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> c<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="br0">&#41;</span>
			lcpn<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> lcp<span class="br0">&#91;</span>rpos<span class="br0">&#91;</span>c<span class="br0">&#91;</span>a<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">else</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> aa <span class="sy1">=</span> <span class="br0">&#40;</span>a <span class="sy2">+</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>h<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy2">%</span> n,  bb <span class="sy1">=</span> <span class="br0">&#40;</span>b <span class="sy2">+</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>h<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy2">%</span> n<span class="sy4">;</span>
			lcpn<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>h<span class="br0">&#41;</span> <span class="sy2">+</span> rmq <span class="br0">&#40;</span>lpos<span class="br0">&#91;</span>c<span class="br0">&#91;</span>aa<span class="br0">&#93;</span><span class="br0">&#93;</span>, rpos<span class="br0">&#91;</span>c<span class="br0">&#91;</span>bb<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
			lcpn<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> min <span class="br0">&#40;</span>n, lcpn<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw3">memcpy</span> <span class="br0">&#40;</span>lcp, lcpn, <span class="br0">&#40;</span>n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy2">*</span> <span class="kw3">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw3">memcpy</span> <span class="br0">&#40;</span>c, cn, n <span class="sy2">*</span> <span class="kw3">sizeof</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Здесь помимо массива <img class=tex src="../tex2png/cache/a5d07488021f4ad569b61e022ef927ad.png" alt="\rm lcp[]"> вводится временный массив <img class=tex src="../tex2png/cache/ec5026a642d21abf60f08f9b8abad120.png" alt="\rm lcpn[]"> с его новым значением. Также поддерживается массив <img class=tex src="../tex2png/cache/86dc3261b0399ac6cb9fa5bb406dd403.png" alt="\rm pos[]">, который для каждой подстроки хранит её позицию в перестановке <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]">. Функция <img class=tex src="../tex2png/cache/30ff26ea64f95e372d4d87ec34e65890.png" alt="\rm rmq\_build"> &mdash; некоторая функция, строящая структуру данных для минимума по массиву-первому аргументу, размер его передаётся вторым аргументом. Функция <img class=tex src="../tex2png/cache/046080712eb75512a4889163574172bb.png" alt="\rm rmq"> возвращает минимум на отрезке: с первого аргумента по второй включительно.<p>Из самого алгоритма построения суффиксного массива пришлось только вынести копирование массива <img class=tex src="../tex2png/cache/d9e2aa831637d909843d3ec6bd160813.png" alt="c[]">, поскольку во время вычисления <img class=tex src="../tex2png/cache/71fac3aeb9fa1e3e719cb67acd7c467c.png" alt="\rm lcp"> нам понадобятся старые значения этого массива.<p>Стоит отметить, что наша реализация находит длину общего префикса для <b>циклических подстрок</b>, в то время как на практике чаще бывает нужной длина общего префикса для суффиксов в их обычном понимании. В этом случае надо просто ограничить значения <img class=tex src="../tex2png/cache/71fac3aeb9fa1e3e719cb67acd7c467c.png" alt="\rm lcp"> по окончании работы алгоритма:<p><pre class="notranslate cpp"><span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	lcp<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> min <span class="br0">&#40;</span>lcp<span class="br0">&#91;</span>i<span class="br0">&#93;</span>, min <span class="br0">&#40;</span>n<span class="sy2">-</span>p<span class="br0">&#91;</span>i<span class="br0">&#93;</span>, n<span class="sy2">-</span>p<span class="br0">&#91;</span>i<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p>Для <b>любых</b> двух суффиксов длину их наибольшего общего префикса теперь можно найти как минимум на соответствующем отрезке массива <img class=tex src="../tex2png/cache/71fac3aeb9fa1e3e719cb67acd7c467c.png" alt="\rm lcp">:<p><pre class="notranslate cpp"><span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	pos<span class="br0">&#91;</span>p<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
rmq_build <span class="br0">&#40;</span>lcp, n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
... поступил запрос <span class="br0">&#40;</span>i,j<span class="br0">&#41;</span> на нахождение LCP ...
<span class="kw4">int</span> result <span class="sy1">=</span> rmq <span class="br0">&#40;</span>min<span class="br0">&#40;</span>i,j<span class="br0">&#41;</span>, max<span class="br0">&#40;</span>i,j<span class="br0">&#41;</span><span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p><p><h3 style="padding-top:15px;"> Количество различных подстрок </h3><p>Выполним <b>препроцессинг</b>, описанный в предыдущем разделе: за <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)"> времени и <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> памяти мы для каждой пары соседних в порядке сортировки суффиксов найдём длину их наибольшего общего префикса. Найдём теперь по этой информации количество различных подстрок в строке.<p>Для этого будем рассматривать, какие новые подстроки начинаются в позиции <img class=tex src="../tex2png/cache/13298d26b66ed695fab4fc3fc1f1dbd0.png" alt="p[0]">, затем в позиции <img class=tex src="../tex2png/cache/973461b3241ee0607c4ce84e4169e8a6.png" alt="p[1]">, и т.д. Фактически, мы берём очередной в порядке сортировки суффикс и смотрим, какие его префиксы дают новые подстроки. Тем самым мы, очевидно, не упустим из виду никакие из подстрок.<p>Пользуясь тем, что суффиксы у нас уже отсортированы, нетрудно понять, что текущий суффикс <img class=tex src="../tex2png/cache/6fa33a48f7fff7f52d08a07ab012145a.png" alt="p[i]"> даст в качестве новых подстрок все свои префиксы, кроме совпадающих с префиксами суффикса <img class=tex src="../tex2png/cache/e9d4e351799f1afc17a73678f1e782c3.png" alt="p[i-1]">. Т.е. все его префиксы, кроме <img class=tex src="../tex2png/cache/b9b25cbc6351d371a02a6b28ecaa8ca2.png" alt="{\rm lcp}[i-1]"> первых, дадут новые подстроки. Поскольку длина текущего суффикса равна <img class=tex src="../tex2png/cache/233424f2a1d720f3b1c1e4f3009281f3.png" alt="n-p[i]">, то окончательно получаем, что текущий суффикс <img class=tex src="../tex2png/cache/6fa33a48f7fff7f52d08a07ab012145a.png" alt="p[i]"> даёт <img class=tex src="../tex2png/cache/1bd3f25b5a810eb12eea587e0bf48ef1.png" alt="n-p[i]-{\rm lcp}[i-1]"> новых подстрок. Суммируя это по всем суффиксам (для самого первого, <img class=tex src="../tex2png/cache/13298d26b66ed695fab4fc3fc1f1dbd0.png" alt="p[0]">, отнимать нечего &mdash; прибавится просто <img class=tex src="../tex2png/cache/85fb853fc040180ff638a42820bc838a.png" alt="n-p[0]">), получаем <b>ответ</b> на задачу:<p><p class=formula><img class=tex src="../tex2png/cache/97acc8c31d5aa1d426f281e3d94ffddb.png" alt=" \sum_{i=0}^n (n - p[i]) - \sum_{i=0}^{n-1} {\rm l[...]"><p><p></p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Задачи, которые можно решить, используя суффиксный массив:<p><ul><p><li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1620">UVA #10679 <b>"I Love Strings!!!"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>