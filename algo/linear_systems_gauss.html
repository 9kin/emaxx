<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Метод Гаусса решения системы линейных уравнений</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 11 Jun 2008 11:11<br>редактировано: 2 May 2012 0:40</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="linear_systems_gauss.html#" id="contents-hide">[скрыть]</a><a href="linear_systems_gauss.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Метод Гаусса решения системы линейных уравнений </h1><p><p>Дана система <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> линейных алгебраических уравнений (СЛАУ) с <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> неизвестными. Требуется решить эту систему: определить, сколько решений она имеет (ни одного, одно или бесконечно много), а если она имеет хотя бы одно решение, то найти любое из них.<p><b>Формально</b> задача ставится следующим образом: решить систему:<p><p class=formula><img class=tex src="../tex2png/cache/164afa61bb105a63db1e680926b81837.png" alt=" \cases{
a_{11} x_1 + a_{12} x_2 + \ldots + a_{1m[...]"></p><p>где коэффициенты <img class=tex src="../tex2png/cache/56eda49e993f2d35c7fe39a74adc1ae4.png" alt="a_{ij} (i=1 \ldots n, j=1 \ldots m)"> и <img class=tex src="../tex2png/cache/c7a426ab4685bcce1be5181c8e2e2780.png" alt="b_i (i = 1 \ldots n)"> известны, а переменные <img class=tex src="../tex2png/cache/8623f5a22b7d65d7b12c2b05efe58192.png" alt="x_i (i=1 \ldots m)"> &mdash; искомые неизвестные.<p>Удобно матричное представление этой задачи:<p><p class=formula><img class=tex src="../tex2png/cache/5f796309bcc982cae81dbf32c7f549f0.png" alt=" A x = b, "></p><p>где <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> &mdash; матрица <img class=tex src="../tex2png/cache/ed0e13f7024ff254a4fccd689fe21ad3.png" alt="n \times m">, составленная из коэффициентов <img class=tex src="../tex2png/cache/6279eacd73327c201d0787014ac5405f.png" alt="a_{ij}">, <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> &mdash; векторы-столбцы высоты <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m">.<p>Стоит отметить, что СЛАУ может быть не над полем действительных чисел, а над полем <b>по модулю</b> какого-либо числа <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">, т.е.:<p><p class=formula><img class=tex src="../tex2png/cache/6beda4b356b07f561b6a085986eaf105.png" alt=" \cases{
a_{11} x_1 + a_{12} x_2 + \ldots + a_{1m[...]"></p><p>&mdash; алгоритм Гаусса работает и для таких систем тоже (но этот случай будет рассмотрен ниже в отдельном разделе).<p><p><p><h2 style="padding-top:40px;"> Алгоритм Гаусса </h2><p>Строго говоря, описываемый ниже метод правильно называть методом "Гаусса-Жордана" (Gauss-Jordan elimination), поскольку он является вариацией метода Гаусса, описанной геодезистом Вильгельмом Жорданом в 1887 г. (стоит отметить, что Вильгельм Жордан не является автором ни теоремы Жордана о кривых, ни жордановой алгебры &mdash; всё это три разных учёных-однофамильца; кроме того, по всей видимости, более правильной является транскрипция "Йордан", но написание "Жордан" уже закрепилось в русской литературе). Также интересно заметить, что одновременно с Жорданом (а по некоторым данным даже раньше него) этот алгоритм придумал Класен (B.-I. Clasen).<p><p><h3 style="padding-top:15px;"> Базовая схема </h3><p>Кратко говоря, алгоритм заключается в <b>последовательном исключении</b> переменных из каждого уравнения до тех пор, пока в каждом уравнении не останется только по одной переменной. Если <img class=tex src="../tex2png/cache/140a931edd6d974ebc01777873a0f457.png" alt="n=m">, то можно говорить, что алгоритм Гаусса-Жордана стремится привести матрицу <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> системы к единичной матрице &mdash; ведь после того как матрица стала единичной, решение системы очевидно &mdash; решение единственно и задаётся получившимися коэффициентами <img class=tex src="../tex2png/cache/0993821d823b5b792321f13c90efa683.png" alt="b_i">.<p>При этом алгоритм основывается на двух простых эквивалентных преобразованиях системы: во-первых, можно обменивать два уравнения, а во-вторых, любое уравнение можно заменить линейной комбинацией этой строки (с ненулевым коэффициентом) и других строк (с произвольными коэффициентами).<p><b>На первом шаге</b> алгоритм Гаусса-Жордана делит первую строку на коэффициент <img class=tex src="../tex2png/cache/387397898ca7548e3e7b7f5664db00f2.png" alt="a_{11}">. Затем алгоритм прибавляет первую строку к остальным строкам с такими коэффициентами, чтобы их коэффициенты в первом столбце обращались в нули &mdash; для этого, очевидно, при прибавлении первой строки к <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой надо домножать её на <img class=tex src="../tex2png/cache/0a8f40df01a575706b0a9da9d217b1ca.png" alt="-a_{i1}">. При каждой операции с матрицей <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> (деление на число, прибавление к одной строке другой) соответствующие операции производятся и с вектором <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">; в некотором смысле, он ведёт себя, как если бы он был <img class=tex src="../tex2png/cache/b5bf48f7ed9b1d38b27bbe1d90506368.png" alt="m+1">-ым столбцом матрицы <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A">.<p>В итоге, по окончании первого шага первый столбец матрицы <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> станет единичным (т.е. будет содержать единицу в первой строке и нули в остальных).<p>Аналогично производится второй шаг алгоритма, только теперь рассматривается второй столбец и вторая строка: сначала вторая строка делится на <img class=tex src="../tex2png/cache/aecbee882471e82d3b96ddaa16d23614.png" alt="a_{22}">, а затем отнимается от всех остальных строк с такими коэффициентами, чтобы обнулять второй столбец матрицы <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A">.<p>И так далее, пока мы не обработаем все строки или все столбцы матрицы <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A">. Если <img class=tex src="../tex2png/cache/140a931edd6d974ebc01777873a0f457.png" alt="n=m">, то по построению алгоритма очевидно, что матрица <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> получится единичной, что нам и требовалось.<p><p><h3 style="padding-top:15px;"> Поиск опорного элемента (pivoting) </h3><p>Разумеется, описанная выше схема неполна. Она работает только в том случае, если на каждом <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ом шаге элемент <img class=tex src="../tex2png/cache/6039987bfb0eb0480e7c6d34b515728a.png" alt="a_{ii}"> отличен от нуля &mdash; иначе мы просто не сможем добиться обнуления остальных коэффициентов в текущем столбце путём прибавления к ним <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой строки.<p>Чтобы сделать алгоритм работающим в таких случаях, как раз и существует процесс <b>выбора опорного элемента</b> (на английском языке это называется одним словом "pivoting"). Он заключается в том, что производится перестановка строк и/или столбцов матрицы, чтобы в нужном элементе <img class=tex src="../tex2png/cache/6039987bfb0eb0480e7c6d34b515728a.png" alt="a_{ii}"> оказалось ненулевое число.<p>Заметим, что перестановка строк значительно проще реализуется на компьютере, чем перестановка столбцов: ведь при обмене местами двух каких-то столбцов надо запомнить, что эти две переменных обменялись местами, чтобы затем, при восстановлении ответа, правильно восстановить, какой ответ к какой переменной относится. При перестановке строк никаких таких дополнительных действий производить не надо.<p>К счастью, для корректности метода достаточно одних только обменов строк (т.н. "partial pivoting", в отличие от "full pivoting", когда обмениваются и строки, и столбцы). Но какую же именно строку следует выбирать для обмена? И правда ли, что поиск опорного элемента надо делать только тогда, когда текущий элемент <img class=tex src="../tex2png/cache/6039987bfb0eb0480e7c6d34b515728a.png" alt="a_{ii}"> нулевой?<p>Общего ответа на этот вопрос не существует. Есть разнообразные эвристики, однако самой эффективной из них (по соотношению простоты и отдачи) является такая <b>эвристика</b>: в качестве опорного элемента следует брать наибольший по модулю элемент, причём производить поиск опорного элемента и обмен с ним надо <b>всегда</b>, а не только когда это необходимо (т.е. не только тогда, когда <img class=tex src="../tex2png/cache/e3e17b3289bba8fdad1d5fdfaecd9f06.png" alt="a_{ii}=0">).<p>Иными словами, перед выполнением <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой фазы алгоритма Гаусса-Жордана с эвристикой partial pivoting необходимо найти в <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ом столбце среди элементов с индексами от <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> до <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> максимальный по модулю, и обменять строку с этим элементом с <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой строкой.<p>Во-первых, эта эвристика позволит решить СЛАУ, даже если по ходу решения будет случаться так, что элемент <img class=tex src="../tex2png/cache/e3e17b3289bba8fdad1d5fdfaecd9f06.png" alt="a_{ii}=0">. Во-вторых, что весьма немаловажно, эта эвристика улучшает <b>численную устойчивость</b> алгоритма Гаусса-Жордана.<p>Без этой эвристики, даже если система такова, что на каждой <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой фазе <img class=tex src="../tex2png/cache/62722e19f8fe74e8d4d2705c4cd973b0.png" alt="a_{ii} \ne 0"> &mdash; алгоритм Гаусса-Жордана отработает, но в итоге накапливающаяся погрешность может оказаться настолько огромной, что даже для матриц размера около <img class=tex src="../tex2png/cache/5e7759304ea771e5b17cc15648bdae1f.png" alt="20"> погрешность будет превосходить сам ответ.<p><p><h3 style="padding-top:15px;"> Вырожденные случаи </h3><p>Итак, если останавливаться на алгоритме Гаусса-Жордана с partial pivoting, то, утверждается, если <img class=tex src="../tex2png/cache/4e7cc5369f8c1cacf48d2f7fc0504e8b.png" alt="m=n"> и система невырождена (т.е. имеет ненулевой определитель, что означает, что она имеет единственное решение), то описанный выше алгоритм полностью отработает и придёт к единичной матрице <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> (доказательство этого, т.е. того, что ненулевой опорный элемент всегда будет находиться, здесь не приводится).<p>Рассмотрим теперь <b>общий случай</b> &mdash; когда <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> и <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> не обязательно равны. Предположим, что опорный элемент на <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ом шаге не нашёлся. Это означает, что в <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ом столбце все строки, начиная с текущей, содержат нули. Утверждается, что в этом случае эта <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ая переменная не может быть определена, и является <b>независимой переменной</b> (может принимать произвольное значение). Чтобы алгоритм Гаусса-Жордана продолжил свою работу для всех последующих переменных, в такой ситуации надо просто пропустить текущий <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ый столбец, не увеличивая при этом номер текущей строки (можно сказать, что мы виртуально удаляем <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ый столбец матрицы).<p>Итак, некоторые переменные в процессе работы алгоритма могут оказываться независимыми. Понятно, что когда количество <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> переменных больше количества <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> уравнений, то как минимум <img class=tex src="../tex2png/cache/373ce0e39558e9857b1a74841f62b5be.png" alt="m-n"> переменных обнаружатся независимыми.<p>В целом, если обнаружилась хотя бы одна независимая переменная, то она может принимать произвольное значение, в то время как остальные (зависимые) переменные будут выражаться через неё. Это означает, что, когда мы работаем в поле действительных чисел, система потенциально имеет <b>бесконечно много решений</b> (если мы рассматриваем СЛАУ по модулю, то число решений будет равно этому модулю в степени количества независимых переменных). Впрочем, следует быть аккуратным: надо помнить о том, что даже если были обнаружены независимые переменные, тем не менее СЛАУ <b>может не иметь решений вовсе</b>. Это происходит, когда в оставшихся необработанными уравнениях (тех, до которых алгоритм Гаусса-Жордана не дошёл, т.е. это уравнения, в которых остались только независимые переменные) есть хотя бы один ненулевой свободный член.<p>Впрочем, проще это проверить явной подстановкой найденного решения: всем независимыми переменным присвоить нулевые значения, зависимым переменным присвоить найденные значения, и подставить это решение в текущую СЛАУ.<p><p><p><h2 style="padding-top:40px;"> Реализация </h2><p>Приведём здесь реализацию алгоритма Гаусса-Жордана с эвристикой partial pivoting (выбором опорного элемента как максимума по столбцу).<p>На вход функции <img class=tex src="../tex2png/cache/6ab4e4365b862d7eeda8415eeba6f0f6.png" alt="\rm gauss()"> передаётся сама матрица системы <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">. Последний столбец матрицы <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> &mdash; это в наших старых обозначениях столбец <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> свободных коэффициентов (так сделано для удобства программирования &mdash; т.к. в самом алгоритме все операции со свободными коэффициентами <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> повторяют операции с матрицей <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A">).<p>Функция возвращает число решений системы (<img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0">, <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"> или <img class=tex src="../tex2png/cache/3d40198f44abce2dbb7a7eb7fba559c9.png" alt="\infty">) (бесконечность обозначена в коде специальной константой <img class=tex src="../tex2png/cache/a7edbf6ce4bf393cf5db4311b9f2d11c.png" alt="\rm INF">, которой можно задать любое большое значение). Если хотя бы одно решение существует, то оно возвращается в векторе <img class=tex src="../tex2png/cache/607d24373b46b951fe9353e68153b1f4.png" alt="\rm ans">.<p><pre class="notranslate cpp"><span class="kw4">int</span> gauss <span class="br0">&#40;</span>vector <span class="sy1">&lt;</span> vector<span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> a, vector<span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> ans<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw4">int</span> m <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> a<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy2">-</span> <span class="nu0">1</span><span class="sy4">;</span>
&nbsp;
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> where <span class="br0">&#40;</span>m, <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> col<span class="sy1">=</span><span class="nu0">0</span>, row<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> col<span class="sy1">&lt;</span>m <span class="sy3">&amp;&amp;</span> row<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>col<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> sel <span class="sy1">=</span> row<span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>row<span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw3">abs</span> <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>col<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="sy1">&gt;</span> <span class="kw3">abs</span> <span class="br0">&#40;</span>a<span class="br0">&#91;</span>sel<span class="br0">&#93;</span><span class="br0">&#91;</span>col<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
				sel <span class="sy1">=</span> i<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw3">abs</span> <span class="br0">&#40;</span>a<span class="br0">&#91;</span>sel<span class="br0">&#93;</span><span class="br0">&#91;</span>col<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="sy1">&lt;</span> EPS<span class="br0">&#41;</span>
			<span class="kw1">continue</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>col<span class="sy4">;</span> i<span class="sy1">&lt;=</span>m<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			swap <span class="br0">&#40;</span>a<span class="br0">&#91;</span>sel<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span>, a<span class="br0">&#91;</span>row<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		where<span class="br0">&#91;</span>col<span class="br0">&#93;</span> <span class="sy1">=</span> row<span class="sy4">;</span>
&nbsp;
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy3">!</span><span class="sy1">=</span> row<span class="br0">&#41;</span> <span class="br0">&#123;</span>
				<span class="kw4">double</span> c <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>col<span class="br0">&#93;</span> <span class="sy2">/</span> a<span class="br0">&#91;</span>row<span class="br0">&#93;</span><span class="br0">&#91;</span>col<span class="br0">&#93;</span><span class="sy4">;</span>
				<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span>col<span class="sy4">;</span> j<span class="sy1">&lt;=</span>m<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
					a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy2">-</span><span class="sy1">=</span> a<span class="br0">&#91;</span>row<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy2">*</span> c<span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="sy2">++</span>row<span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	ans.<span class="me1">assign</span> <span class="br0">&#40;</span>m, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>m<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>where<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
			ans<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="br0">&#91;</span>where<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#91;</span>m<span class="br0">&#93;</span> <span class="sy2">/</span> a<span class="br0">&#91;</span>where<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">double</span> sum <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>m<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			sum <span class="sy2">+</span><span class="sy1">=</span> ans<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy2">*</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw3">abs</span> <span class="br0">&#40;</span>sum <span class="sy2">-</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>m<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="sy1">&gt;</span> EPS<span class="br0">&#41;</span>
			<span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>m<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>where<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
			<span class="kw1">return</span> INF<span class="sy4">;</span>
	<span class="kw1">return</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>В функции поддерживаются два указателя &mdash; на текущий столбец <img class=tex src="../tex2png/cache/c7bd6e64fc7d7dadacd5636829b54b1f.png" alt="\rm col"> и текущую строку <img class=tex src="../tex2png/cache/615013ec9746fe3fe954e9772bc80048.png" alt="\rm row">.<p>Также заводится вектор <img class=tex src="../tex2png/cache/7a7fe4140366f542b1556206c0d83909.png" alt="\rm where">, в котором для каждой переменной записано, в какой строке должна она получиться (иными словами, для каждого столбца записан номер строки, в которой этот столбец отличен от нуля). Этот вектор нужен, поскольку некоторые переменные могли не "определиться" в ходе решения (т.е. это независимые переменные, которым можно присвоить произвольное значение &mdash; например, в приведённой реализации это нули).<p>Реализация использует технику partial pivoting, производя поиск строки с максимальным по модулю элементом, и переставляя затем эту строку в позицию <img class=tex src="../tex2png/cache/615013ec9746fe3fe954e9772bc80048.png" alt="\rm row"> (хотя явную перестановку строк можно заменить обменом двух индексов в некотором массиве, на практике это не даст реального выигрыша, т.к. на обмены тратится <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)"> операций).<p>В реализации в целях простоты текущая строка не делится на опорный элемент &mdash; так что в итоге по окончании работы алгоритма матрица становится не единичной, а диагональной (впрочем, по-видимому, деление строки на ведущий элемент позволяет несколько уменьшить возникающие погрешности).<p>После нахождения решения оно подставляется обратно в матрицу &mdash; чтобы проверить, имеет ли система хотя бы одно решение или нет. Если проверка найденного решения прошла успешно, то функция возвращает <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"> или <img class=tex src="../tex2png/cache/3d40198f44abce2dbb7a7eb7fba559c9.png" alt="\infty"> &mdash; в зависимости от того, есть ли хотя бы одна независимая переменная или нет.<p><p><p><h2 style="padding-top:40px;"> Асимптотика </h2><p>Оценим асимптотику полученного алгоритма. Алгоритм состоит из <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> фаз, на каждой из которых происходит:<p><ul><li>поиск и перестановка опорного элемента &mdash; за время <img class=tex src="../tex2png/cache/d20d4ea468976eeb83adea753c1fd674.png" alt="O(n+m)"> при использовании эвристики "partial pivoting" (поиск максимума в столбце)<li>если опорный элемент в текущем столбце был найден &mdash; то прибавление текущего уравнения ко всем остальным уравнениям &mdash; за время <img class=tex src="../tex2png/cache/c4fa4086adf46462d07aa16071f709ef.png" alt="O(nm)"></ul><p>Очевидно, первый пункт имеет меньшую асимптотику, чем второй. Заметим также, что второй пункт выполняется не более <img class=tex src="../tex2png/cache/d3dbdb62453aa770c0d223a23edfd07e.png" alt="\min(n,m)"> раз &mdash; столько, сколько может быть зависимых переменных в СЛАУ.<p>Таким образом, <b>итоговая асимптотика</b> алгоритма принимает вид <img class=tex src="../tex2png/cache/bfdbb053042b6d041b835d7ffee45e71.png" alt="O (\min(n,m) \cdot n m)">.<p>При <img class=tex src="../tex2png/cache/1f2b0897a79cf035eca3154f683f4805.png" alt="n = m"> эта оценка превращается в <img class=tex src="../tex2png/cache/5333bf52919bd2805f33a181851ebbf4.png" alt="O(n^3)">.<p>Заметим, что когда СЛАУ рассматривается не в поле действительных чисел, а в поле по модулю два, то систему можно решать гораздо быстрее &mdash; об этом см. ниже в разделе "Решение СЛАУ по модулю".<p><h3 style="padding-top:15px;">Более точная оценка числа действий</h3><p>Для простоты выкладок будем считать, что <img class=tex src="../tex2png/cache/1f2b0897a79cf035eca3154f683f4805.png" alt="n = m">.<p>Как мы уже знаем, время работы всего алгоритма фактически определяется временем, затрачиваемым на исключение текущего уравнения из остальных.<p>Это может происходить на каждом из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> шагов, при этом текущее уравнение прибавляется ко всем <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> остальным. При прибавлении работа идёт только со столбцами, начиная с текущего. Таким образом, в сумме получается <img class=tex src="../tex2png/cache/87924c7fca9ad26e14f1780d41a6b514.png" alt="n^3 / 2"> операций.<p><p><p><p><h2 style="padding-top:40px;"> Дополнения </h2><p><p><h3 style="padding-top:15px;"> Ускорение алгоритма: разделение его на прямой и обратный ход </h3><p>Добиться двукратного ускорения алгоритма можно, рассмотрев другую его версию, более классическую, когда алгоритм разбивается на фазы прямого и обратного хода.<p>В целом, в отличие от описанного выше алгоритма, можно приводить матрицу не к диагональному виду, а к <b>треугольному виду</b> &mdash; когда все элементы строго ниже главной диагонали равны нулю.<p>Система с треугольной матрицей решается тривиально &mdash; сначала из последнего уравнения сразу находится значение последней переменной, затем найденное значение подставляется в предпоследнее уравнение и находится значение предпоследней переменной, и так далее. Этот процесс и называется <b>обратным ходом</b> алгоритма Гаусса.<p><b>Прямой ход</b> алгоритма Гаусса &mdash; это алгоритм, аналогичный описанному выше алгоритму Гаусса-Жордана, за одним исключением: текущая переменная исключается не из всех уравнений, а только из уравнений после текущего. В результате этого действительно получается не диагональная, а треугольная матрица.<p>Разница в том, что прямой ход работает <b>быстрее</b> алгоритма Гаусса-Жордана &mdash; поскольку в среднем он делает в два раза меньше прибавлений одного уравнения к другому. Обратный ход работает за <img class=tex src="../tex2png/cache/c4fa4086adf46462d07aa16071f709ef.png" alt="O(nm)">, что в любом случае асимптотически быстрее прямого хода.<p>Таким образом, если <img class=tex src="../tex2png/cache/140a931edd6d974ebc01777873a0f457.png" alt="n=m">, то данный алгоритм будет делать уже <img class=tex src="../tex2png/cache/8f1d7347e119d76f6a8cdf74191c5072.png" alt="n^3/4"> операций &mdash; что в два раза меньше алгоритма Гаусса-Жордана.<p><p><h3 style="padding-top:15px;"> Решение СЛАУ по модулю </h3><p>Для решения СЛАУ по модулю можно применять описанный выше алгоритм, он сохраняет свою корректность.<p>Разумеется, теперь становится ненужным использовать какие-то хитрые техники выбора опорного элемента &mdash; достаточно найти любой ненулевой элемент в текущем столбце.<p>Если модуль простой, то никаких сложностей вообще не возникает &mdash; происходящие по ходу работы алгоритма Гаусса деления не создают особых проблем.<p>Особенно замечателен <b>модуль, равный двум</b>: для него все операции с матрицей можно производить очень эффективно. Например, отнимание одной строки от другой по модулю два &mdash; это на самом деле их симметрическая разность ("xor"). Таким образом, весь алгоритм можно значительно ускорить, сжав всю матрицу в битовые маски и оперируя только ими. Приведём здесь новую реализацию основной части алгоритма Гаусса-Жордана, используя стандартный контейнер C++ "bitset":<p><pre class="notranslate cpp"><span class="kw4">int</span> gauss <span class="br0">&#40;</span>vector <span class="sy1">&lt;</span> bitset<span class="sy1">&lt;</span>N<span class="sy1">&gt;</span> <span class="sy1">&gt;</span> a, <span class="kw4">int</span> n, <span class="kw4">int</span> m, bitset<span class="sy1">&lt;</span>N<span class="sy1">&gt;</span> <span class="sy3">&amp;</span> ans<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> where <span class="br0">&#40;</span>m, <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> col<span class="sy1">=</span><span class="nu0">0</span>, row<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> col<span class="sy1">&lt;</span>m <span class="sy3">&amp;&amp;</span> row<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>col<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>row<span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>col<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				swap <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span>, a<span class="br0">&#91;</span>row<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
				<span class="kw1">break</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span> a<span class="br0">&#91;</span>row<span class="br0">&#93;</span><span class="br0">&#91;</span>col<span class="br0">&#93;</span><span class="br0">&#41;</span>
			<span class="kw1">continue</span><span class="sy4">;</span>
		where<span class="br0">&#91;</span>col<span class="br0">&#93;</span> <span class="sy1">=</span> row<span class="sy4">;</span>
&nbsp;
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy3">!</span><span class="sy1">=</span> row <span class="sy3">&amp;&amp;</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>col<span class="br0">&#93;</span><span class="br0">&#41;</span>
				a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy3">^</span><span class="sy1">=</span> a<span class="br0">&#91;</span>row<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="sy2">++</span>row<span class="sy4">;</span>
	<span class="br0">&#125;</span></pre><p>Как можно заметить, реализация стала даже немного короче, при том, что она значительно быстрее старой реализации &mdash; а именно, быстрее в <img class=tex src="../tex2png/cache/4479cf8459f4479cde703fcbe446c66b.png" alt="32"> раза за счёт битового сжатия. Также следует отметить, что решение систем по модулю два на практике работает очень быстро, поскольку случаи, когда от одной строки надо отнимать другую, происходят достаточно редко (на разреженных матрицах этот алгоритм может работать за время скорее порядка квадрата от размера, чем куба).<p>Если модуль <b>произвольный</b> (не обязательно простой), то всё становится несколько сложнее. Понятно, что пользуясь <a href="chinese_theorem.html">Китайской теоремой об остатках</a>, мы сводим задачу с произвольным модулем только к модулям вида "степень простого". [ дальнейший текст был скрыт, т.к. это непроверенная информация &mdash; возможно, неправильный способ решения ]<p>Наконец, рассмотрим вопрос <b>числа решений СЛАУ по модулю</b>. Ответ на него достаточно прост: число решений равно <img class=tex src="../tex2png/cache/c481da8ac40260376fd0f2170ff97def.png" alt="p^k">, где <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> &mdash; модуль, <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> &mdash; число независимых переменных.<p><p><h3 style="padding-top:15px;"> Немного о различных способах выбора опорного элемента </h3><p>Как уже говорилось выше, однозначного ответа на этот вопрос нет.<p>Эвристика "partial pivoting", которая заключалась в поиске максимального элемента в текущем столбце, работает на практике весьма неплохо. Также оказывается, что она даёт практически тот же результат, что и "full pivoting" &mdash; когда опорный элемент ищется среди элементов целой подматрицы &mdash; начиная с текущей строки и с текущего столбца.<p>Но интересно отметить, что обе эти эвристики с поиском максимального элемента, фактически, очень зависят от того, насколько были промасштабированы исходные уравнения. Например, если одно из уравнений системы умножить на миллион, то это уравнение почти наверняка будет выбрано в качестве ведущего на первом же шаге. Это кажется достаточно странным, поэтому логичен переход к немного более сложной эвристике &mdash; так называемому <b>"implicit pivoting"</b>.<p>Эвристика implicit pivoting заключается в том, что элементы различных строк сравниваются так, как если бы обе строки были пронормированы таким образом, что максимальный по модулю элемент в них был бы равен единице. Для реализации этой техники надо просто поддерживать текущий максимум в каждой строке (либо поддерживать каждую строку так, чтобы максимум в ней был равен единице по модулю, но это может привести к увеличению накапливаемой погрешности).<p><p><h3 style="padding-top:15px;"> Улучшение найденного ответа </h3><p>Поскольку, несмотря на различные эвристики, алгоритм Гаусса-Жордана всё равно может приводить к большим погрешностям на специальных матрицах даже размеров порядка <img class=tex src="../tex2png/cache/4ff9ae9fb5965767ea8214d9641879bb.png" alt="50"> - <img class=tex src="../tex2png/cache/42eebf03554591becb9bdde682ba1fbf.png" alt="100">.<p>В связи с этим, полученный алгоритмом Гаусса-Жордана ответ можно улучшить, применив к нему какой-либо простой численный метод &mdash; например, метод простой итерации.<p>Таким образом, решение превращается в двухшаговое: сначала выполняется алгоритм Гаусса-Жордана, затем &mdash; какой-либо численный метод, принимающий в качестве начальных данных решение, полученное на первом шаге.<p>Такой приём позволяет несколько расширить множество задач, решаемых алгоритмом Гаусса-Жордана с приемлемой погрешностью.<p><p><p><h2 style="padding-top:40px;"> Литература </h2><p><ul><li><a href="../bookz/files/numerical_recipes.pdf">William H. Press, Saul A. Teukolsky, William T. Vetterling, Brian P. Flannery. <b>Numerical Recipes: The Art of Scientific Computing</b> [2007]</a><li>Anthony Ralston, Philip Rabinowitz. <b>A first course in numerical analysis</b> [2001]</ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>