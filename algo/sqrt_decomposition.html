<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Sqrt-декомпозиция</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 11 Jun 2008 10:54<br>редактировано: 14 Jan 2013 17:58</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="sqrt_decomposition.html#" id="contents-hide">[скрыть]</a><a href="sqrt_decomposition.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Sqrt-декомпозиция</h1><p>Sqrt-декомпозиция &mdash; это метод, или структура данных, которая позволяет выполнять некоторые типичные операции (суммирование элементов подмассива, нахождение минимума/максимума и т.д.) за <img class=tex src="../tex2png/cache/e89d540813b771cb61aba6ca1d79b86e.png" alt="O(\sqrt{n})">, что значительно быстрее, чем <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> для тривиального алгоритма.<p>Сначала мы опишем структуру данных для одного из простейших применений этой идеи, затем покажем, как обобщать её для решения некоторых других задач, и, наконец, рассмотрим несколько иное применение этой идеи: разбиение входных запросов на sqrt-блоки.<p><p><h2 style="padding-top:40px;">Структура данных на основе sqrt-декомпозиции</h2><p><b>Поставим задачу</b>. Дан массив <img class=tex src="../tex2png/cache/2f7c3ec9c849a4dcbfc3195989056b93.png" alt="a[0 \ldots n-1]">. Требуется реализовать такую структуру данных, которая сможет находить сумму элементов <img class=tex src="../tex2png/cache/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a[l \ldots r]"> для произвольных <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> и <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> за <img class=tex src="../tex2png/cache/e89d540813b771cb61aba6ca1d79b86e.png" alt="O(\sqrt{n})"> операций.<p><p><h3 style="padding-top:15px;">Описание</h3><p>Основная идея sqrt-декомпозиции заключается в том, что сделаем следующий <b>предпосчёт</b>: разделим массив <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> на блоки длины примерно <img class=tex src="../tex2png/cache/59924d89d7dd54098a99b85b4e3cda4b.png" alt="\sqrt{n}">, и в каждом блоке <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> заранее предпосчитаем сумму <img class=tex src="../tex2png/cache/e875235207203e3980be2bd509460e7a.png" alt="b[i]"> элементов в нём.<p>Можно считать, что длина одного блока и количество блоков равны одному и тому же числу &mdash; корню из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, округлённому вверх:<p><p class=formula><img class=tex src="../tex2png/cache/06fb2a0945b9381db95093cf8fe65c1b.png" alt=" s = \left\lceil \sqrt{n} \right\rceil, "></p><p>тогда массив <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]"> разбивается на блоки примерно таким образом:<p><p class=formula><img class=tex src="../tex2png/cache/662da4cbdb10ce5be7fc046667cde348.png" alt=" \underbrace{ a[0] ~ a[1] ~ \ldots ~ a[s-1] }_{b[0[...]"></p><p>Хотя последний блок может содержать меньше, чем <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, элементов (если <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> не делится на <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">), &mdash; это не принципиально.<p>Таким образом, для каждого блока <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> мы знаем сумму на нём <img class=tex src="../tex2png/cache/e41b82131f67211d919da00859e908b9.png" alt="b[k]">:<p><p class=formula><img class=tex src="../tex2png/cache/f2fe22971a0f5830959a5164f611dbd9.png" alt=" b[k] = \sum_{i=k \cdot s}^{\min (n-1, (k+1) \cdot[...]"></p><p>Итак, пусть эти значения <img class=tex src="../tex2png/cache/dc588a78c0b54005094f2e9632ac3a38.png" alt="b_k"> предварительно подсчитаны (для этого надо, очевидно, <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> операций). Что они могут дать при вычислении ответа на очередной запрос <img class=tex src="../tex2png/cache/5da5090de09ee020bba6974c7d377e42.png" alt="(l,r)">? Заметим, что если отрезок <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> длинный, то в нём будут содержаться несколько блоков целиком, и на такие блоки мы можем узнать сумму на них за одну операцию. В итоге от всего отрезка <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> останется лишь два блока, попадающие в него лишь частично, и на этих кусках нам придётся произвести суммирование тривиальным алгоритмом.<p>Иллюстрация (здесь через <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> обозначен номер блока, в котором лежит <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l">, а через <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> &mdash; номер блока, в котором лежит <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">):<p><p class=formula><img class=tex src="../tex2png/cache/591460c780d6658d53231703eb0ed3ba.png" alt=" \ldots ~ \overbrace{ a[l] ~ \ldots ~ a[(k+1) \cdo[...]"></p><p>На этом рисунке видно, что для того чтобы посчитать сумму в отрезке <img class=tex src="../tex2png/cache/653023af1da32cf3f51fe321fa0778da.png" alt="[l \ldots r]">, надо просуммировать элементы только в двух "хвостах": <img class=tex src="../tex2png/cache/31a3de8a513ac2a8ce7cd9e031bc17c1.png" alt="[l \ldots (k+1) \cdot s-1]"> и <img class=tex src="../tex2png/cache/c9aef1a7216556e01c0d969353aad25e.png" alt="[p \cdot s \ldots r]">, и просуммировать значения <img class=tex src="../tex2png/cache/e875235207203e3980be2bd509460e7a.png" alt="b[i]"> во всех блоках, начиная с <img class=tex src="../tex2png/cache/b7e1992873e6c485f926be57173a6d22.png" alt="k+1"> и заканчивая <img class=tex src="../tex2png/cache/433653455abe8dc3c97e9d8461e2adbe.png" alt="p-1">:<p><p class=formula><img class=tex src="../tex2png/cache/cdba4a8584445ee8e23b643b55564844.png" alt=" \sum_{i=l}^{r} a[i] = \sum_{i=l}^{(k+1) \cdot s-1[...]"></p><p>(примечание: эта формула неверна, когда <img class=tex src="../tex2png/cache/e7743925fad88ae6806d9b6e2c011419.png" alt="k=p">: в таком случае некоторые элементы будут просуммированы дважды; в этом случае надо просто просуммировать элементы с <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> по <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">)<p>Тем самым мы экононим значительное количество операций. Действительно, размер каждого из "хвостов", очевидно, не превосходит длины блока <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, и количество блоков также не превосходит <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">. Поскольку <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> мы выбирали <img class=tex src="../tex2png/cache/ba7bffff79bb59296cda7a38ccd8617f.png" alt="\approx \sqrt{n}">, то всего для вычисления суммы на отрезке <img class=tex src="../tex2png/cache/653023af1da32cf3f51fe321fa0778da.png" alt="[l \ldots r]"> нам понадобится лишь <img class=tex src="../tex2png/cache/e89d540813b771cb61aba6ca1d79b86e.png" alt="O(\sqrt{n})"> операций.<p><p><h3 style="padding-top:15px;">Реализация</h3><p>Приведём сначала простейшую реализацию:<p><pre class="notranslate cpp"><span class="co1">// входные данные</span>
<span class="kw4">int</span> n<span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> a <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// предпосчёт</span>
<span class="kw4">int</span> len <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> <span class="kw3">sqrt</span> <span class="br0">&#40;</span>n <span class="sy2">+</span> <span class="nu18">.0</span><span class="br0">&#41;</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span> <span class="co1">// и размер блока, и количество блоков</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> b <span class="br0">&#40;</span>len<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	b<span class="br0">&#91;</span>i <span class="sy2">/</span> len<span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// ответ на запросы</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> l, r<span class="sy4">;</span> <span class="co1">// считываем входные данные - очередной запрос</span>
	<span class="kw4">int</span> sum <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>l<span class="sy4">;</span> i<span class="sy1">&lt;=</span>r<span class="sy4">;</span> <span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy2">%</span> len <span class="sy1">==</span> <span class="nu0">0</span> <span class="sy3">&amp;&amp;</span> i <span class="sy2">+</span> len <span class="sy2">-</span> <span class="nu0">1</span> <span class="sy1">&lt;=</span> r<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="co1">// если i указывает на начало блока, целиком лежащего в [l;r]</span>
			sum <span class="sy2">+</span><span class="sy1">=</span> b<span class="br0">&#91;</span>i <span class="sy2">/</span> len<span class="br0">&#93;</span><span class="sy4">;</span>
			i <span class="sy2">+</span><span class="sy1">=</span> len<span class="sy4">;</span>
		<span class="br0">&#125;</span>
		<span class="kw1">else</span> <span class="br0">&#123;</span>
			sum <span class="sy2">+</span><span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
			<span class="sy2">++</span>i<span class="sy4">;</span>
		<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Недостатком этой реализации является то, что в ней неоправданно много операций деления (которые, как известно, выполняются значительно медленнее других операций). Вместо этого можно посчитать номера блоков <img class=tex src="../tex2png/cache/59c3a12e81947e10f1c08c7a74f4028e.png" alt="c_l"> и <img class=tex src="../tex2png/cache/2a0073e7f2828856e971fa62bd780c41.png" alt="c_r">, в которых лежат границы <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> и <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> соответственно, и затем сделать цикл по блокам с <img class=tex src="../tex2png/cache/4d702442de6f5b9fc73e31ced5e95291.png" alt="c_l+1"> по <img class=tex src="../tex2png/cache/a8bb5b8afe8e233a4ca648024068f007.png" alt="c_r-1">, отдельно обработав "хвосты" в блоках <img class=tex src="../tex2png/cache/59c3a12e81947e10f1c08c7a74f4028e.png" alt="c_l"> и <img class=tex src="../tex2png/cache/2a0073e7f2828856e971fa62bd780c41.png" alt="c_r">. Кроме того, при такой реализации случай <img class=tex src="../tex2png/cache/e32a8d2da7e5a2adb623b7a2eca93b00.png" alt="c_l = c_r"> становится особым и требует отдельной обработки:<p><pre class="notranslate cpp"><span class="kw4">int</span> sum <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw4">int</span> c_l <span class="sy1">=</span> l <span class="sy2">/</span> len,   c_r <span class="sy1">=</span> r <span class="sy2">/</span> len<span class="sy4">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>c_l <span class="sy1">==</span> c_r<span class="br0">&#41;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>l<span class="sy4">;</span> i<span class="sy1">&lt;=</span>r<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		sum <span class="sy2">+</span><span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw1">else</span> <span class="br0">&#123;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>l, end<span class="sy1">=</span><span class="br0">&#40;</span>c_l<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy2">*</span>len<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;=</span>end<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		sum <span class="sy2">+</span><span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>c_l<span class="sy2">+</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;=</span>c_r<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		sum <span class="sy2">+</span><span class="sy1">=</span> b<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>c_r<span class="sy2">*</span>len<span class="sy4">;</span> i<span class="sy1">&lt;=</span>r<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		sum <span class="sy2">+</span><span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h3 style="padding-top:15px;">Другие задачи</h3><p>Мы рассматривали задачу нахождения суммы элементов массива в каком-то его подотрезке. Эту задачу можно немного расширить: разрешим также <b>меняться</b> отдельным элементам массива <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A">. Действительно, если меняется какой-то элемент <img class=tex src="../tex2png/cache/ef875bf5bad8370d4f3bbe3c740d3dd3.png" alt="a_i">, то достаточно обновить значение <img class=tex src="../tex2png/cache/e41b82131f67211d919da00859e908b9.png" alt="b[k]"> в том блоке, в котором этот элемент находится (<img class=tex src="../tex2png/cache/d3a7de2ca1bec25311494e7101a1d5fb.png" alt="k = i / len">):<p><p class=formula><img class=tex src="../tex2png/cache/69c2bbc50be3a3a96149c9725fe5f2c5.png" alt=" b[k] += a[i] - old\_a[i]. "></p><p>С другой стороны, вместо задачи о сумме аналогично можно решать задачи о <b>минимальном, максимальном</b> элементах в отрезке. Если в этих задачах допускать изменения отдельных элементов, то тоже надо будет пересчитывать значение <img class=tex src="../tex2png/cache/dc588a78c0b54005094f2e9632ac3a38.png" alt="b_k"> того блока, которому принадлежит изменяемый элемент, но пересчитывать уже полностью, проходом по всем элементам блока за <img class=tex src="../tex2png/cache/2d467b392c109c137af0ae99b63ea085.png" alt="O(len) = O(\sqrt{n})"> операций.<p>Аналогичным образом sqrt-декомпозицию можно применять и для множества <b>других</b> подобных задач: нахождение количества нулевых элементов, первого ненулевого элемента, подсчёта количества определённых элементов, и т.д.<p>Есть и целый класс задач, когда происходят <b>изменения элементов на целом подотрезке</b>: прибавление или присвоение элементов на каком-то подотрезке массива <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A">.<p>Например, нужно выполнять следующие два вида запросов: прибавить ко всем элементам некоторого отрезка <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> величину <img class=tex src="../tex2png/cache/f6b0b63b4a525030adf32292343cdf97.png" alt="\delta">, и узнавать значение отдельного элемента <img class=tex src="../tex2png/cache/ef875bf5bad8370d4f3bbe3c740d3dd3.png" alt="a_i">. Тогда в качестве <img class=tex src="../tex2png/cache/dc588a78c0b54005094f2e9632ac3a38.png" alt="b_k"> положим ту величину, которая должна быть прибавлена ко всем элементам <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-го блока (например, изначально все <img class=tex src="../tex2png/cache/fa26c22644b6ff04e1b0a4c8e13560d1.png" alt="b_k = 0">); тогда при выполнении запроса "прибавление" нужно будет выполнить прибавление ко всем элементам <img class=tex src="../tex2png/cache/ef875bf5bad8370d4f3bbe3c740d3dd3.png" alt="a_i"> "хвостов", а затем выполнить прибавление ко всем элементам <img class=tex src="../tex2png/cache/0993821d823b5b792321f13c90efa683.png" alt="b_i"> для блоков, целиком лежащих в отрезке <img class=tex src="../tex2png/cache/653023af1da32cf3f51fe321fa0778da.png" alt="[l \ldots r]">. А ответом на второй запрос, очевидно, будет просто <img class=tex src="../tex2png/cache/6a35f4964da222b0923265faac8c87fd.png" alt="a_i + b_k">, где <img class=tex src="../tex2png/cache/d3a7de2ca1bec25311494e7101a1d5fb.png" alt="k = i / len">. Таким образом, прибавление на отрезке будет выполняться за <img class=tex src="../tex2png/cache/e89d540813b771cb61aba6ca1d79b86e.png" alt="O(\sqrt{n})">, а запрос отдельного элемента &mdash; за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)">.<p>Наконец, можно комбинировать оба вида задач: изменение элементов на отрезке и ответ на запросы тоже на отрезке. Оба вида операций будут выполняться за <img class=tex src="../tex2png/cache/e89d540813b771cb61aba6ca1d79b86e.png" alt="O(\sqrt{n})">. Для этого уже надо будет делать два "блоковых" массива <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> и <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">: один &mdash; для обеспечения изменений на отрезке, другой &mdash; для ответа на запросы.<p>Можно привести пример и других задач, к которым можно применить sqrt-декомпозицию. Например, можно решать задачу о <b>поддержании множества чисел</b> с возможностью добавления/удаления чисел, проверки числа на принадлежность множеству, поиск <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-го по порядку числа. Для решения этой задачи надо хранить числа в отсортированном порядке, разделёнными на несколько блоков по <img class=tex src="../tex2png/cache/59924d89d7dd54098a99b85b4e3cda4b.png" alt="\sqrt{n}"> чисел в каждом. При добавлении или удалении числа надо будет производить "перебалансировку" блоков, перебрасывая числа из начал/концов одних блоков в начала/концы соседних блоков.<p><p><h2 style="padding-top:40px;">Sqrt-декомпозиция входных запросов</h2><p>Рассмотрим теперь совершенно иное применение идеи об sqrt-декомпозиции.<p>Предположим, что у нас есть некоторая задача, в которой нам даются некоторые входные данные, а затем поступают <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> команд/запросов, каждую из которых мы должны дать обработать и выдать ответ. Мы рассматриваем случай, когда запросы бывают как запрашивающие (не меняющие состояния системы, а только запрашивающие некоторую информацию), так и модифицирующие (т.е. влияющие на состояние системы, изначально заданное входными данными).<p>Конкретная задача может быть весьма сложной, и "честное" её решение (которое считывает один запрос, обрабатывает его, изменяя состояние системы, и возвращает ответ) может быть технически сложным или вовсе быть не по силам для решающего. С другой стороны, решение "оффлайнового" варианта задачи, т.е. когда отсутствуют модифицирующие операции, а имеются только лишь запрашивающие запросы &mdash; часто оказывается гораздо проще. Предположим, что мы <b>умеем решать "оффлайновый" вариант</b> задачи, т.е. строить за некоторое время <img class=tex src="../tex2png/cache/a98ee0652f294c121a56ea027f633960.png" alt="B(n)"> некую структуру данных, которая может отвечать на запросы, но не умеет обрабатывать модифицирующие запросы.<p>Тогда <b>разобьём входные запросы на блоки</b> (какой длины &mdash; пока не уточняем; обозначим эту длину через <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">). В начале обработки каждого блока будем за <img class=tex src="../tex2png/cache/a98ee0652f294c121a56ea027f633960.png" alt="B(n)"> строить структуру данных для "оффлайнового" варианта задачи по состоянию данных на момент начала этого блока.<p>Теперь будем по очереди брать запросы из текущего блока и обрабатывать каждый из них. Если текущий запрос &mdash; модифицирующий, то пропустим его. Если же текущий запрос &mdash; запрашивающий, то обратимся к структуре данных для оффлайнового варианта задачи, но предварительно <b>учтя все модифицирующие запросы в текущем блоке</b>. Такое учитывание модифицирующих запросов бывает возможным далеко не всегда, и оно должно происходить достаточно быстро &mdash; за время <img class=tex src="../tex2png/cache/880870901a6dc66bf68a0d2d8f583dda.png" alt="O(s)"> или немного хуже; обозначим это время через <img class=tex src="../tex2png/cache/945931122ecff2907689b748cea7e7b2.png" alt="Q(s)">.<p>Таким образом, если всего у нас <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> запросов, то на их обработку потребуется <img class=tex src="../tex2png/cache/a2df376b25be8777a814fe08f04de092.png" alt="B(m) \frac{m}{s} + m Q(s)"> времени. Величину <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> следует выбирать, исходя из конкретного вида функций <img class=tex src="../tex2png/cache/e640d0e51c946391a7fda156e5638525.png" alt="B()"> и <img class=tex src="../tex2png/cache/df74d760b7ec0b7771a53c9afd910192.png" alt="Q()">. Например, если <img class=tex src="../tex2png/cache/f9a00be2e00b5ed83fc19e3f984c18c6.png" alt="B(m)=O(m)"> и <img class=tex src="../tex2png/cache/cc96881c8675df562c640cd50b942b1f.png" alt="Q(s)=O(s)">, то оптимальным выбором будет <img class=tex src="../tex2png/cache/fe94d9c55a388e66fe018a9f4925ce2a.png" alt="s \approx \sqrt{m}">, и итоговая асимптотика получится <img class=tex src="../tex2png/cache/c036751067846fe12ce7c46db3954295.png" alt="O (m \sqrt{m})">.<p>Поскольку приведённые выше рассуждения слишком абстрактны, приведём несколько примеров задач, к которым применима такая sqrt-декомпозиция.<p><p><h3 style="padding-top:15px;">Пример задачи: прибавление на отрезке</h3><p>Условие задачи: дан массив чисел <img class=tex src="../tex2png/cache/882c9eac4789d4397cc304ec6933ec6e.png" alt="a[1 \ldots n]">, и поступают запросы двух видов: узнать значение в <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ом элементе массива, и прибавить некоторое число <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> ко всем элементам массива в некотором отрезке <img class=tex src="../tex2png/cache/301805acd8bb348b42f7e89540ac8d84.png" alt="a[l \dots r]">.<p>Хотя эту задачу можно решать и без этого приёма с разбиением запросов на блоки, мы приведём её здесь &mdash; как простейшее и наглядное применение этого метода.<p>Итак, разобьём входные запросы на блоки по <img class=tex src="../tex2png/cache/e04accd41225fc6a693f8554729890f6.png" alt="\sqrt{m}"> (где <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> &mdash; число запросов). В начале первого блока запросов никаких структур строить не надо, просто храним массив <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]">. Идём теперь по запросам первого блока. Если текущий запрос &mdash; запрос прибавления, то пока пропускаем его. Если же текущий запрос &mdash; запрос чтения значения в некоторой позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, то вначале просто возьмём в качестве ответа значение <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]">. Затем пройдёмся по всем пропущенным в этом блоке запросам прибавления, и для тех из них, в которые попадает <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, применим их увеличения к текущему ответу.<p>Таким образом, мы научились отвечать на запрашивающие запросы за время <img class=tex src="../tex2png/cache/9234a1aea607255b3ed67b1c478761df.png" alt="O(\sqrt{m})">.<p>Осталось только заметить, что в конце каждого блока запросов мы должны применить все модифицирующие запросы этого блока к массиву <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]">. Но это легко сделать за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> &mdash; достаточно для каждого запроса прибавления <img class=tex src="../tex2png/cache/2299c7cb2af1f2f4088808efbc21bf69.png" alt="(l,r,x)"> отметить в вспомогательном массиве в точке <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> число <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">, а в точке <img class=tex src="../tex2png/cache/005ef78ebc43937bc2262cec731be2ac.png" alt="r+1"> &mdash; число <img class=tex src="../tex2png/cache/6336282e981b1354731385a4d0f0646c.png" alt="-x">, и затем пройтись по этому массиву, прибавляя текущую сумму к массиву <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]">.<p>Таким образом, итоговая асимптотика решения составит <img class=tex src="../tex2png/cache/69d549356f4de4b5d0f4b634bc7941c9.png" alt="O (\sqrt{m} (n + m))">.<p><p><h3 style="padding-top:15px;">Пример задачи: disjoint-set-union с разделением</h3><p>Есть неориентированный граф с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами и <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> рёбрами. Поступают запросы трёх видов: добавить ребро <img class=tex src="../tex2png/cache/a5be10853e90ed2cd02bc9bf3215a165.png" alt="(x_i,y_i)">, удалить ребро <img class=tex src="../tex2png/cache/a5be10853e90ed2cd02bc9bf3215a165.png" alt="(x_i,y_i)">, и проверить, связаны или нет вершины <img class=tex src="../tex2png/cache/bdf4742dd10f0eb4f2b7801e40b0e129.png" alt="x_i"> и <img class=tex src="../tex2png/cache/fb0ccfa89dc1cadb04e1c765e4f696d7.png" alt="y_i"> путём.<p>Если бы запросы удаления отсутствовали, то решением задачи была бы известная структура данных <a href="dsu.html">disjoint-set-union (система непересекающихся множеств)</a>. Однако при наличии удалений задача значительно усложняется.<p>Сделаем следующим образом. В начале каждого блока запросов посмотрим, какие рёбра в этом блоке будут удаляться, и сразу <b>удалим</b> их из графа. Теперь построим систему непересекающихся множеств (dsu) на полученном графе.<p>Как мы теперь должны отвечать на очередной запрос из текущего блока? Наша система непересекающихся множеств "знает" обо всех рёбрах, кроме тех, что добавляются/удаляются в текущем блоке. Однако удаления из dsu нам делать уже не надо &mdash; мы заранее удалили все такие рёбра из графа. Таким образом, всё, что может быть &mdash; это дополнительные, добавляющиеся рёбра, которых может быть максимум <img class=tex src="../tex2png/cache/e04accd41225fc6a693f8554729890f6.png" alt="\sqrt{m}"> штук.<p>Следовательно, при ответе на текущий запрашивающий запрос мы можем просто пустить обход в ширину по компонентам связности dsu, который отработает за <img class=tex src="../tex2png/cache/9234a1aea607255b3ed67b1c478761df.png" alt="O(\sqrt{m})">, поскольку у нас в рассмотрении будут только <img class=tex src="../tex2png/cache/9234a1aea607255b3ed67b1c478761df.png" alt="O(\sqrt{m})"> рёбер.<p><p><p><h2 style="padding-top:40px;">Оффлайновые задачи на запросы на подотрезках массива и универсальная sqrt-эвристика для них</h2><p>Рассмотрим ещё одну интересную вариацию идеи sqrt-декомпозиции.<p>Пусть у нас есть некоторая задача, в которой есть массив чисел, и поступают запрашивающие запросы, имеющие вид <img class=tex src="../tex2png/cache/5da5090de09ee020bba6974c7d377e42.png" alt="(l,r)"> &mdash; узнать что-то о подотрезке <img class=tex src="../tex2png/cache/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a[l \ldots r]">. Мы считаем, что запросы не модифицирующие, и известны нам заранее, т.е. задача &mdash; оффлайновая.<p>Наконец, введём последнее <b>ограничение</b>: мы считаем, что умеем быстро пересчитывать ответ на запрос при изменении левой или правой границы на единицу. Т.е. если мы знали ответ на запрос <img class=tex src="../tex2png/cache/5da5090de09ee020bba6974c7d377e42.png" alt="(l,r)">, то быстро сможем посчитать ответ на запрос <img class=tex src="../tex2png/cache/24b590a60be1ac182ba662aabbdd674e.png" alt="(l+1,r)"> или <img class=tex src="../tex2png/cache/274fb56d840657babfd6c92570ea5611.png" alt="(l-1,r)"> или <img class=tex src="../tex2png/cache/6caf9e5f0ed633386b3d489a1d39590d.png" alt="(l,r+1)"> или <img class=tex src="../tex2png/cache/ab9d4e6c249f705692f66bf8e1a3b6f5.png" alt="(l,r-1)">.<p>Опишем теперь <b>универсальную эвристику</b> для всех таких задач. Отсортируем запросы по паре: <img class=tex src="../tex2png/cache/00194c0db6cd4c295130f582cace3c95.png" alt="(l ~ {\rm div} ~ \sqrt{n}, r)">. Т.е. мы отсортировали запросы по номеру sqrt-блока, в котором лежит левый конец, а при равенстве &mdash; по правому концу.<p>Рассмотрим теперь группу запросов с одинаковым значением <img class=tex src="../tex2png/cache/b34d052e37a345b00b537cd9cbb41a8c.png" alt="l ~ {\rm div} ~ \sqrt{n}"> и будем обрабатывать все запросы этой группы. Ответ на первый запрос посчитаем тривиальным образом. Каждый следующий запрос будем считать на основе предыдущего ответа: т.е. двигать левую и правую границы предыдущего запроса к границам следующего запроса, поддерживая при этом текущий ответ. Оценим асимптотику: левая граница каждый раз могла двигаться на не более <img class=tex src="../tex2png/cache/59924d89d7dd54098a99b85b4e3cda4b.png" alt="\sqrt{n}"> раз, а правая &mdash; не более <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> раз в сумме по всем запросам текущей группы. Итого, если текущая группа состояла из <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> запросов, в сумме будет совершено не более <img class=tex src="../tex2png/cache/a65f08af97029a73f977eeeb098e4c6a.png" alt="n + k \cdot \sqrt{n}"> пересчётов. В сумме по всему алгоритму получится &mdash; <img class=tex src="../tex2png/cache/4c45415df2faa4fc294c4984aa9d5d89.png" alt="O((n + m) \cdot \sqrt{n})"> пересчётов.<p>Простым <b>примером</b> на данную эвристику является такая задача: узнать количество различных чисел в отрезке массива <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]">.<p>Чуть более усложнённым вариантом этой задачи является <a href="http://www.codeforces.ru/contest/86/problem/D">задача с одного из раундов Codeforces</a>.<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>