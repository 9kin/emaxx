<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Обратная задача SSSP (inverse-SSSP - обратная задача кратчайших путей из одной вершины)</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 23:10<br>редактировано: 10 Jun 2008 23:11</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="inverse_sssp.html#" id="contents-hide">[скрыть]</a><a href="inverse_sssp.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Обратная задача SSSP (inverse-SSSP - обратная задача кратчайших путей из одной вершины)</h1>

<p>Имеется взвешенный неориентированный мультиграф G из N вершин и M рёбер. Дан массив P[1..N] и указана некоторая начальная вершина S. Требуется изменить веса рёбер так, чтобы для всех I P[I] было равно длине кратчайшего пути из S в I, причём сумма всех изменений (сумма модулей изменений весов рёбер) была бы наименьшей. Если этого сделать невозможно, то алгоритм должен выдать "No solution". Делать вес ребра отрицательным запрещено.</p>
<h2>Описание решения</h2>
<p>Мы решим эту задачу за линейное время, просто перебрав все рёбра (т.е. за один проход).</p>
<p>Пусть на текущем шаге мы рассматриваем ребро из вершины A в вершину B длиной R. Мы предполагаем, что для вершины A уже все условия выполнены (т.е. расстояние от S до A действительно равно P[A]), и будем проверять выполнение условий для вершины B. Имеем несколько вариантов ситуации:</p>
<ul>
<li>1. <b>P[A] + R &lt; P[B]</b><br>Это означает, что мы нашли путь, более короткий, чем он должен быть. Поскольку P[A] и P[B] мы изменять не можем, то мы обязаны удлинить текущее ребро (независимо от остальных рёбер), а именно выполнить:<br>R += P[B] - P[A] - R.<br>Кроме того, это означает, что мы нашли уже путь в вершину B из S, длина которого равна требуемому значению P[B], поэтому на последующих шагах нам не придётся укорачивать какие-либо рёбра (см. вариант 2).</li>
<li>2. <b>P[A] + R >= P[B]</b><br>Это означает, что мы нашли путь, более длинный, чем требуемый. Поскольку таких путей может быть несколько, мы должны выбрать среди всех таких путей (рёбер) то, которое потребует наименьшего изменения. Повторимся, что если мы удлиняли какое-то ребро, ведущее в вершину B (вариант 1), то этим мы фактически построили кратчайший путь в вершину B, а потому укорачивать никакое ребро уже не надо будет. Таким образом, для каждой вершины мы должны хранить ребро, которое собираемся укорачивать, т.е. ребро с наименьшим весом изменения.</li>
</ul>
<p>Таким образом, просто перебрав все рёбра, и рассмотрев для каждого ребра ситуацию (за O(1)), мы решим обратную задачу SSSP за линейное время.</p>
<p>Если в какой-то момент мы пытаемся изменить уже изменённое ребро, то, очевидно, этого делать нельзя, и следует выдать "No solution". Кроме того, у некоторых вершин может быть так и не достигнута требуемая оценка кратчайшего пути, тогда ответ тоже будет "No solution". Во всех остальных случаях (кроме, конечно, явно некорректных значений в массиве P, т.е. P[S] != 0 или отрицательные значения) ответ будет существовать.</p>
<h2>Реализация</h2>
<p>Программа выводит "No solution", если решения нет, иначе выводит в первой строке минимальную сумму изменений весов рёбер, а в последующих M строках - новые веса рёбер.</p>
<pre>const int INF = 1000*1000*1000;
int n, m;
vector&lt;int> p (n);

bool ok = true;
vector&lt;int> cost (m), cost_ch (m), decrease (n, INF), decrease_id (n, -1);
decrease[0] = 0;
for (int i=0; i&lt;m; ++i) {
	int a, b, c; // текущее ребро (a,b) с ценой c
	cost[i] = c;

	for (int j=0; j&lt;=1; ++j) {
		int diff = p[b] - p[a] - c;
		if (diff > 0) {
			ok &= cost_ch[i] == 0 || cost_ch[i] == diff;
			cost_ch[i] = diff;
			decrease[b] = 0;
		}
		else
			if (-diff &lt;= c && -diff &lt; decrease[b]) {
				decrease[b] = -diff;
				decrease_id[b] = i;
			}
		swap (a, b);
	}
}

for (int i=0; i&lt;n; ++i) {
	ok &= decrease[i] != INF;
	int r_id = decrease_id[i];
	if (r_id != -1) {
		ok &= cost_ch[r_id] == 0 || cost_ch[r_id] == -decrease[i];
		cost_ch[r_id] = -decrease[i];
	}
}

if (!ok)
	cout &lt;&lt; "No solution";
else {
	long long sum = 0;
	for (int i=0; i&lt;m; ++i)  sum += abs (cost_ch[i]);
	cout &lt;&lt; sum &lt;&lt; '\n';
	for (int i=0; i&lt;m; ++i)
		printf ("%d ", cost[i] + cost_ch[i]);
}</pre><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>