<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Код Прюфера. Формула Кэли. Количество способов сделать граф связным</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 26 Mar 2012 1:00<br>редактировано: 26 Mar 2012 1:00</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="prufer_code_cayley_formula.html#" id="contents-hide">[скрыть]</a><a href="prufer_code_cayley_formula.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Код Прюфера. Формула Кэли. Количество способов сделать граф связным </h1><p>В данной статье мы рассмотрим так называемый <b>код Прюфера</b>, который представляет из себя способ однозначного кодирования помеченного дерева с помощью последовательности чисел.<p>С помощью кодов Прюфера демонстрируется доказательство <b>формулы Кэли</b> (задающей количество остовных деревьев в полном графе), а также решение задачи о количестве способов добавить в заданный граф рёбра, чтобы превратить его в связный.<p><b>Примечание</b>. Мы не будем рассматривать деревья, состоящие из единственной вершины, &mdash; это особый случай, на котором многие утверждения вырождаются.<p><p><p><h2 style="padding-top:40px;"> Код Прюфера </h2><p>Код Прюфера &mdash; это способ взаимно однозначного кодирования помеченных деревьев с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами с помощью последовательности <img class=tex src="../tex2png/cache/3c24e4e1066ea76ff7ba0fb29a761758.png" alt="n-2"> целых чисел в отрезке <img class=tex src="../tex2png/cache/526eecfe9426198c72ecda20833889a2.png" alt="[1;n]">. Иными словами, код Прюфера &mdash; это <b>биекция</b> между всеми остовными деревьями полного графа и числовыми последовательностями.<p>Хотя использовать код Прюфера для хранения и оперирования с деревьями нецелесообразно из-за специфичности представления, коды Прюфера находят применения в решении комбинаторных задач.<p>Автор &mdash; Хейнц Прюфер (Heinz Pr&#252;fer) &mdash; предложил этот код в 1918 г. как доказательство формулы Кэли (см. ниже).<p><p><h3 style="padding-top:15px;"> Построение кода Прюфера для данного дерева </h3><p>Код Прюфера строится следующим образом. Будем <img class=tex src="../tex2png/cache/3c24e4e1066ea76ff7ba0fb29a761758.png" alt="n-2"> раза проделывать процедуру: выбираем лист дерева с наименьшим номером, удаляем его из дерева, и добавляем к коду Прюфера номер вершины, которая была связана с этим листом. В конце концов в дереве останется только <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2"> вершины, и алгоритм на этом завершается (номер этих вершин явным образом в коде не записываются).<p>Таким образом, код Прюфера для заданного дерева &mdash; это последовательность из <img class=tex src="../tex2png/cache/3c24e4e1066ea76ff7ba0fb29a761758.png" alt="n-2"> чисел, где каждое число &mdash; номер вершины, связанной с наименьшим на тот момент листом &mdash; т.е. это число в отрезке <img class=tex src="../tex2png/cache/526eecfe9426198c72ecda20833889a2.png" alt="[1;n]">.<p>Алгоритм вычисления кода Прюфера легко реализовать с асимптотикой <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">, просто поддерживая структуру данных для извлечения минимума (например, <img class=tex src="../tex2png/cache/2c5f1363a0556d7fbb6be5f5cc6bd878.png" alt="\rm set<>"> или <img class=tex src="../tex2png/cache/becf068890e021899ba047c2ad437cf6.png" alt="\rm priority\_queue<>"> в языке C++), содержащую в себе список всех текущих листьев:<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> MAXN <span class="sy1">=</span> ...<span class="sy4">;</span>
<span class="kw4">int</span> n<span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> g<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">int</span> degree<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">bool</span> killed<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> prufer_code<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	set<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> leaves<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		degree<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>degree<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="nu0">1</span><span class="br0">&#41;</span>
			leaves.<span class="me1">insert</span> <span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>
		killed<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> result <span class="br0">&#40;</span>n<span class="sy2">-</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> iter<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> iter<span class="sy1">&lt;</span>n<span class="sy2">-</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>iter<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> leaf <span class="sy1">=</span> <span class="sy2">*</span>leaves.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		leaves.<span class="me1">erase</span> <span class="br0">&#40;</span>leaves.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		killed<span class="br0">&#91;</span>leaf<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
&nbsp;
		<span class="kw4">int</span> v<span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>leaf<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>killed<span class="br0">&#91;</span>g<span class="br0">&#91;</span>leaf<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#41;</span>
				v <span class="sy1">=</span> g<span class="br0">&#91;</span>leaf<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
		result<span class="br0">&#91;</span>iter<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy2">--</span>degree<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="nu0">1</span><span class="br0">&#41;</span>
			leaves.<span class="me1">insert</span> <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> result<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Впрочем, построение кода Прюфера можно реализовать и за линейное время, что описывается в следующем разделе.<p><p><h3 style="padding-top:15px;"> Построение кода Прюфера для данного дерева за линейное время </h3><p>Приведём здесь простой алгоритм, имеющий асимптотику <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">.<p>Суть алгоритма заключается в хранении <b>движущегося указателя</b> <img class=tex src="../tex2png/cache/62c1be13ce000549b0095fbbfd087a3f.png" alt="ptr">, который всегда будет продвигаться только в сторону увеличения номеров вершин.<p>На первый взгляд, такое невозможно, ведь в процессе построения кода Прюфера номера листьев могут как увеличиваться, так и <b>уменьшаться</b>. Однако легко заметить, что уменьшения происходят только в единственном случае: кода при удалении текущего листа его предок имеет меньший номер (этот предок станет минимальным листом и удалится из дерева на следующем же шаге кода Прюфера). Таким образом, случаи уменьшения можно обработать за время <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)">, и ничего не мешает построению алгоритма с <b>линейной асимптотикой</b>:<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> MAXN <span class="sy1">=</span> ...<span class="sy4">;</span>
<span class="kw4">int</span> n<span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> g<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">int</span> parent<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, degree<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> dfs <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> to <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>to <span class="sy3">!</span><span class="sy1">=</span> parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			parent<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
			dfs <span class="br0">&#40;</span>to<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> prufer_code<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	parent<span class="br0">&#91;</span>n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	dfs <span class="br0">&#40;</span>n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw4">int</span> ptr <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		degree<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>degree<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> ptr <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
			ptr <span class="sy1">=</span> i<span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> result<span class="sy4">;</span>
	<span class="kw4">int</span> leaf <span class="sy1">=</span> ptr<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> iter<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> iter<span class="sy1">&lt;</span>n<span class="sy2">-</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>iter<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> next <span class="sy1">=</span> parent<span class="br0">&#91;</span>leaf<span class="br0">&#93;</span><span class="sy4">;</span>
		result.<span class="me1">push_back</span> <span class="br0">&#40;</span>next<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="sy2">--</span>degree<span class="br0">&#91;</span>next<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>degree<span class="br0">&#91;</span>next<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> next <span class="sy1">&lt;</span> ptr<span class="br0">&#41;</span>
			leaf <span class="sy1">=</span> next<span class="sy4">;</span>
		<span class="kw1">else</span> <span class="br0">&#123;</span>
			<span class="sy2">++</span>ptr<span class="sy4">;</span>
			<span class="kw1">while</span> <span class="br0">&#40;</span>ptr<span class="sy1">&lt;</span>n <span class="sy3">&amp;&amp;</span> degree<span class="br0">&#91;</span>ptr<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">1</span><span class="br0">&#41;</span>
				<span class="sy2">++</span>ptr<span class="sy4">;</span>
			leaf <span class="sy1">=</span> ptr<span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> result<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Прокомментируем этот код. Основная функция здесь &mdash; <img class=tex src="../tex2png/cache/0abf0603152817c98e27ba04f6b4ccc5.png" alt="\rm prufer\_code()">, которая возвращает код Прюфера для дерева, заданного в глобальных переменных <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> (количество вершин) и <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> (списки смежности, задающие граф). Вначале мы находим для каждой вершины её предка <img class=tex src="../tex2png/cache/734ce16646e67c9edb154fed4e574bb7.png" alt="{\rm parent}[i]"> &mdash; т.е. того предка, которого эта вершина будет иметь в момент удаления из дерева (всё это мы можем найти заранее, пользуясь тем, что максимальная вершина <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> никогда не удалится из дерева). Также мы находим для каждой вершины её степень <img class=tex src="../tex2png/cache/98507a85f4beeb7b7cf98be70ffaab1b.png" alt="{\rm degree}[i]">. Переменная <img class=tex src="../tex2png/cache/705242366933656ae2b224b2f947f033.png" alt="\rm ptr"> &mdash; это движущийся указатель ("кандидат" на минимальный лист), который изменяется всегда только в сторону увеличения. Переменная <img class=tex src="../tex2png/cache/9c71249e334d7e5cfc62cb9630bc7bc6.png" alt="\rm leaf"> &mdash; это текущий лист с минимальным номером. Таким образом, каждая итерация кода Прюфера заключается в добавлении <img class=tex src="../tex2png/cache/9c71249e334d7e5cfc62cb9630bc7bc6.png" alt="\rm leaf"> в ответ, а также проверке, не оказалось ли <img class=tex src="../tex2png/cache/fefe6f8f4413e8becd380d1671b45a07.png" alt="\rm parent[leaf]"> меньше текущего кандидата <img class=tex src="../tex2png/cache/705242366933656ae2b224b2f947f033.png" alt="\rm ptr">: если оказалось меньше, то мы просто присваиваем <img class=tex src="../tex2png/cache/0d4312dff65e3e3cc1cffe6ab9f89778.png" alt="\rm leaf = parent[leaf]">, а в противном случае &mdash; двигаем указатель <img class=tex src="../tex2png/cache/705242366933656ae2b224b2f947f033.png" alt="\rm ptr"> до следующего листа.<p>Как легко видно по коду, асимптотика алгоритма действительно составляет <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">: указатель <img class=tex src="../tex2png/cache/705242366933656ae2b224b2f947f033.png" alt="\rm ptr"> претерпит лишь <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> изменений, а все остальные части алгоритма очевидно работают за линейное время.<p><p><h3 style="padding-top:15px;"> Некоторые свойства кодов Прюфера </h3><p><ul><p><li>По окончании построения кода Прюфера в дереве останутся неудалёнными две вершины.<p>Одной из них точно будет вершина с максимальным номером &mdash; <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">, а вот про другую вершину ничего определённого сказать нельзя.<p><li>Каждая вершина встречается в коде Прюфера определённое число раз, равное её степени минус один.<p>Это легко понять, если заметить, что вершина удаляется из дерева в момент, когда её степень равна единице &mdash; т.е. к этому моменту все смежные с ней рёбра, кроме одного, были удалены. (Для двух оставшихся после построения кода вершин это утверждение тоже верно.)<p></ul><p><p><h3 style="padding-top:15px;"> Восстановление дерева по его коду Прюфера </h3><p>Для восстановления дерева достаточно заметить из предыдущего пункта, что степени всех вершин в искомом дереве мы уже знаем (и можем посчитать и сохранить в некотором массиве <img class=tex src="../tex2png/cache/eafcdd621f4bc0c92098c05e9208edab.png" alt="degree[]">). Следовательно, мы можем найти все листья, и, соответственно, номер наименьшего листа &mdash; который был удалён на первом шаге. Этот лист был соединён с вершиной, номер которой записан в первой ячейке кода Прюфера.<p>Таким образом, мы нашли первое ребро, удалённое кодом Прюфера. Добавим это ребро в ответ, затем уменьшим степени <img class=tex src="../tex2png/cache/eafcdd621f4bc0c92098c05e9208edab.png" alt="degree[]"> у обоих концов ребра.<p>Будем повторять эту операцию, пока не просмотрим весь код Прюфера: искать минимальную вершину с <img class=tex src="../tex2png/cache/a201503c112b560d38cb827cbb721312.png" alt="degree = 1">, соединять её с очередной вершиной кода Прюфера, уменьшать <img class=tex src="../tex2png/cache/eafcdd621f4bc0c92098c05e9208edab.png" alt="degree[]"> у обоих концов.<p>В конце концов у нас останется только две вершины с <img class=tex src="../tex2png/cache/a201503c112b560d38cb827cbb721312.png" alt="degree = 1"> &mdash; это те вершины, который алгоритм Прюфера оставил неудалёнными. Соединим их ребром.<p>Алгоритм завершён, искомое дерево построено.<p><b>Реализовать</b> этот алгоритм легко за время <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">: поддерживая в структуре данных для извлечения минимума (например, <img class=tex src="../tex2png/cache/2c5f1363a0556d7fbb6be5f5cc6bd878.png" alt="\rm set<>"> или <img class=tex src="../tex2png/cache/becf068890e021899ba047c2ad437cf6.png" alt="\rm priority\_queue<>"> в C++) номера всех вершин, имеющих <img class=tex src="../tex2png/cache/c0fe07d30e4115f2d8454904b060ec7c.png" alt="degree=1">, и извлекая из него каждый раз минимум.<p>Приведём соответствующую реализацию (где функция <img class=tex src="../tex2png/cache/6a0470ba3a3f6df8bc15cd35a258c447.png" alt="prufer\_decode()"> возвращает список из рёбер искомого дерева):<p><pre class="notranslate cpp">vector <span class="sy1">&lt;</span> pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> prufer_decode <span class="br0">&#40;</span><span class="kw4">const</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> prufer_code<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> prufer_code.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy2">+</span> <span class="nu0">2</span><span class="sy4">;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> degree <span class="br0">&#40;</span>n, <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy2">-</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="sy2">++</span>degree<span class="br0">&#91;</span>prufer_code<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
	set<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> leaves<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>degree<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="nu0">1</span><span class="br0">&#41;</span>
			leaves.<span class="me1">insert</span> <span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	vector <span class="sy1">&lt;</span> pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> result<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy2">-</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> leaf <span class="sy1">=</span> <span class="sy2">*</span>leaves.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		leaves.<span class="me1">erase</span> <span class="br0">&#40;</span>leaves.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
		<span class="kw4">int</span> v <span class="sy1">=</span> prufer_code<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		result.<span class="me1">push_back</span> <span class="br0">&#40;</span>make_pair <span class="br0">&#40;</span>leaf, v<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy2">--</span>degree<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="nu0">1</span><span class="br0">&#41;</span>
			leaves.<span class="me1">insert</span> <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	result.<span class="me1">push_back</span> <span class="br0">&#40;</span>make_pair <span class="br0">&#40;</span><span class="sy2">*</span>leaves.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, <span class="sy2">*--</span>leaves.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">return</span> result<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h3 style="padding-top:15px;"> Восстановление дерева по коду Прюфера за линейное время </h3><p>Для получения алгоритма с линейной асимптотикой можно применить тот же самый приём, что применялся для получения линейного алгоритма вычисления кода Прюфера.<p>В самом деле, для нахождения листа с наименьшим номером необязательно заводить структуру данных для извлечения минимума. Вместо этого можно заметить, что, после того как мы находим и обрабатываем текущий лист, он добавляет в рассмотрение только одну новую вершину. Следовательно, мы можем обойтись одним движущимся указателем вместе с переменной, хранящей в себе текущий минимальный лист:<p><pre class="notranslate cpp">vector <span class="sy1">&lt;</span> pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> prufer_decode_linear <span class="br0">&#40;</span><span class="kw4">const</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> prufer_code<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> prufer_code.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy2">+</span> <span class="nu0">2</span><span class="sy4">;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> degree <span class="br0">&#40;</span>n, <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy2">-</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="sy2">++</span>degree<span class="br0">&#91;</span>prufer_code<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw4">int</span> ptr <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>ptr <span class="sy1">&lt;</span> n <span class="sy3">&amp;&amp;</span> degree<span class="br0">&#91;</span>ptr<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">1</span><span class="br0">&#41;</span>
		<span class="sy2">++</span>ptr<span class="sy4">;</span>
	<span class="kw4">int</span> leaf <span class="sy1">=</span> ptr<span class="sy4">;</span>
&nbsp;
	vector <span class="sy1">&lt;</span> pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> result<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy2">-</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> v <span class="sy1">=</span> prufer_code<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		result.<span class="me1">push_back</span> <span class="br0">&#40;</span>make_pair <span class="br0">&#40;</span>leaf, v<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
		<span class="sy2">--</span>degree<span class="br0">&#91;</span>leaf<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy2">--</span>degree<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> v <span class="sy1">&lt;</span> ptr<span class="br0">&#41;</span>
			leaf <span class="sy1">=</span> v<span class="sy4">;</span>
		<span class="kw1">else</span> <span class="br0">&#123;</span>
			<span class="sy2">++</span>ptr<span class="sy4">;</span>
			<span class="kw1">while</span> <span class="br0">&#40;</span>ptr <span class="sy1">&lt;</span> n <span class="sy3">&amp;&amp;</span> degree<span class="br0">&#91;</span>ptr<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">1</span><span class="br0">&#41;</span>
				<span class="sy2">++</span>ptr<span class="sy4">;</span>
			leaf <span class="sy1">=</span> ptr<span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> v<span class="sy1">&lt;</span>n<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> <span class="sy2">++</span>v<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>degree<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="nu0">1</span><span class="br0">&#41;</span>
			result.<span class="me1">push_back</span> <span class="br0">&#40;</span>make_pair <span class="br0">&#40;</span>v, n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">return</span> result<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h3 style="padding-top:15px;"> Взаимная однозначность соответствия между деревьями и кодами Прюфера </h3><p>С одной стороны, для каждого дерева существует ровно один код Прюфера, соответствующий ему (это следует из определения кода Прюфера).<p>С другой стороны, из корректности алгоритма восстановления дерева по коду Прюфера следует, что любому коду Прюфера (т.е. последовательности из <img class=tex src="../tex2png/cache/3c24e4e1066ea76ff7ba0fb29a761758.png" alt="n-2"> чисел, где каждое число лежит в отрезке <img class=tex src="../tex2png/cache/526eecfe9426198c72ecda20833889a2.png" alt="[1;n]">) соответствует некоторое дерево.<p>Таким образом, все деревья и все коды Прюфера образуют <b>взаимно однозначное соответствие</b>.<p><p><p><h2 style="padding-top:40px;"> Формула Кэли </h2><p>Формула Кэли гласит, что <b>количество остовных деревьев в полном помеченном графе</b> из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершин равно:<p><p class=formula><img class=tex src="../tex2png/cache/41bfe4aa5ed0025e97b896643b44e7d2.png" alt=" n^{n-2}. "></p><p>Имеется много <b>доказательств</b> этой формулы, но доказательство с помощью кодов Прюфера наглядно и конструктивно.<p>В самом деле, любому набору из <img class=tex src="../tex2png/cache/3c24e4e1066ea76ff7ba0fb29a761758.png" alt="n-2"> чисел из отрезка <img class=tex src="../tex2png/cache/526eecfe9426198c72ecda20833889a2.png" alt="[1;n]"> однозначно соответствует некоторое дерево из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершин. Всего различных кодов Прюфера <img class=tex src="../tex2png/cache/ad4879b247a838f43042e03b2d92aee8.png" alt="n^{n-2}">. Поскольку в случае полного графа из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершин в качестве остова подходит любое дерево, то и количество остовных деревьев равно <img class=tex src="../tex2png/cache/ad4879b247a838f43042e03b2d92aee8.png" alt="n^{n-2}">, что и требовалось доказать.<p><p><p><h2 style="padding-top:40px;"> Количество способов сделать граф связным </h2><p>Мощь кодов Прюфера заключается в том, что они позволяют получить более общую формулу, чем формулу Кэли.<p>Итак, дан граф из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершин и <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> рёбер; пусть <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> &mdash; количество компонент связности в этом графе. Требуется найти число способов добавить <img class=tex src="../tex2png/cache/658627816b5be3d0859b8d0d52d03fd5.png" alt="k-1"> ребро, чтобы граф стал связным (очевидно, <img class=tex src="../tex2png/cache/658627816b5be3d0859b8d0d52d03fd5.png" alt="k-1"> ребро &mdash; минимально необходимое количество рёбер, чтобы сделать граф связным).<p>Выведем готовую формулу для решения этой задачи.<p>Обозначим через <img class=tex src="../tex2png/cache/7cb3f68c9d190e11a47d1562105e1f09.png" alt="s_1, \ldots, s_k"> размеры компонент связности этого графа. Поскольку добавлять рёбра внутри компонент связности запрещено, то получается, что задача очень похожа на поиск количества остовных деревьев в полном графе из <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> вершин: но отличие здесь в том, что каждая вершина имеет свой "вес" <img class=tex src="../tex2png/cache/0178ba7bc134eaf6ff236cdbaaed5bfd.png" alt="s_i">: каждое ребро, смежное с <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой вершиной, умножает ответ на <img class=tex src="../tex2png/cache/0178ba7bc134eaf6ff236cdbaaed5bfd.png" alt="s_i">.<p>Таким образом, для подсчёта количества способов оказывается важным, какие степени имеют все <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> вершин в остове. Для получения формулы для задачи надо просуммировать ответы по всем возможным степеням.<p>Пусть <img class=tex src="../tex2png/cache/47851709f5d29672352f9c77c0f3dffc.png" alt="d_1, \ldots, d_k"> &mdash; степени вершин в остове. Сумма степеней вершин равна удвоенному количеству рёбер, поэтому:<p><p class=formula><img class=tex src="../tex2png/cache/0d8874bb59f41d5e46750f295b47e43c.png" alt=" \sum_{i=1}^k d_i = 2k-2. "></p><p>Если <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-я вершина имеет степень <img class=tex src="../tex2png/cache/21d1e5e0a98550967314625438cc5c3b.png" alt="d_i">, то в код Прюфера она входит <img class=tex src="../tex2png/cache/089fe23899843818039f47605cd07ed1.png" alt="d_i-1"> раз. Код Прюфера для дерева из <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> вершин имеет длину <img class=tex src="../tex2png/cache/cfa5b5f61682257ec38664e652d0e826.png" alt="k-2">. Количество способов выбрать набор <img class=tex src="../tex2png/cache/cfa5b5f61682257ec38664e652d0e826.png" alt="k-2"> чисел, где число <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> встречается ровно <img class=tex src="../tex2png/cache/089fe23899843818039f47605cd07ed1.png" alt="d_i-1"> раз, равно <b>мультиномиальному коэффициенту</b> (по аналогии с <a href="binomial_coeff.html">биномиальным коэффициентом</a>):<p><p class=formula><img class=tex src="../tex2png/cache/74b7d171ce81b9334527bd3646c7b000.png" alt=" \binom{ k-2 }{ d_1-1, ~ d_2-1, ~ \ldots ~ , d_k-1[...]"></p><p>С учётом того, что каждое ребро, смежное с <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой вершиной, умножает ответ на <img class=tex src="../tex2png/cache/0178ba7bc134eaf6ff236cdbaaed5bfd.png" alt="s_i">, получаем, что ответ, при условии, что степени вершин равны <img class=tex src="../tex2png/cache/47851709f5d29672352f9c77c0f3dffc.png" alt="d_1, \ldots, d_k">, равен:<p><p class=formula><img class=tex src="../tex2png/cache/619f6109330144930c5c289c32f5b1bc.png" alt=" s_1^{d_1} \cdot s_2^{d_2} \cdot \ldots \cdot s_k^[...]"></p><p>Для получения ответа на задачу надо просуммировать эту формулу по всевозможным допустимым наборам <img class=tex src="../tex2png/cache/2f3965d628f7681ecb6299dcb5777fd3.png" alt="\{ d_i \}_{i=1}^{i=k}">:<p><p class=formula><img class=tex src="../tex2png/cache/77406647ab0fee014d0f95ed88c60d42.png" alt=" \sum_{ \substack{ d_i \ge 1, \\ \sum_{i=1}^k d_i [...]"></p><p>Для свёртывания этой формулы воспользуемся определением мультиномиального коэффициента:<p><p class=formula><img class=tex src="../tex2png/cache/3e49c85ae4b9a7804aabd621a9553876.png" alt=" (x_1 + \ldots x_m)^p = \sum_{ \substack{ c_i \ge [...]"></p><p>Сравнивая эту формулу с предыдущей, получаем, что если ввести обозначение <img class=tex src="../tex2png/cache/3f47f2fef4515a3f2bc8f8d65e802c2f.png" alt="e_i = d_i-1">:<p><p class=formula><img class=tex src="../tex2png/cache/978969a108a53c33c11d276e760be8a3.png" alt=" \sum_{ \substack{ e_i \ge 0, \\ \sum_{i=1}^k e_i [...]"></p><p>то после сворачивания <b>ответ на задачу</b> равен:<p><p class=formula><img class=tex src="../tex2png/cache/546ba63a268bd27f8b655b3629cc19e3.png" alt=" s_1 \cdot s_2 \cdot \ldots \cdot s_k \cdot (s_1 +[...]"></p><p>(Эта формула верна и при <img class=tex src="../tex2png/cache/c52bf046f58b7dd5434e50c9358055d3.png" alt="k=1">, хотя формально из доказательства это не следовало.)<p><p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Задачи в online judges, в которых применяются коды Прюфера:<p><ul><p><li><a href="http://acm.uva.es/p/v108/10843.html"> UVA #10843 <b>"Anne's game"</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая] </a><p><li><a href="http://acm.timus.ru/problem.aspx?space=1&num=1069"> TIMUS #1069 <b>"Код Прюфера"</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая] </a><p><li><a href="http://codeforces.ru/contest/156/problem/D"> CODEFORCES 110D <b>"Улики"</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя] </a><p><li><a href="http://community.topcoder.com/stat?c=problem_statement&pm=10774&rd=14146"> TopCoder SRM 460 <b>"TheCitiesAndRoadsDivTwo"</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя] </a><p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>