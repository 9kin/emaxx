<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Нахождение наидлиннейшей возрастающей подпоследовательности</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 11 Jun 2008 11:06<br>редактировано: 7 Nov 2011 15:45</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="longest_increasing_subseq_log.html#" id="contents-hide">[скрыть]</a><a href="longest_increasing_subseq_log.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Нахождение наидлиннейшей возрастающей подпоследовательности </h1><p><b>Условие задачи</b> следующее. Дан массив из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> чисел: <img class=tex src="../tex2png/cache/2f7c3ec9c849a4dcbfc3195989056b93.png" alt="a[0 \ldots n-1]">. Требуется найти в этой последовательности строго возрастающую подпоследовательность наибольшей длины.<p><b>Формально</b> это выглядит следующим образом: требуется найти такую последовательность индексов <img class=tex src="../tex2png/cache/31f62cd031ad6f41cf399a9ee54eea07.png" alt="i_1 \ldots i_k">, что:<p><p class=formula><img class=tex src="../tex2png/cache/282f36b7b9a99cac2a93bb569571eef8.png" alt=" i_1 < i_2 < \ldots < i_k, "><br><img class=tex src="../tex2png/cache/7ff4036782cb0246a7de44401083d2d1.png" alt=" a[i_1] < a[i_2] < \ldots < a[i_k]. "></p><p>В данной статье рассматриваются различные алгоритмы решения данной задачи, а также некоторые задачи, которые можно свести к данной задаче.<p><p><p><h2 style="padding-top:40px;"> Решение за <img class=tex src="../tex2png/cache/d7f83a4af3951f243cc25e2d3dcaa215.png" alt="O(n^2)">: метод динамического программирования </h2><p>Динамическое программирование &mdash; это весьма общая методика, позволяющая решать огромный класс задач. Здесь мы рассмотрим эту методику применительно к нашей конкретной задаче.<p>Научимся сначала искать <b>длину</b> наидлиннейшей возрастающей подпоследовательности, а восстановлением самой подпоследовательности займёмся чуть позже.<p><p><h3 style="padding-top:15px;"> Динамическое программирование для поиска длины ответа </h3><p>Для этого давайте научимся считать массив <img class=tex src="../tex2png/cache/38d695526225bef162865943225ab63c.png" alt="d[0 \ldots n-1]">, где <img class=tex src="../tex2png/cache/a1fc654329221233840e1ce43c252646.png" alt="d[i]"> &mdash; это длина наидлиннейшей возрастающей подпоследовательности, оканчивающейся именно в элементе с индексом <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">. Массив этот (он и есть &mdash; сама динамика) будем считать постепенно: сначала <img class=tex src="../tex2png/cache/fd83646c2f1ba5cbc34cd1e316e3283c.png" alt="d[0]">, затем <img class=tex src="../tex2png/cache/3a61ca030ea68c851a929352ca53337d.png" alt="d[1]"> и т.д. В конце, когда этот массив будет подсчитан нами, ответ на задачу будет равен максимуму в массиве <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]">.<p>Итак, пусть текущий индекс &mdash; <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, т.е. мы хотим посчитать значение <img class=tex src="../tex2png/cache/a1fc654329221233840e1ce43c252646.png" alt="d[i]">, а все предыдущие значения <img class=tex src="../tex2png/cache/dbe2c14cfb117a98c297881630fcb6a0.png" alt="d[0] 
\ldots d[i-1]"> уже подсчитаны. Тогда заметим, что у нас есть два варианта:<p><ul><p><li>либо <img class=tex src="../tex2png/cache/ea5fa657e7c3d1576d18227758447c9e.png" alt="d[i] = 1">, т.е. искомая подпоследовательность состоит только из числа <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]">.<p><li>либо <img class=tex src="../tex2png/cache/57eb1a8f8d29fb59c12ded852672e0ff.png" alt="d[i] > 1">. Тогда перед числом <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]"> в искомой подпоследовательности стоит какое-то другое число. Давайте переберём это число: это может быть любой элемент <img class=tex src="../tex2png/cache/f58a0bf6aff616b32e2407456e23e37a.png" alt="a[j]"> <img class=tex src="../tex2png/cache/fabd0cf792046d4b6de34d1a2597099d.png" alt="(j = 0 \ldots i-1)">, но такой, что <img class=tex src="../tex2png/cache/3143b74d70e01324142db6190e5c3c3e.png" alt="a[j] < a[i]">. Пусть мы рассматриваем какой-то текущий индекс <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">. Поскольку динамика <img class=tex src="../tex2png/cache/bb24f99736a597ad13552e3dbac37d06.png" alt="d[j]"> для него уже подсчитана, получается, что это число <img class=tex src="../tex2png/cache/f58a0bf6aff616b32e2407456e23e37a.png" alt="a[j]"> вместе с числом <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]"> даёт ответ <img class=tex src="../tex2png/cache/420694bedbab6cd10e0729e0209cb0f6.png" alt="d[j] + 1">. Таким образом, <img class=tex src="../tex2png/cache/a1fc654329221233840e1ce43c252646.png" alt="d[i]"> можно считать по такой формуле:<p><p class=formula><img class=tex src="../tex2png/cache/93a855a30cbce17bb88065b0e1bfd8ed.png" alt=" d[i] = \max_{j=0 \ldots i-1, \atop a[j] < a[i]} ([...]"></p><p></ul><p>Объединяя эти два варианта в один, получаем окончательный алгоритм для вычисления <img class=tex src="../tex2png/cache/a1fc654329221233840e1ce43c252646.png" alt="d[i]">:<p><p class=formula><img class=tex src="../tex2png/cache/522b0b0489b2b64bac9f7116779ad506.png" alt=" d[i] = \max \Big( 1, \max_{j=0 \ldots i-1, \atop [...]"></p><p>Этот алгоритм &mdash; и есть сама динамика.<p><p><h3 style="padding-top:15px;"> Реализация </h3><p>Приведём реализацию описанного выше алгоритма, которая находит и выводит длину наидлиннейшей возрастающей подпоследовательности:<p><pre class="notranslate cpp"><span class="kw4">int</span> d<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span> <span class="co1">// константа MAXN равна наибольшему возможному значению n</span>
&nbsp;
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	d<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>i<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>a<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">&lt;</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>
			d<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> max <span class="br0">&#40;</span>d<span class="br0">&#91;</span>i<span class="br0">&#93;</span>, <span class="nu0">1</span> <span class="sy2">+</span> d<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> ans <span class="sy1">=</span> d<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	ans <span class="sy1">=</span> max <span class="br0">&#40;</span>ans, d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> ans <span class="sy1">&lt;&lt;</span> endl<span class="sy4">;</span></pre><p><p><h3 style="padding-top:15px;"> Восстановление ответа </h3><p>Пока мы лишь научились искать длину ответа, но саму наидлиннейшую подпоследовательность мы вывести не можем, т.к. не сохраняем никакой дополнительной информации о том, где достигаются максимумы.<p>Чтобы суметь восстановить ответ, помимо динамики <img class=tex src="../tex2png/cache/38d695526225bef162865943225ab63c.png" alt="d[0 \ldots n-1]"> надо также хранить вспомогательный массив <img class=tex src="../tex2png/cache/9ff50b5f8fed0fbedd5d2edbbbd08679.png" alt="p[0 \ldots n-1]"> &mdash; то, в каком месте достигся максимум для каждого значения <img class=tex src="../tex2png/cache/a1fc654329221233840e1ce43c252646.png" alt="d[i]">. Иными словами, индекс <img class=tex src="../tex2png/cache/6fa33a48f7fff7f52d08a07ab012145a.png" alt="p[i]"> будет обозначать тот самый индекс <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">, при котором получилось наибольшее значение <img class=tex src="../tex2png/cache/a1fc654329221233840e1ce43c252646.png" alt="d[i]">. (Этот массив <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]"> в динамическом программировании часто называют "массивом предков".)<p>Тогда, чтобы вывести ответ, надо просто идти от элемента с максимальным значением <img class=tex src="../tex2png/cache/a1fc654329221233840e1ce43c252646.png" alt="d[i]"> по его предкам до тех пор, пока мы не выведем всю подпоследовательность, т.е. пока не дойдём до элемента со значением <img class=tex src="../tex2png/cache/d701b46582aba819383bbec2ba3fc6b7.png" alt="d = 1">.<p><p><h3 style="padding-top:15px;"> Реализация восстановления ответа </h3><p>Итак, у нас изменится и код самой динамики, и добавится код, производящий вывод наидлиннейшей подпоследовательности (выводятся индексы элементов подпоследовательности, в 0-индексации).<p>Для удобства мы изначально положили индексы <img class=tex src="../tex2png/cache/fee6e3e552d839535776088bf7c3033d.png" alt="p[i] = -1">: для элементов, у которых динамика получилась равной единице, это значение предка так и останется минус единицей, что чуть-чуть удобнее при восстановлении ответа.<p><pre class="notranslate cpp"><span class="kw4">int</span> d<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, p<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span> <span class="co1">// константа MAXN равна наибольшему возможному значению n</span>
&nbsp;
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	d<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	p<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>i<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>a<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">&lt;</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span><span class="nu0">1</span> <span class="sy2">+</span> d<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">&gt;</span> d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				d<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">1</span> <span class="sy2">+</span> d<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="sy4">;</span>
				p<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> j<span class="sy4">;</span>
			<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> ans <span class="sy1">=</span> d<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>,  pos <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&gt;</span> ans<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		ans <span class="sy1">=</span> d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		pos <span class="sy1">=</span> i<span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> ans <span class="sy1">&lt;&lt;</span> endl<span class="sy4">;</span>
&nbsp;
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> path<span class="sy4">;</span>
<span class="kw1">while</span> <span class="br0">&#40;</span>pos <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	path.<span class="me1">push_back</span> <span class="br0">&#40;</span>pos<span class="br0">&#41;</span><span class="sy4">;</span>
	pos <span class="sy1">=</span> p<span class="br0">&#91;</span>pos<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
reverse <span class="br0">&#40;</span>path.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, path.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>path.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> path<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&lt;&lt;</span> <span class="st0">' '</span><span class="sy4">;</span></pre><p><p><h3 style="padding-top:15px;"> Альтернативный способ восстановления ответа </h3><p>Впрочем, как почти всегда в случае динамического программирования, для восстановления ответа можно не хранить дополнительный массив предков <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]">, а просто заново пересчитывая текущий элемент динамики и ища, на каком же индексе был достигнут максимум.<p>Этот способ при реализации приводит к чуть более длинному коду, однако взамен получаем экономию памяти и абсолютное совпадение логики программы в процессе подсчёта динамики и в процессе восстановления.<p><p><p><h2 style="padding-top:40px;"> Решение за <img class=tex src="../tex2png/cache/a11776a13135ae4d7d1007f97b9b95c4.png" alt="O (n \log n)">: динамическое программирование с двоичным поиском </h2><p>Чтобы получить более быстрое решение задачи, построим другой вариант динамического программирования за <img class=tex src="../tex2png/cache/4cd2772b06262896a7cf8a9d3c989ea4.png" alt="O (n^2)">, а затем поймём, как можно этот вариант ускорить до <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">.<p><b>Динамика</b> теперь будет такой: пусть <img class=tex src="../tex2png/cache/a1fc654329221233840e1ce43c252646.png" alt="d[i]"> <img class=tex src="../tex2png/cache/e7b4a74ab5f8a3c3e8f392d8934329d4.png" alt="(i = 0 \ldots n)"> &mdash; это число, на которое оканчивается возрастающая подпоследовательность длины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> (а если таких чисел несколько &mdash; то наименьшее из них).<p>Изначально мы полагаем <img class=tex src="../tex2png/cache/2d9c6db08f9f8cead42096c4e96d2f73.png" alt="d[0] = -\infty">, а все остальные элементы <img class=tex src="../tex2png/cache/4b674d7388cee2848918260520b74dcc.png" alt="d[i] = \infty">.<p>Считать эту динамику мы будем постепенно, обработав число <img class=tex src="../tex2png/cache/0b15347ed7123f9c75a08d6f7a8e396e.png" alt="a[0]">, затем <img class=tex src="../tex2png/cache/f2b215a7eec3dbdf3e84512d66d1b4fd.png" alt="a[1]">, и т.д.<p>Приведём реализацию этой динамики за <img class=tex src="../tex2png/cache/4cd2772b06262896a7cf8a9d3c989ea4.png" alt="O (n^2)">:<p><pre class="notranslate cpp"><span class="kw4">int</span> d<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
d<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy1">=</span> <span class="sy2">-</span>INF<span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;=</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	d<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> INF<span class="sy4">;</span>
&nbsp;
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">++</span><span class="br0">&#41;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> j<span class="sy1">&lt;=</span>n<span class="sy4">;</span> j<span class="sy2">++</span><span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>j<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy1">&lt;</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy3">&amp;&amp;</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&lt;</span> d<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span>
			d<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span></pre><p>Заметим теперь, что у этой динамики есть одно <b>очень важное свойство</b>: <img class=tex src="../tex2png/cache/23c946055cfea078e9123948b46877cd.png" alt="d[i-1] \le d[i]"> для всех <img class=tex src="../tex2png/cache/1cf0d52047c38a1a3bbeab42c2de96a3.png" alt="i = 1 \ldots n">. Другое свойство &mdash; что каждый элемент <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]"> обновляет максимум одну ячейку <img class=tex src="../tex2png/cache/bb24f99736a597ad13552e3dbac37d06.png" alt="d[j]">.<p>Таким образом, это означает, что обрабатывать очередное <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]"> мы можем за <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">, сделав двоичный поиск по массиву <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]">. В самом деле, мы просто ищем в массиве <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]"> первое число, которое строго больше <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]">, и пытаемся произвести обновление этого элемента аналогично приведённой выше реализации.<p><p><h3 style="padding-top:15px;"> Реализация за <img class=tex src="../tex2png/cache/a11776a13135ae4d7d1007f97b9b95c4.png" alt="O (n \log n)"> </h3><p>Воспользовавшись стандартным в языке C++ алгоритмом двоичного поиска <img class=tex src="../tex2png/cache/9626e902e5b509129f1b52a83bbfdc8a.png" alt="upper\_bound"> (который возвращает позицию первого элемента, строго большего данного), получаем такую простую реализацию:<p><pre class="notranslate cpp"><span class="kw4">int</span> d<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
d<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy1">=</span> <span class="sy2">-</span>INF<span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;=</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	d<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> INF<span class="sy4">;</span>
&nbsp;
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">++</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> j <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>upper_bound <span class="br0">&#40;</span>d.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, d.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="sy2">-</span> d.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>j<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy1">&lt;</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy3">&amp;&amp;</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&lt;</span> d<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span>
		d<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h3 style="padding-top:15px;"> Восстановление ответа </h3><p>По такой динамике тоже можно восстановить ответ, для чего опять же помимо динамики <img class=tex src="../tex2png/cache/a1fc654329221233840e1ce43c252646.png" alt="d[i]"> также надо хранить массив "предков" <img class=tex src="../tex2png/cache/6fa33a48f7fff7f52d08a07ab012145a.png" alt="p[i]"> &mdash; то, на элементе с каким индексом оканчивается оптимальная подпоследовательность длины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">. Кроме того, для каждого элемента массива <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]"> надо будет хранить его "предка" &mdash; т.е. индекс того элемента, который должен стоять перед <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]"> в оптимальной подпоследовательности.<p>Поддерживая эти два массива по ходу вычисления динамики, в конце будет нетрудно восстановить искомую подпоследовательность.<p>(Интересно отметить, что применительно к данной динамике ответ можно восстанавливать только так, через массивы предков &mdash; а без них восстановить ответ после вычисления динамики будет невозможно. Это один из редких случаев, когда к динамике неприменим альтернативный способ восстановления &mdash; без массивов предков).<p><p><p><h2 style="padding-top:40px;"> Решение за <img class=tex src="../tex2png/cache/a11776a13135ae4d7d1007f97b9b95c4.png" alt="O (n \log n)">: структуры данных </h2><p>Если приведённый выше способ за <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)"> весьма красив, однако не совсем тривиален идейно, то есть и другой путь: воспользоваться одной из известных простых структур данных.<p>В самом деле, давайте вернёмся к самой первой динамике, где состоянием являлась просто текущая позиция. Текущее значение динамики <img class=tex src="../tex2png/cache/a1fc654329221233840e1ce43c252646.png" alt="d[i]"> вычисляется как максимум значений <img class=tex src="../tex2png/cache/a1fc654329221233840e1ce43c252646.png" alt="d[i]"> среди всех таких элементов <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">, что <img class=tex src="../tex2png/cache/3143b74d70e01324142db6190e5c3c3e.png" alt="a[j] < a[i]">.<p>Следовательно, если мы через <img class=tex src="../tex2png/cache/ef81dd9a1c266209451a0f924cf42f69.png" alt="t[]"> обозначим такой <b>массив</b>, в который будем записывать значения динамики от чисел:<p><p class=formula><img class=tex src="../tex2png/cache/50c4b6bf2d3b3d9bae325bacb48c909f.png" alt=" t[a[i]] = d[i], "></p><p>то получается, что всё, что нам надо уметь &mdash; это искать <b>максимум на префиксе</b> массива <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">: <img class=tex src="../tex2png/cache/d87e4aefc873f590782cd45cc36ea156.png" alt="t[0 \ldots a[i]-1]">.<p>Задача поиска максимума на префиксах массива (с учётом того, что массив может меняться) решается многими стандартными структурами данных, например, <a href="segment_tree.html">деревом отрезков</a> или <a href="fenwick_tree.html">деревом Фенвика</a>.<p>Воспользовавшись любой такой структурой данных, мы получим решение за <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">.<p>У этого способа решения есть явные <b>недостатки</b>: по длине и сложности реализации этот путь будет в любом случае хуже, чем описанная выше динамика за <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">. Кроме того, если входные числа <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]"> могут быть достаточно большими, то скорее всего их придётся сжимать (т.е. перенумеровывать от <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0"> до <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">) &mdash; без этого многие стандартные структуры данных работать не смогут из-за высокого потребления памяти.<p>С другой стороны, у данного пути есть и <b>преимущества</b>. Во-первых, при таком способе решения не придётся задумываться о хитрой динамике. Во-вторых, этот способ позволяет решать некоторые обобщения нашей задачи (о них см. ниже).<p><p><p><h2 style="padding-top:40px;"> Смежные задачи </h2><p>Приведём здесь несколько задач, тесно связанных с задачей поиска наидлиннейшей возрастающей подпоследовательности.<p><p><h3 style="padding-top:15px;"> Наидлиннейшая неубывающая подпоследовательность </h3><p>Фактически, это та же самая задача, только теперь в искомой подпоследовательности допускаются одинаковые числа (т.е. мы должны найти нестрого возрастающую подпоследовательность).<p>Решение этой задачи по сути ничем не отличается от нашей исходной задачи, просто при сравнениях изменятся знаки неравенств, а также надо будет немного изменить двоичный поиск.<p><p><h3 style="padding-top:15px;"> Количество наидлиннейших возрастающих подпоследовательностей </h3><p>Для решения этой задачи можно использовать самую первую динамику за <img class=tex src="../tex2png/cache/4cd2772b06262896a7cf8a9d3c989ea4.png" alt="O (n^2)"> либо подход с помощью структур данных для решения за <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">. И в том, и в том случае все изменения заключаются только в том, что помимо значения динамики <img class=tex src="../tex2png/cache/a1fc654329221233840e1ce43c252646.png" alt="d[i]"> надо также хранить, сколькими способами это значение могло быть получено.<p>По всей видимости, способ решения через динамику за <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)"> к данной задаче применить невозможно.<p><p><h3 style="padding-top:15px;"> Наименьшее число невозрастающих подпоследовательностей, покрывающих данную последовательность </h3><p><b>Условие</b> таково. Дан массив из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> чисел <img class=tex src="../tex2png/cache/2f7c3ec9c849a4dcbfc3195989056b93.png" alt="a[0 \ldots n-1]">. Требуется раскрасить его числа в наименьшее число цветов так, чтобы по каждому цвету получалась бы невозрастающая подпоследовательность.<p><b>Решение</b>. Утверждается, что минимальное количество необходимых цветов равно длине наидлиннейшей возрастающей подпоследовательности.<p><b>Доказательство</b>. Фактически, нам надо доказать <b>двойственность</b> этой задачи и задачи поиска наидлиннейшей возрастающей подпоследовательности.<p>Обозначим через <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> длину наидлиннейшей возрастающей подпоследовательности, а через <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> &mdash; искомое наименьшее число невозрастающих подпоследовательностей. Нам надо доказать, что <img class=tex src="../tex2png/cache/010ab3eb5524c06a443e6ce642131ccf.png" alt="x=y">.<p>С одной стороны, понятно, почему не может быть <img class=tex src="../tex2png/cache/8dc8a505b5b1eeff4e63eb1f67a82fc5.png" alt="y<x">: ведь если у нас есть <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> строго возрастающих элементов, то никакие два из них не могли попасть в одну невозрастающую подпоследовательность, а, значит, <img class=tex src="../tex2png/cache/dd276b8c54b69bc1bcaeab83e0a5b17c.png" alt="y \ge x">.<p>Покажем теперь, что, наоборот, <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> не может быть <img class=tex src="../tex2png/cache/b99e7e921dccccd792d7cc58cb4eaf0b.png" alt="> x">. Докажем это от противного: предположим, что <img class=tex src="../tex2png/cache/ef40992b2d3bfdad5bb6525da831097a.png" alt="y > x">. Тогда рассмотрим любой оптимальный набор из <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> невозрастающих подпоследовательностей. Преобразуем этот набор таким образом: пока есть две таких подпоследовательности, что первая начинается раньше второй, но при этом первая начинается с числа, больше либо равного чем начало второй &mdash; отцепим это стартовое число от первой подпоследовательности и прицепим в начало второй. Таким образом, через какое-то конечное число шагов у нас останется <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> подпоследовательностей, причём их стартовые числа будут образовывать возрастающую подпоследовательность длины <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">. Но <img class=tex src="../tex2png/cache/ef40992b2d3bfdad5bb6525da831097a.png" alt="y > x">, т.е. мы пришли к противоречию (ведь не может быть возрастающих подпоследовательностей длиннее <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">).<p>Таким образом, в самом деле, <img class=tex src="../tex2png/cache/3aa1d180d53212879b833aadb95b5f19.png" alt="y = x">, что и требовалось доказать.<p><b>Восстановление ответа</b>. Утверждается, что само искомое разбиение на подпоследовательности можно искать жадно, т.е. идя слева направо и относя текущее число в ту подпоследовательность, которая сейчас заканчивается на минимальное число, больше либо равное текущему.<p><p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Список задач, которые можно решить по данной тематике:<p><ul><p><li><a href="http://informatics.mccme.ru/moodle/mod/statements/view3.php?chapterid=1793">MCCME #1793 <b>"Наибольшая возрастающая подпоследовательность за O(n*log(n))"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><p><li><a href="http://community.topcoder.com/stat?c=problem_statement&pm=5922&rd=8075">TopCoder SRM 278 <b>"500 IntegerSequence"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><p><li><a href="http://community.topcoder.com/stat?c=problem_statement&pm=3937&rd=6532">TopCoder SRM 233 <b>"DIV2 1000 AutoMarket"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><p><li><a href="http://codeforces.ru/contest/76/problem/F">Всеукраинская олимпиада школьников по информатике &mdash; задача F <b>"Турист"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p><li><a href="http://codeforces.ru/problemset/problem/10/D">Codeforces Beta Round #10 &mdash; задача D <b>"НОВП"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p><li><a href="http://acm.tju.edu.cn/toj/showp2707.html">ACM.TJU.EDU.CN 2707 <b>"Greatest Common Increasing Subsequence"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p><li><a href="http://www.spoj.pl/problems/SUPPER/">SPOJ #57 <b>"SUPPER. Supernumbers in a permutation"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p><li><a href="http://acm.sgu.ru/problem.php?contest=0&problem=521">ACM.SGU.RU #521 <b>"North-East"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: высокая]</a><p><li><a href="http://community.topcoder.com/stat?c=problem_statement&pm=2967&rd=5881">TopCoder Open 2004 &mdash; Round 4 &mdash; <b>"1000. BridgeArrangement"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: высокая]</a><p></ul><p><p><p><p><p><p><p><p><p><p><p><p><p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>