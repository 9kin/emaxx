<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Нахождение пары ближайших точек алгоритмом разделяй-и-властвуй</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2009 21:03<br>редактировано: 28 Oct 2015 22:35</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="nearest_points.html#" id="contents-hide">[скрыть]</a><a href="nearest_points.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Нахождение пары ближайших точек </h1><p><p><h2 style="padding-top:40px;"> Постановка задачи </h2><p>Даны <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> точек <img class=tex src="../tex2png/cache/b98bee3099688d9f0572adb2ffa3ff68.png" alt="p_i"> на плоскости, заданные своими координатами <img class=tex src="../tex2png/cache/a5be10853e90ed2cd02bc9bf3215a165.png" alt="(x_i,y_i)">. Требуется найти среди них такие две точки, расстояние между которыми минимально:<p><p class=formula><img class=tex src="../tex2png/cache/08de4c7004c91e3b8d483ef12bd37e6e.png" alt=" \min_{\scriptstyle i,j=0 \ldots n-1, \atop \scrip[...]"></p><p>Расстояния мы берём обычные евклидовы:<p><p class=formula><img class=tex src="../tex2png/cache/ea7e93c48e6cbe5a7993d384eae9e82b.png" alt=" \rho(p_i,p_j) = \sqrt{ (x_i-x_j)^2 + (y_i-y_j)^2 [...]"></p><p>Тривиальный алгоритм &mdash; перебор всех пар и вычисление расстояния для каждой &mdash; работает за <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)">. Ниже описывается алгоритм, работающий за время <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">. Этот алгоритм был предложен Препаратой (Preparata) в 1975 г. Препарата и Шамос также показали, что в модели дерева решений этот алгоритм асимптотически оптимален.<p><p><h2 style="padding-top:40px;"> Алгоритм </h2><p>Построим алгоритм по общей схеме алгоритмов <b>"разделяй-и-властвуй"</b>: алгоритм оформляем в виде рекурсивной функции, которой передаётся множество точек; эта рекурсивная функция разбивает это множество пополам, вызывает себя рекурсивно от каждой половины, а затем выполняет какие-то операции по объединению ответов. Операция объединения заключается в обнаружении случаев, когда одна точка оптимального решения попала в одну половину, а другая точка &mdash; в другую (в этом случае рекурсивные вызовы от каждой из половинок отдельно обнаружить эту пару, конечно, не смогут). Основная сложность, как всегда, заключается в эффективной реализации этой стадии объединения. Если рекурсивной функции передаётся множество из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> точек, то стадия объединения должна работать не более, чем <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">, тогда асимптотика всего алгоритма <img class=tex src="../tex2png/cache/d6fc6b4d622783678ffe9beb4007b66d.png" alt="T(n)"> будет находиться из уравнения:<p><p class=formula><img class=tex src="../tex2png/cache/24a99d6ec9ec1a3208d7e9d962bc9c6d.png" alt=" T(n) = 2 T(n/2) + O(n). "></p><p>Решением этого уравнения, как известно, является <img class=tex src="../tex2png/cache/f006d4fbd8182d779e14903e28676f6b.png" alt="T(n) = O (n \log n)">.<p>Итак, перейдём к построению алгоритма. Чтобы в будущем прийти к эффективной реализации стадии объединения, разбивать множество точек на два будем согласно их <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">-координатам: фактически мы проводим некоторую вертикальную прямую, разбивающую множество точек на два подмножества примерно одинаковых размеров. Такое разбиение удобно произвести следующим образом: отсортируем точки стандартно как пары чисел, т.е.:<p><p class=formula><img class=tex src="../tex2png/cache/c804948b904b0d716c2225188dda1337.png" alt=" p_i < p_j \Longleftrightarrow (x_i < x_j) \lor \B[...]"></p><p>Тогда возьмём среднюю после сортировки точку <img class=tex src="../tex2png/cache/58443a69e4f8742d31b67dd836111e52.png" alt="p_m"> (<img class=tex src="../tex2png/cache/3846761acac40be2f8b20af5b55f5df4.png" alt="m = \lfloor n/2 \rfloor">), и все точки до неё и саму <img class=tex src="../tex2png/cache/58443a69e4f8742d31b67dd836111e52.png" alt="p_m"> отнесём к первой половине, а все точки после неё &mdash; ко второй половине:<p><p class=formula><img class=tex src="../tex2png/cache/f2846bca606019edb014ad981738f043.png" alt=" A_1 = \{ p_i\ |\ i = 0 \ldots m \}, "><br><img class=tex src="../tex2png/cache/f0ee97c1667a96c0cabfe1a3840e1bd8.png" alt=" A_2 = \{ p_i\ |\ i = m+1 \ldots n-1 \}. "></p><p>Теперь, вызвавшись рекурсивно от каждого из множеств <img class=tex src="../tex2png/cache/cbf522547b41e347e97ce35c1ff8868b.png" alt="A_1"> и <img class=tex src="../tex2png/cache/243106e8ae0554329d50ec81b7987f6c.png" alt="A_2">, мы найдём ответы <img class=tex src="../tex2png/cache/c09c711ab28ad6a89c2a51737dbcc468.png" alt="h_1"> и <img class=tex src="../tex2png/cache/ef00299d4c8846c1b5e3cd36e52d8938.png" alt="h_2"> для каждой из половинок. Возьмём лучший из них: <img class=tex src="../tex2png/cache/5320bf3f7b3dc1944a359c94b910c3a8.png" alt="h = \min (h_1, h_2)">.<p>Теперь нам надо произвести <b>стадию объединения</b>, т.е. попытаться обнаружить такие пары точек, расстояние между которыми меньше <img class=tex src="../tex2png/cache/0f2a144dc82bc6974b98d1a4d3972640.png" alt="h">, причём одна точка лежит в <img class=tex src="../tex2png/cache/cbf522547b41e347e97ce35c1ff8868b.png" alt="A_1">, а другая &mdash; в <img class=tex src="../tex2png/cache/243106e8ae0554329d50ec81b7987f6c.png" alt="A_2">. Очевидно, что для этого достаточно рассматривать только те точки, которые отстоят от вертикальной прямой раздела на расстояние, меньшее <img class=tex src="../tex2png/cache/0f2a144dc82bc6974b98d1a4d3972640.png" alt="h">, т.е. множество <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B"> рассматриваемых на этой стадии точек равно:<p><p class=formula><img class=tex src="../tex2png/cache/f90532905c52ec22a68c1b4d176fd6f3.png" alt=" B = \{ p_i\ |\ | x_i - x_m | < h \}. "></p><p>Для каждой точки из множества <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B"> надо попытаться найти точки, находящиеся к ней ближе, чем <img class=tex src="../tex2png/cache/0f2a144dc82bc6974b98d1a4d3972640.png" alt="h">. Например, достаточно рассматривать только те точки, координата <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> которых отличается не более чем на <img class=tex src="../tex2png/cache/0f2a144dc82bc6974b98d1a4d3972640.png" alt="h">. Более того, не имеет смысла рассматривать те точки, у которых <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">-координата больше <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">-координаты текущей точки. Таким образом, для каждой точки <img class=tex src="../tex2png/cache/b98bee3099688d9f0572adb2ffa3ff68.png" alt="p_i"> определим множество рассматриваемых точек <img class=tex src="../tex2png/cache/ee308a4f9c190d3a419ca024a423c705.png" alt="C(p_i)"> следующим образом:<p><p class=formula><img class=tex src="../tex2png/cache/c67fae960344e8b81fa0165b014377c7.png" alt=" C(p_i) = \{ p_j\ |\ p_j \in B,\ \ y_i - h < y_j \[...]"></p><p>Если мы отсортируем точки множества <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B"> по <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">-координате, то находить <img class=tex src="../tex2png/cache/ee308a4f9c190d3a419ca024a423c705.png" alt="C(p_i)"> будет очень легко: это несколько точек подряд до точки <img class=tex src="../tex2png/cache/b98bee3099688d9f0572adb2ffa3ff68.png" alt="p_i">.<p>Итак, в новых обозначениях <b>стадия объединения</b> выглядит следующим образом: построить множество <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B">, отсортировать в нём точки по <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">-координате, затем для каждой точки <img class=tex src="../tex2png/cache/14d11cf8b6898f8f672fb96bc2de7426.png" alt="p_i \in B"> рассмотреть все точки <img class=tex src="../tex2png/cache/465ca6b92f334c85dd591bd68bae974d.png" alt="p_j \in C(p_i)">, и каждой пары <img class=tex src="../tex2png/cache/3367be54f18b5715bf8bd92c95d8882f.png" alt="(p_i,p_j)"> посчитать расстояние и сравнить с текущим наилучшим расстоянием.<p>На первый взгляд, это по-прежнему неоптимальный алгоритм: кажется, что размеры множеств <img class=tex src="../tex2png/cache/ee308a4f9c190d3a419ca024a423c705.png" alt="C(p_i)"> будут порядка <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, и требуемая асимптотика никак не получится. Однако, как это ни удивительно, можно доказать, что размер каждого из множеств <img class=tex src="../tex2png/cache/ee308a4f9c190d3a419ca024a423c705.png" alt="C(p_i)"> есть величина <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)">, т.е. не превосходит некоторой малой константы вне зависимости от самих точек. Доказательство этого факта приведено в следующем разделе.<p>Наконец, обратим внимание на сортировки, которых вышеописанный алгоритм содержит сразу две: сначала сортировка по парам (<img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">,<img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">), а затем сортировка элементов множества <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B"> по <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">. На самом деле, от обеих этих сортировок внутри рекурсивной функции можно избавиться (иначе бы мы не достигли оценки <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> для стадии объединения, и общая асимптотика алгоритма получилась бы <img class=tex src="../tex2png/cache/c230b655c4512e68886f06f776c0f949.png" alt="O(n \log^2 n)">). От первой сортировки избавиться легко &mdash; достаточно предварительно, до запуска рекурсии, выполнить эту сортировку: ведь внутри рекурсии сами элементы не меняются, поэтому нет никакой необходимости выполнять сортировку заново. Со второй сортировкой чуть сложнее, выполнить её предварительно не получится. Зато, вспомнив <b>сортировку слиянием</b> (merge sort), которая тоже работает по принципу разделяй-и-властвуй, можно просто встроить эту сортировку в нашу рекурсию. Пусть рекурсия, принимая какое-то множество точек (как мы помним, упорядоченное по парам <img class=tex src="../tex2png/cache/bceeeeebd9fec9d8ed4cd44b0d1a5b83.png" alt="(x,y)">) возвращает это же множество, но отсортированное уже по координате <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">. Для этого достаточно просто выполнить слияние (за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">) двух результатов, возвращённых рекурсивными вызовами. Тем самым получится отсортированное по <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> множество.<p><p><h2 style="padding-top:40px;"> Оценка асимптотики </h2><p>Чтобы показать, что вышеописанный алгоритм действительно выполняется за <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">, нам осталось доказать следующий факт: <img class=tex src="../tex2png/cache/e8209304f033e3a32e68d3db2a747147.png" alt="|C(p_i)| = O(1)">.<p>Итак, пусть мы рассматриваем какую-то точку <img class=tex src="../tex2png/cache/b98bee3099688d9f0572adb2ffa3ff68.png" alt="p_i">; напомним, что множество <img class=tex src="../tex2png/cache/ee308a4f9c190d3a419ca024a423c705.png" alt="C(p_i)"> &mdash; это множество точек, <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">-координата которых лежит в отрезке <img class=tex src="../tex2png/cache/e15fcbfd29047c6a057500f5a4726595.png" alt="[y_i-h; y_i]">, а, кроме того, по координате <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> и сама точка <img class=tex src="../tex2png/cache/b98bee3099688d9f0572adb2ffa3ff68.png" alt="p_i">, и все точки множества <img class=tex src="../tex2png/cache/ee308a4f9c190d3a419ca024a423c705.png" alt="C(p_i)"> лежат в полосе шириной <img class=tex src="../tex2png/cache/4534f0a08a5cf66815229b4b3c49d26c.png" alt="2h">. Иными словами, рассматриваемые нами точки <img class=tex src="../tex2png/cache/b98bee3099688d9f0572adb2ffa3ff68.png" alt="p_i"> и <img class=tex src="../tex2png/cache/ee308a4f9c190d3a419ca024a423c705.png" alt="C(p_i)"> лежат в прямоугольнике размера <img class=tex src="../tex2png/cache/14ad7aa68370d855556c29d2c00b1d64.png" alt="2h \times h">.<p>Наша задача &mdash; оценить максимальное количество точек, которое может лежать в этом прямоугольнике <img class=tex src="../tex2png/cache/14ad7aa68370d855556c29d2c00b1d64.png" alt="2h \times h">; тем самым мы оценим и максимальный размер множества <img class=tex src="../tex2png/cache/ee308a4f9c190d3a419ca024a423c705.png" alt="C(p_i)">. При этом при оценке надо не забывать, что могут встречаться повторяющиеся точки.<p>Вспомним, что <img class=tex src="../tex2png/cache/0f2a144dc82bc6974b98d1a4d3972640.png" alt="h"> получалось как минимум из двух результатов рекурсивных вызовов &mdash; от множеств <img class=tex src="../tex2png/cache/cbf522547b41e347e97ce35c1ff8868b.png" alt="A_1"> и <img class=tex src="../tex2png/cache/243106e8ae0554329d50ec81b7987f6c.png" alt="A_2">, причём <img class=tex src="../tex2png/cache/cbf522547b41e347e97ce35c1ff8868b.png" alt="A_1"> содержит точки слева от линии раздела и частично на ней, <img class=tex src="../tex2png/cache/243106e8ae0554329d50ec81b7987f6c.png" alt="A_2"> &mdash; оставшиеся точки линии раздела и точки справа от неё. Для любой пары точек из <img class=tex src="../tex2png/cache/cbf522547b41e347e97ce35c1ff8868b.png" alt="A_1">, равно как и из <img class=tex src="../tex2png/cache/243106e8ae0554329d50ec81b7987f6c.png" alt="A_2">, расстояние не может оказаться меньше <img class=tex src="../tex2png/cache/0f2a144dc82bc6974b98d1a4d3972640.png" alt="h"> &mdash; иначе бы это означало некорректность работы рекурсивной функции.<p>Для оценки максимального количества точек в прямоугольнике <img class=tex src="../tex2png/cache/14ad7aa68370d855556c29d2c00b1d64.png" alt="2h \times h"> разобьём его на два квадрата <img class=tex src="../tex2png/cache/fc0835212cefeb94d804531b00608bdb.png" alt="h \times h">, к первому квадрату отнесём все точки <img class=tex src="../tex2png/cache/6ccc8de41b08ff0065d950c24c9485e9.png" alt="C(p_i) \cap A_1">, а ко второму &mdash; все остальные, т.е. <img class=tex src="../tex2png/cache/2a1571c302e34c56085c72716897afe2.png" alt="C(p_i) \cap A_2">. Из приведённых выше соображений следует, что в каждом из этих квадратов расстояние между любыми двумя точками не менее <img class=tex src="../tex2png/cache/0f2a144dc82bc6974b98d1a4d3972640.png" alt="h">.<p>Покажем, что в каждом квадрате <b>не более четырёх</b> точек. Например, это можно сделать следующим образом: разобьём квадрат на 4 подквадрата со сторонами <img class=tex src="../tex2png/cache/8242564f4c198c40b0fc21c1615001f6.png" alt="h/2">. Тогда в каждом из этих подквадратов не может быть больше одной точки (т.к. даже диагональ равна <img class=tex src="../tex2png/cache/02b9a2774e1dbd70c449c26c0ab99aa5.png" alt="h / \sqrt{2}">, что меньше <img class=tex src="../tex2png/cache/0f2a144dc82bc6974b98d1a4d3972640.png" alt="h">). Следовательно, во всём квадрате не может быть более 4 точек.<p>Итак, мы доказали, что в прямоугольнике <img class=tex src="../tex2png/cache/14ad7aa68370d855556c29d2c00b1d64.png" alt="2h \times h"> не может быть больше <img class=tex src="../tex2png/cache/826fde5de05c8443e95fc00e6d8bddee.png" alt="4 \cdot 2 = 8"> точек, а, следовательно, размер множества <img class=tex src="../tex2png/cache/ee308a4f9c190d3a419ca024a423c705.png" alt="C(p_i)"> не может превосходить <img class=tex src="../tex2png/cache/5c705587512261d7061e23ba54f595f3.png" alt="7">, что и требовалось доказать.<p><p><h2 style="padding-top:40px;"> Реализация </h2><p>Введём структуру данных для хранения точки (её координаты и некий номер) и операторы сравнения, необходимые для двух видов сортировки:<p><pre class="notranslate cpp"><span class="kw4">struct</span> pt <span class="br0">&#123;</span>
	<span class="kw4">int</span> x, y, id<span class="sy4">;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
&nbsp;
<span class="kw2">inline</span> <span class="kw4">bool</span> cmp_x <span class="br0">&#40;</span><span class="kw4">const</span> pt <span class="sy3">&amp;</span> a, <span class="kw4">const</span> pt <span class="sy3">&amp;</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">return</span> a.<span class="me1">x</span> <span class="sy1">&lt;</span> b.<span class="me1">x</span> <span class="sy3">||</span> a.<span class="me1">x</span> <span class="sy1">==</span> b.<span class="me1">x</span> <span class="sy3">&amp;&amp;</span> a.<span class="me1">y</span> <span class="sy1">&lt;</span> b.<span class="me1">y</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">inline</span> <span class="kw4">bool</span> cmp_y <span class="br0">&#40;</span><span class="kw4">const</span> pt <span class="sy3">&amp;</span> a, <span class="kw4">const</span> pt <span class="sy3">&amp;</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">return</span> a.<span class="me1">y</span> <span class="sy1">&lt;</span> b.<span class="me1">y</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
pt a<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span></pre><p>Для удобной реализации рекурсии введём вспомогательную функцию <img class=tex src="../tex2png/cache/159827ca5721717ceb58a58b879da72d.png" alt="upd\_ans()">, которая будет вычислять расстояние между двумя точками и проверять, не лучше ли это текущего ответа:<p><pre class="notranslate cpp"><span class="kw4">double</span> mindist<span class="sy4">;</span>
<span class="kw4">int</span> ansa, ansb<span class="sy4">;</span>
&nbsp;
<span class="kw2">inline</span> <span class="kw4">void</span> upd_ans <span class="br0">&#40;</span><span class="kw4">const</span> pt <span class="sy3">&amp;</span> a, <span class="kw4">const</span> pt <span class="sy3">&amp;</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">double</span> dist <span class="sy1">=</span> <span class="kw3">sqrt</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>a.<span class="me1">x</span><span class="sy2">-</span>b.<span class="me1">x</span><span class="br0">&#41;</span><span class="sy2">*</span><span class="br0">&#40;</span>a.<span class="me1">x</span><span class="sy2">-</span>b.<span class="me1">x</span><span class="br0">&#41;</span> <span class="sy2">+</span> <span class="br0">&#40;</span>a.<span class="me1">y</span><span class="sy2">-</span>b.<span class="me1">y</span><span class="br0">&#41;</span><span class="sy2">*</span><span class="br0">&#40;</span>a.<span class="me1">y</span><span class="sy2">-</span>b.<span class="me1">y</span><span class="br0">&#41;</span> <span class="sy2">+</span> <span class="nu18">.0</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>dist <span class="sy1">&lt;</span> mindist<span class="br0">&#41;</span>
		mindist <span class="sy1">=</span> dist,  ansa <span class="sy1">=</span> a.<span class="me1">id</span>,  ansb <span class="sy1">=</span> b.<span class="me1">id</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Наконец, реализация самой рекурсии. Предполагается, что перед её вызовом массив <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]"> уже отсортирован по <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">-координате. Рекурсии передаётся просто два указателя <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l">, <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">, которые указывают, что она должна искать ответ для <img class=tex src="../tex2png/cache/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a[l \ldots r]">. Если расстояние между <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> и <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> слишком мало, то рекурсию надо остановить, и выполнить тривиальный алгоритм поиска ближайшей пары и затем отсортировать подмассив по <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">-координате.<p>Для слияния двух множеств точек, полученных от рекурсивных вызовов, в одно (упорядоченное по <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">-координате), мы используем стандартную функцию STL <img class=tex src="../tex2png/cache/39b5b91ed32f0c386ad4938063be9009.png" alt="merge()">, и создаём вспомогательный буфер <img class=tex src="../tex2png/cache/ef81dd9a1c266209451a0f924cf42f69.png" alt="t[]"> (один на все рекурсивные вызовы). (Использовать <img class=tex src="../tex2png/cache/15dd789ada01e996469645a96dbe6c9d.png" alt="inplace\_merge()"> нецелесообразно, т.к. она в общем случае работает не за линейное время).<p>Наконец, множество <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B"> хранится в том же массиве <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">.<p><pre class="notranslate cpp"><span class="kw4">void</span> rec <span class="br0">&#40;</span><span class="kw4">int</span> l, <span class="kw4">int</span> r<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>r <span class="sy2">-</span> l <span class="sy1">&lt;=</span> <span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>l<span class="sy4">;</span> i<span class="sy1">&lt;=</span>r<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span>i<span class="sy2">+</span><span class="nu0">1</span><span class="sy4">;</span> j<span class="sy1">&lt;=</span>r<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
				upd_ans <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span>, a<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		sort <span class="br0">&#40;</span>a<span class="sy2">+</span>l, a<span class="sy2">+</span>r<span class="sy2">+</span><span class="nu0">1</span>, <span class="sy3">&amp;</span>cmp_y<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">return</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw4">int</span> m <span class="sy1">=</span> <span class="br0">&#40;</span>l <span class="sy2">+</span> r<span class="br0">&#41;</span> <span class="sy1">&gt;&gt;</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw4">int</span> midx <span class="sy1">=</span> a<span class="br0">&#91;</span>m<span class="br0">&#93;</span>.<span class="me1">x</span><span class="sy4">;</span>
	rec <span class="br0">&#40;</span>l, m<span class="br0">&#41;</span>,  rec <span class="br0">&#40;</span>m<span class="sy2">+</span><span class="nu0">1</span>, r<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw4">static</span> pt t<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
	merge <span class="br0">&#40;</span>a<span class="sy2">+</span>l, a<span class="sy2">+</span>m<span class="sy2">+</span><span class="nu0">1</span>, a<span class="sy2">+</span>m<span class="sy2">+</span><span class="nu0">1</span>, a<span class="sy2">+</span>r<span class="sy2">+</span><span class="nu0">1</span>, t, <span class="sy3">&amp;</span>cmp_y<span class="br0">&#41;</span><span class="sy4">;</span>
	copy <span class="br0">&#40;</span>t, t<span class="sy2">+</span>r<span class="sy2">-</span>l<span class="sy2">+</span><span class="nu0">1</span>, a<span class="sy2">+</span>l<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw4">int</span> tsz <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>l<span class="sy4">;</span> i<span class="sy1">&lt;=</span>r<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw3">abs</span> <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">x</span> <span class="sy2">-</span> midx<span class="br0">&#41;</span> <span class="sy1">&lt;</span> mindist<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span>tsz<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> j<span class="sy1">&gt;=</span><span class="nu0">0</span> <span class="sy3">&amp;&amp;</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">y</span> <span class="sy2">-</span> t<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">y</span> <span class="sy1">&lt;</span> mindist<span class="sy4">;</span> <span class="sy2">--</span>j<span class="br0">&#41;</span>
				upd_ans <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span>, t<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
			t<span class="br0">&#91;</span>tsz<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Кстати говоря, если все координаты целые, то на время работы рекурсии можно вообще не переходить к дробным величинам, и хранить в <img class=tex src="../tex2png/cache/0a000f626a5c8ead0d1a57d68cbdbb4e.png" alt="mindist"> квадрат минимального расстояния.<p>В основной программе вызывать рекурсию следует так:<p><pre class="notranslate cpp">sort <span class="br0">&#40;</span>a, a<span class="sy2">+</span>n, <span class="sy3">&amp;</span>cmp_x<span class="br0">&#41;</span><span class="sy4">;</span>
mindist <span class="sy1">=</span> <span class="nu19">1E20</span><span class="sy4">;</span>
rec <span class="br0">&#40;</span><span class="nu0">0</span>, n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p><p><p><h2 style="padding-top:40px;"> Обобщение: поиск треугольника с минимальным периметром </h2><p>Описанный выше алгоритм интересно обобщается и на эту задачу: среди заданного множества точек выбрать три различных точки так, чтобы сумма попарных расстояний между ними была наименьшей.<p>По сути, для решения этой задачи алгоритм остаётся прежним: мы разделяем поле на две половинки вертикальной прямой, вызываем решение рекурсивно от обеих половинок, выбираем минимум <img class=tex src="../tex2png/cache/f2de2b37cf75267aaa7f72baa34fec51.png" alt="minper"> из найденных периметров, строим полоску толщиной <img class=tex src="../tex2png/cache/cd4a278776b03fd078ce3ca7010fe51b.png" alt="minper / 2">, и в ней перебираем все треугольники, способные улучшить ответ. (Отметим, что у треугольника с периметром <img class=tex src="../tex2png/cache/c193bf2539ede2f07c594243f3865e6a.png" alt="\le minper"> длиннейшая сторона <img class=tex src="../tex2png/cache/c0ace69b2dd3913b0a071f487a594922.png" alt="\le minper/2">.)<p><p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Список задач, которые сводятся к поиску двух ближайших точек:<p><ul><p><li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1186"> UVA 10245 <b>"The Closest Pair Problem"</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая] </a><p><li><a href="http://www.spoj.pl/problems/CLOPPAIR/"> SPOJ #8725 CLOPPAIR <b>"Closest Point Pair"</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая] </a><p><li><a href="http://codeforces.ru/contest/120/problem/J"> CODEFORCES Командная олимпиада школьников Саратова - 2011 <b>"Минимальная сумма"</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя] </a><p><li><a href="http://code.google.com/codejam/contest/311101/dashboard#s=a&a=1"> Google CodeJam 2009 Final <b>"Min Perimeter"</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя] </a><p><li><a href="https://www.spoj.pl/problems/CLOSEST/"> SPOJ #7029 CLOSEST <b>"Closest Triple"</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя] </a><p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>