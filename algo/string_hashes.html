<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Алгоритмы хэширования в задачах на строки</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 11 Jun 2008 10:39<br>редактировано: 4 Apr 2012 20:11</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="string_hashes.html#" id="contents-hide">[скрыть]</a><a href="string_hashes.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Алгоритмы хэширования в задачах на строки</h1>

<p>Алгоритмы хэширования строк помогают решить очень много задач. Но у них есть большой недостаток: что чаще всего они не 100%-ны, поскольку есть множество строк, хэши которых совпадают. Другое дело, что в большинстве задач на это можно не обращать внимания, поскольку вероятность совпадения хэшей всё-таки очень мала.</p>

<p>&nbsp;</p>

<h2>Определение хэша и его вычисление</h2>
<p>Один из лучших способов определить хэш-функцию от строки S следующий:</p>
<pre>h(S)  =  S[0]  +  S[1] * P  +  S[2] * P^2  +  S[3] * P^3  +  ...  +  S[N] * P^N</pre>
<p>где P - некоторое число.</p>
<p>Разумно выбирать для P простое число, примерно равное количеству символов во входном алфавите. Например, если строки предполаются состоящими только из маленьких латинских букв, то хорошим выбором будет P = 31. Если буквы могут быть и заглавными, и маленькими, то, например, можно P = 53.</p>
<p>Во всех кусках кода в этой статье будет использоваться P = 31.</p>
<p>Само значение хэша желательно хранить в самом большом числовом типе - int64, он же long long. Очевидно, что при длине строки порядка 20 символов уже будет происходить переполнение значение. Ключевой момент - что мы не обращаем внимание на эти переполнения, как бы беря хэш по модулю 2^64.</p>
<p>Пример вычисления хэша, если допустимы только маленькие латинские буквы:</p>
<pre>const int p = 31;
long long hash = 0, p_pow = 1;
for (size_t i=0; i&lt;s.length(); ++i)
{
	// желательно отнимать 'a' от кода буквы
	// единицу прибавляем, чтобы у строки вида 'aaaaa' хэш был ненулевой
	hash += (s[i] - 'a' + 1) * p_pow;
	p_pow *= p;
}</pre>
<p>В большинстве задач имеет смысл сначала вычислить все нужные степени P в каком-либо массиве.</p>

<p>&nbsp;</p>

<h2>Пример задачи. Поиск одинаковых строк</h2>
<p>Уже теперь мы в состоянии эффективно решить такую задачу. Дан список строк S[1..N], каждая длиной не более M символов. Допустим, требуется найти все повторяющиеся строки и разделить их на группы, чтобы в каждой группе были только одинаковые строки.</p>
<p>Обычной сортировкой строк мы бы получили алгоритм со сложностью O (N M log N), в то время как используя хэши, мы получим O (N M + N log N).</p>
<p>Алгоритм. Посчитаем хэш от каждой строки, и отсортируем строки по этому хэшу.</p>
<pre>vector&lt;string> s (n);
// ... считывание строк ...

// считаем все степени p, допустим, до 10000 - максимальной длины строк
const int p = 31;
vector&lt;long long> p_pow (10000);
p_pow[0] = 1;
for (size_t i=1; i&lt;p_pow.size(); ++i)
	p_pow[i] = p_pow[i-1] * p;

// считаем хэши от всех строк
// в массиве храним значение хэша и номер строки в массиве s
vector &lt; pair&lt;long long, int> > hashes (n);
for (int i=0; i&lt;n; ++i)
{
	long long hash = 0;
	for (size_t j=0; j&lt;s[i].length(); ++j)
		hash += (s[i][j] - 'a' + 1) * p_pow[j];
	hashes[i] = make_pair (hash, i);
}

// сортируем по хэшам
sort (hashes.begin(), hashes.end());

// выводим ответ
for (int i=0, group=0; i&lt;n; ++i)
{
	if (i == 0 || hashes[i].first != hashes[i-1].first)
		cout &lt;&lt; "\nGroup " &lt;&lt; ++group &lt;&lt; ":";
	cout &lt;&lt; ' ' &lt;&lt; hashes[i].second;
}</pre>

<p>&nbsp;</p>

<h2>Хэш подстроки и его быстрое вычисление</h2>
<p>Предположим, нам дана строка S, и даны индексы I и J. Требуется найти хэш от подстроки S[I..J].</p>
<p>По определению имеем:</p>
<pre>H[I..J]  =  S[I]  +  S[I+1] * P  +  S[I+2] * P^2  +  ...  + S[J] * P^(J-I)</pre>
<p>откуда:</p>
<pre>H[I..J] * P[I]  =  S[I] * P[I]  +  ...  +  S[J] * P[J],
H[I..J] * P[I]  =  H[0..J]  -  H[0..I-1]</pre>
<p>Полученное свойство является очень важным.</p>
<p>Действительно, получается, что, <b>зная только хэши от всех префиксов строки S, мы можем за O (1) получить хэш любой подстроки</b>.</p>
<p>Единственная возникающая проблема - это то, что нужно уметь делить на P[I]. На самом деле, это не так просто. Поскольку мы вычисляем хэш по модулю 2^64, то для деления на P[I] мы должны найти к нему обратный элемент в поле (например, с помощью <a href="extended_Euclid_algorithm.html">Расширенного алгоритма Евклида</a>), и выполнить умножение на этот обратный элемент.</p>
<p>Впрочем, есть и более простой путь. В большинстве случаев, <b>вместо того чтобы делить хэши на степени P, можно, наоборот, умножать их на эти степени</b>.</p>
<p>Допустим, даны два хэша: один умноженный на P[I], а другой - на P[J]. Если I &lt; J, то умножим перый хэш на P[J-I], иначе же умножим второй хэш на P[I-J]. Теперь мы привели хэши к одной степени, и можем их спокойно сравнивать.</p>
<p>Например, код, который вычисляет хэши всех префиксов, а затем за O (1) сравнивает две подстроки:</p>
<pre>string s;  int i1, i2, len; // входные данные

// считаем все степени p
const int p = 31;
vector&lt;long long> p_pow (s.length());
p_pow[0] = 1;
for (size_t i=1; i&lt;p_pow.size(); ++i)
	p_pow[i] = p_pow[i-1] * p;

// считаем хэши от всех префиксов
vector&lt;long long> h (s.length());
for (size_t i=0; i&lt;s.length(); ++i)
{
	h[i] = (s[i] - 'a' + 1) * p_pow[i];
	if (i)  h[i] += h[i-1];
}

// получаем хэши двух подстрок
long long h1 = h[i1+len-1];
if (i1)  h1 -= h[i1-1];
long long h2 = h[i2+len-1];
if (i2)  h2 -= h[i2-1];

// сравниваем их
if (i1 &lt; i2 && h1 * p_pow[i2-i1] == h2 ||
	i1 > i2 && h1 == h2 * p_pow[i1-i2])
	cout &lt;&lt; "equal";
else
	cout &lt;&lt; "different";</pre>

<h2>Применение хэширования</h2>
<p>Вот некоторые типичные применения хэширования:</p>
<ul>
<li><a href="rabin_karp.html">Алгоритм Рабина-Карпа поиска подстроки в строке за O (N)</a></li>
<li>Определение количества различных подстрок за O (N^2 log N) (см. ниже)</li>
<li>Определение количества палиндромов внутри строки</li>
</ul>

<h2>Определение количества различных подстрок</h2>

<p>Пусть дана строка S длиной N, состоящая только из маленьких латинских букв. Требуется найти количество различных подстрок в этой строке.</p>

<p>Для решения переберём по очереди длину подстроки: L = 1 .. N.</p>
<p>Для каждого L мы построим массив хэшей подстрок длины L, причём приведём хэши к одной степени, и отсортируем этот массив. Количество различных элементов в этом массиве прибавляем к ответу.</p>

<p>Реализация:</p>

<pre>string s; // входная строка
int n = (int) s.length();

// считаем все степени p
const int p = 31;
vector&lt;long long> p_pow (s.length());
p_pow[0] = 1;
for (size_t i=1; i&lt;p_pow.size(); ++i)
	p_pow[i] = p_pow[i-1] * p;

// считаем хэши от всех префиксов
vector&lt;long long> h (s.length());
for (size_t i=0; i&lt;s.length(); ++i)
{
	h[i] = (s[i] - 'a' + 1) * p_pow[i];
	if (i)  h[i] += h[i-1];
}

int result = 0;

// перебираем длину подстроки
for (int l=1; l&lt;=n; ++l)
{
	// ищем ответ для текущей длины

	// получаем хэши для всех подстрок длины l
	vector&lt;long long> hs (n-l+1);
	for (int i=0; i&lt;n-l+1; ++i)
	{
		long long cur_h = h[i+l-1];
		if (i)  cur_h -= h[i-1];
		// приводим все хэши к одной степени
		cur_h *= p_pow[n-i-1];
		hs[i] = cur_h;
	}

	// считаем количество различных хэшей
	sort (hs.begin(), hs.end());
	hs.erase (unique (hs.begin(), hs.end()), hs.end());
	result += (int) hs.size();
}

cout &lt;&lt; result;</pre>
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>