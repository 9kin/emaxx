<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Нахождение кратчайших путей от заданной вершины до всех остальных вершин алгоритмом Дейкстры</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 19:30<br>редактировано: 10 Dec 2012 16:05</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="dijkstra.html#" id="contents-hide">[скрыть]</a><a href="dijkstra.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Нахождение кратчайших путей от заданной вершины до всех остальных вершин алгоритмом Дейкстры</h1><p><h2 style="padding-top:40px;">Постановка задачи</h2><p>Дан ориентированный или неориентированный взвешенный граф с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами и <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> рёбрами. Веса всех рёбер неотрицательны. Указана некоторая стартовая вершина <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">. Требуется найти длины кратчайших путей из вершины <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> во все остальные вершины, а также предоставить способ вывода самих кратчайших путей.<p>Эта задача называется "задачей о кратчайших путях с единственным источником" (single-source shortest paths problem).<p><h2 style="padding-top:40px;">Алгоритм</h2><p>Здесь описывается алгоритм, который предложил голландский исследователь <b>Дейкстра</b> (Dijkstra) в 1959 г.<p>Заведём массив <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]">, в котором для каждой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> будем хранить текущую длину <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]"> кратчайшего пути из <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> в <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Изначально <img class=tex src="../tex2png/cache/3e34557900a0d42df24998b12b9d8b52.png" alt="d[s]=0">, а для всех остальных вершин эта длина равна бесконечности (при реализации на компьютере обычно в качестве бесконечности выбирают просто достаточно большое число, заведомо большее возможной длины пути):<p class=formula><img class=tex src="../tex2png/cache/944751abee6ed894a89fa9aa6ce0ed67.png" alt=" d[v] = \infty, v \ne s "></p><p>Кроме того, для каждой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> будем хранить, помечена она ещё или нет, т.е. заведём булевский массив <img class=tex src="../tex2png/cache/df09cae95940e511f8d96cbe8d9ad6b7.png" alt="u[]">. Изначально все вершины не помечены, т.е.<p class=formula><img class=tex src="../tex2png/cache/0ac9b02006125ddf3558744434335528.png" alt=" u[v] = {\rm false} "></p><p>Сам алгоритм Дейкстры состоит из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> <b>итераций</b>. На очередной итерации выбирается вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> с наименьшей величиной <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]"> среди ещё не помеченных, т.е.:<p class=formula><img class=tex src="../tex2png/cache/875a0ce73b8a902123fa26dcaf359061.png" alt=" d[v] = \min_{p:\ u[p]={\rm false}} d[p] "></p><p>(Понятно, что на первой итерации выбрана будет стартовая вершина <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">.)<p>Выбранная таким образом вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> отмечается помеченной. Далее, на текущей итерации, из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> производятся <b>релаксации</b>: просматриваются все рёбра <img class=tex src="../tex2png/cache/2f71535f4ca1feaf0a836a12914b1d88.png" alt="(v,to)">, исходящие из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, и для каждой такой вершины <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to"> алгоритм пытается улучшить значение <img class=tex src="../tex2png/cache/055ebcf2759a1e84a08f5a359acfc850.png" alt="d[to]">. Пусть длина текущего ребра равна <img class=tex src="../tex2png/cache/b7af92da3d97172288294dae18ab411b.png" alt="\rm len">, тогда в виде кода релаксация выглядит как:<p class=formula><img class=tex src="../tex2png/cache/f5b471a01079c54730b0e26dceed600e.png" alt=" d[to] = \min (d[to], d[v] + {\rm len}) "></p><p>На этом текущая итерация заканчивается, алгоритм переходит к следующей итерации (снова выбирается вершина с наименьшей величиной <img class=tex src="../tex2png/cache/30956e25578e9cb8f03bd9d36433020c.png" alt="d">, из неё производятся релаксации, и т.д.). При этом в конце концов, после <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> итераций, все вершины графа станут помеченными, и алгоритм свою работу завершает. Утверждается, что найденные значения <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]"> и есть искомые длины кратчайших путей из <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> в <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">.<p>Стоит заметить, что, если не все вершины графа достижимы из вершины <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, то значения <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]"> для них так и останутся бесконечными. Понятно, что несколько последних итераций алгоритма будут как раз выбирать эти вершины, но никакой полезной работы производить эти итерации не будут (поскольку бесконечное расстояние не сможет прорелаксировать другие, даже тоже бесконечные расстояния). Поэтому алгоритм можно сразу останавливать, как только в качестве выбранной вершины берётся вершина с бесконечным расстоянием.<p><b>Восстановление путей</b>. Разумеется, обычно нужно знать не только длины кратчайших путей, но и получить сами пути. Покажем, как сохранить информацию, достаточную для последующего восстановления кратчайшего пути из <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> до любой вершины. Для этого достаточно так называемого <b>массива предков</b>: массива <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]">, в котором для каждой вершины <img class=tex src="../tex2png/cache/40327048c210dda713e12955b3a896f9.png" alt="v \ne s"> хранится номер вершины <img class=tex src="../tex2png/cache/339e337cb1d15f640ac5fbb295a12782.png" alt="p[v]">, являющейся предпоследней в кратчайшем пути до вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Здесь используется тот факт, что если мы возьмём кратчайший путь до какой-то вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, а затем удалим из этого пути последнюю вершину, то получится путь, оканчивающийся некоторой вершиной <img class=tex src="../tex2png/cache/339e337cb1d15f640ac5fbb295a12782.png" alt="p[v]">, и этот путь будет кратчайшим для вершины <img class=tex src="../tex2png/cache/339e337cb1d15f640ac5fbb295a12782.png" alt="p[v]">. Итак, если мы будем обладать этим массивом предков, то кратчайший путь можно будет восстановить по нему, просто каждый раз беря предка от текущей вершины, пока мы не придём в стартовую вершину <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> &mdash; так мы получим искомый кратчайший путь, но записанный в обратном порядке. Итак, кратчайший путь <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> до вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> равен:<p class=formula><img class=tex src="../tex2png/cache/ea0c2408c4af263c394d58927e09631c.png" alt=" P = (s, \ldots, p[p[p[v]]], p[p[v]], p[v], v) "></p><p>Осталось понять, как строить этот массив предков. Однако это делается очень просто: при каждой успешной релаксации, т.е. когда из выбранной вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> происходит улучшение расстояния до некоторой вершины <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to">, мы записываем, что предком вершины <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to"> является вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">:<p class=formula><img class=tex src="../tex2png/cache/3342f9bdd235b411911cfcaa5db39cec.png" alt=" p[to] = v "></p><p><h2 style="padding-top:40px;">Доказательство</h2><p><b>Основное утверждение</b>, на котором основана корректность алгоритма Дейкстры, следующее. Утверждается, что после того как какая-либо вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> становится помеченной, текущее расстояние до неё <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]"> уже является кратчайшим, и, соответственно, больше меняться не будет.<p><b>Доказательство</b> будем производить по индукции. Для первой итерации справедливость его очевидна &mdash; для вершины <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> имеем <img class=tex src="../tex2png/cache/3e34557900a0d42df24998b12b9d8b52.png" alt="d[s]=0">, что и является длиной кратчайшего пути до неё. Пусть теперь это утверждение выполнено для всех предыдущих итераций, т.е. всех уже помеченных вершин; докажем, что оно не нарушается после выполнения текущей итерации. Пусть <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> &mdash; вершина, выбранная на текущей итерации, т.е. вершина, которую алгоритм собирается пометить. Докажем, что <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]"> действительно равно длине кратчайшего пути до неё (обозначим эту длину через <img class=tex src="../tex2png/cache/17ed5ef9cde8932fb5bdb3dd748fe4b1.png" alt="l[v]">).<p>Рассмотрим кратчайший путь <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> до вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Понятно, этот путь можно разбить на два пути: <img class=tex src="../tex2png/cache/3122f48f5edf548c3d6dc9ec4b8d33bc.png" alt="P_1">, состоящий только из помеченных вершин (как минимум стартовая вершина <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> будет в этом пути), и остальная часть пути <img class=tex src="../tex2png/cache/83ce9474dc01fcd3fabaf5370a97449d.png" alt="P_2"> (она тоже может включать помеченные вершины, но начинается обязательно с непомеченной). Обозначим через <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> первую вершину пути <img class=tex src="../tex2png/cache/83ce9474dc01fcd3fabaf5370a97449d.png" alt="P_2">, а через <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> &mdash; последнюю вершины пути <img class=tex src="../tex2png/cache/3122f48f5edf548c3d6dc9ec4b8d33bc.png" alt="P_1">.<p>Докажем сначала наше утверждение для вершины <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">, т.е. докажем равенство <img class=tex src="../tex2png/cache/2cc32146629ef6e04bf1622512953989.png" alt="d[p] = l[p]">. Однако это практически очевидно: ведь на одной из предыдущих итераций мы выбирали вершину <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> и выполняли релаксацию из неё. Поскольку (в силу самого выбора вершины <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">) кратчайший путь до <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> равен кратчайшему пути до <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> плюс ребро <img class=tex src="../tex2png/cache/c1ea56d7a30bcbf566a0788abd2a9881.png" alt="(p,q)">, то при выполнении релаксации из <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> величина <img class=tex src="../tex2png/cache/0f13a8b24e50f077090e52afeca1c86f.png" alt="d[p]"> действительно установится в требуемое значение.<p>Вследствие неотрицательности стоимостей рёбер длина кратчайшего пути <img class=tex src="../tex2png/cache/865500a989f085374f82bce9e4f80165.png" alt="l[p]"> (а она по только что доказанному равна <img class=tex src="../tex2png/cache/0f13a8b24e50f077090e52afeca1c86f.png" alt="d[p]">) не превосходит длины <img class=tex src="../tex2png/cache/17ed5ef9cde8932fb5bdb3dd748fe4b1.png" alt="l[v]"> кратчайшего пути до вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Учитывая, что <img class=tex src="../tex2png/cache/dfe0ebec874b6754736b87491dcdac15.png" alt="l[v] \le d[v]"> (ведь алгоритм Дейкстры не мог найти более короткого пути, чем это вообще возможно), в итоге получаем соотношения:<p class=formula><img class=tex src="../tex2png/cache/36212f20f6d8be1d6d17491b1b9ea4c0.png" alt=" d[p] = l[p] \le l[v] \le d[v] "></p><p>С другой стороны, поскольку и <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">, и <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> &mdash; вершины непомеченные, то так как на текущей итерации была выбрана именно вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, а не вершина <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">, то получаем другое неравенство:<p class=formula><img class=tex src="../tex2png/cache/69782b01f9036d45dc57cd2bb0b5956b.png" alt=" d[p] \ge d[v] "></p><p>Из этих двух неравенств заключаем равенство <img class=tex src="../tex2png/cache/ee061e3bea8a567fdb7f9002671a35e1.png" alt="d[p] = d[v]">, а тогда из найденных до этого соотношений получаем и:<p class=formula><img class=tex src="../tex2png/cache/a78885e30387157473f477f00332041d.png" alt=" d[v] = l[v] "></p><p>что и требовалось доказать.<p><h2 style="padding-top:40px;">Реализация</h2><p>Итак, алгоритм Дейкстры представляет собой <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> итераций, на каждой из которых выбирается непомеченная вершина с наименьшей величиной <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]">, эта вершина помечается, и затем просматриваются все рёбра, исходящие из данной вершины, и вдоль каждого ребра делается попытка улучшить значение <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]"> на другом конце ребра.<p>Время работы алгоритма складывается из:<ul><li><img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> раз поиск вершины с наименьшей величиной <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]"> среди всех непомеченных вершин, т.е. среди <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> вершин<li><img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> раз производится попытка релаксаций</ul><p>При простейшей реализации этих операций на поиск вершины будет затрачиваться <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> операций, а на одну релаксацию &mdash; <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> операций, и итоговая <b>асимптотика</b> алгоритма составляет:<p class=formula><img class=tex src="../tex2png/cache/e6dd7deb04d4f24322f177c9d66a515b.png" alt=" O(n^2+m) "></p><p><b>Реализация</b>:<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> INF <span class="sy1">=</span> <span class="nu0">1000000000</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n<span class="sy4">;</span>
	... чтение n ...
	<span class="me1">vector</span> <span class="sy1">&lt;</span> vector <span class="sy1">&lt;</span> pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> <span class="sy1">&gt;</span> g <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
	... чтение графа ...
	<span class="kw4">int</span> s <span class="sy1">=</span> ...<span class="sy4">;</span> <span class="co1">// стартовая вершина</span>
&nbsp;
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> d <span class="br0">&#40;</span>n, INF<span class="br0">&#41;</span>,  p <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
	d<span class="br0">&#91;</span>s<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span> u <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> v <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>u<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy3">&amp;&amp;</span> <span class="br0">&#40;</span>v <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy3">||</span> d<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">&lt;</span> d<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
				v <span class="sy1">=</span> j<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">==</span> INF<span class="br0">&#41;</span>
			<span class="kw1">break</span><span class="sy4">;</span>
		u<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
&nbsp;
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> to <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">first</span>,
				len <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">second</span><span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> len <span class="sy1">&lt;</span> d<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				d<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> len<span class="sy4">;</span>
				p<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Здесь граф <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> хранится в виде списков смежности: для каждой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> список <img class=tex src="../tex2png/cache/7fe07e18a35dc318b49ca0ee3c3683f0.png" alt="g[v]"> содержит список рёбер, исходящих из этой вершины, т.е. список пар <img class=tex src="../tex2png/cache/63d62ce13d3b184004da18b7115d2065.png" alt="\rm pair<int,int>">, где первый элемент пары &mdash; вершина, в которую ведёт ребро, а второй элемент &mdash; вес ребра.<p>После чтения заводятся массивы расстояний <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]">, меток <img class=tex src="../tex2png/cache/df09cae95940e511f8d96cbe8d9ad6b7.png" alt="u[]"> и предков <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]">. Затем выполняются <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> итераций. На каждой итерации сначала находится вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, имеющая наименьшее расстояние <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]"> среди непомеченных вершин. Если расстояние до выбранной вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> оказывается равным бесконечности, то алгоритм останавливается. Иначе вершина помечается как помеченная, и просматриваются все рёбра, исходящие из данной вершины, и вдоль каждого ребра выполняются релаксации. Если релаксация успешна (т.е. расстояние <img class=tex src="../tex2png/cache/055ebcf2759a1e84a08f5a359acfc850.png" alt="d[to]"> меняется), то пересчитывается расстояние <img class=tex src="../tex2png/cache/055ebcf2759a1e84a08f5a359acfc850.png" alt="d[to]"> и сохраняется предок <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]">.<p>После выполнения всех итераций в массиве <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]"> оказываются длины кратчайших путей до всех вершин, а в массиве <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]"> &mdash; предки всех вершин (кроме стартовой <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">). Восстановить путь до любой вершины <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> можно следующим образом:<pre class="notranslate cpp">vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> path<span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="sy1">=</span>t<span class="sy4">;</span> v<span class="sy3">!</span><span class="sy1">=</span>s<span class="sy4">;</span> v<span class="sy1">=</span>p<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span>
	path.<span class="me1">push_back</span> <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
path.<span class="me1">push_back</span> <span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="sy4">;</span>
reverse <span class="br0">&#40;</span>path.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, path.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p><h2 style="padding-top:40px;">Литература</h2><p><ul><li><a href="http://www.e-maxx-ru.1gb.ru/bookz/files/cormen.djvu">Томас Кормен, Чарльз Лейзерсон, Рональд Ривест, Клиффорд Штайн. <b>Алгоритмы: Построение и анализ</b> [2005]</a><li>Edsger Dijkstra. <b>A note on two problems in connexion with graphs</b> [1959]</ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>