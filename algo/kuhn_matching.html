<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Алгоритм Куна нахождения наибольшего паросочетания</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 23:01<br>редактировано: 15 Feb 2012 23:59</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="kuhn_matching.html#" id="contents-hide">[скрыть]</a><a href="kuhn_matching.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Алгоритм Куна нахождения наибольшего паросочетания в двудольном графе </h1><p>Дан двудольный граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">, содержащий <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершин и <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> рёбер. Требуется найти наибольшее паросочетание, т.е. выбрать как можно больше рёбер, чтобы ни одно выбранное ребро не имело общей вершины ни с каким другим выбранным ребром.<p><p><h2 style="padding-top:40px;"> Описание алгоритма </h2><p><p><h3 style="padding-top:15px;"> Необходимые определения </h3><p><b>Паросочетанием</b> <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> называется набор попарно несмежных рёбер графа (иными словами, любой вершине графа должно быть инцидентно не более одного ребра из множества <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M">). Мощностью паросочетания назовём количество рёбер в нём. Наибольшим (или максимальным) паросочетанием назовём паросочетание, мощность которого максимальна среди всех возможных паросочетаний в данном графе. Все те вершины, у которых есть смежное ребро из паросочетания (т.е. которые имеют степень ровно один в подграфе, образованном <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M">), назовём насыщенными этим паросочетанием.<p><b>Цепью</b> длины <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> назовём некоторый простой путь (т.е. не содержащий повторяющихся вершин или рёбер), содержащий <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> рёбер.<p><b>Чередующейся цепью</b> (в двудольном графе, относительно некоторого паросочетания) назовём цепь, в которой рёбра поочередно принадлежат/не принадлежат паросочетанию.<p><b>Увеличивающей цепью</b> (в двудольном графе, относительно некоторого паросочетания) назовём чередующуюся цепь, у которой начальная и конечная вершины не принадлежат паросочетанию.<p><p><h3 style="padding-top:15px;"> Теорема Бержа </h3><p><b>Формулировка</b>. Паросочетание является максимальным тогда и только тогда, когда не существует увеличивающих относительно него цепей.<p><b>Доказательство необходимости</b>. Покажем, что если паросочетание <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> максимально, то не существует увеличивающей относительно него цепи. Доказательство это будет конструктивным: мы покажем, как увеличить с помощью этой увеличивающей цепи <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> мощность паросочетания <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> на единицу.<p>Для этого выполним так называемое чередование паросочетания вдоль цепи <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">. Мы помним, что по определению первое ребро цепи <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> не принадлежит паросочетанию, второе &mdash; принадлежит, третье &mdash; снова не принадлежит, четвёртое &mdash; принадлежит, и т.д. Давайте поменяем состояние всех рёбер вдоль цепи <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">: те рёбра, которые не входили в паросочетание (первое, третье и т.д. до последнего) включим в паросочетание, а рёбра, которые раньше входили в паросочетание (второе, четвёртое и т.д. до предпоследнего) &mdash; удалим из него.<p>Понятно, что мощность паросочетания при этом увеличилась на единицу (потому что было добавлено на одно ребро больше, чем удалено). Осталось проверить, что мы построили корректное паросочетание, т.е. что никакая вершина графа не имеет сразу двух смежных рёбер из этого паросочетания. Для всех вершин чередующей цепи <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">, кроме первой и последней, это следует из самого алгоритма чередования: сначала мы у каждой такой вершины удалили смежное ребро, потом добавили. Для первой и последней вершины цепи <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> также ничего не могло нарушиться, поскольку до чередования они должны были быть ненасыщенными. Наконец, для всех остальных вершин, &mdash; не входящих в цепь <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">, &mdash; очевидно, ничего не поменялось. Таким образом, мы в самом деле построили паросочетание, и на единицу большей мощности, чем старое, что и завершает доказательство необходимости.<p><b>Доказательство достаточности</b>. Докажем, что если относительно некоторого паросочетания <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> нет увеличивающих путей, то оно &mdash; максимально.<p>Доказательство проведём от противного. Пусть есть паросочетание <img class=tex src="../tex2png/cache/6fa3b7b1df2447aac8af9a78f6c8751c.png" alt="M^\prime">, имеющее бОльшую мощность, чем <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M">. Рассмотрим симметрическую разность <img class=tex src="../tex2png/cache/c81650f5b09e29586f6c77c5325ac538.png" alt="Q"> этих двух паросочетаний, т.е. оставим все рёбра, входящие в <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> или в <img class=tex src="../tex2png/cache/6fa3b7b1df2447aac8af9a78f6c8751c.png" alt="M^\prime">, но не в оба одновременно.<p>Понятно, что множество рёбер <img class=tex src="../tex2png/cache/c81650f5b09e29586f6c77c5325ac538.png" alt="Q"> &mdash; уже наверняка не паросочетание. Рассмотрим, какой вид это множество рёбер имеет; для удобства будем рассматривать его как граф. В этом графе каждая вершина, очевидно, имеет степень не выше 2 (потому что каждая вершина может иметь максимум два смежных ребра &mdash; из одного паросочетания и из другого). Легко понять, что тогда этот граф состоит только из циклов или путей, причём ни те, ни другие не пересекаются друг с другом.<p>Теперь заметим, что и пути в этом графе <img class=tex src="../tex2png/cache/c81650f5b09e29586f6c77c5325ac538.png" alt="Q"> могут быть не любыми, а только чётной длины. В самом деле, в любом пути в графе <img class=tex src="../tex2png/cache/c81650f5b09e29586f6c77c5325ac538.png" alt="Q"> рёбра чередуются: после ребра из <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> идёт ребро из <img class=tex src="../tex2png/cache/6fa3b7b1df2447aac8af9a78f6c8751c.png" alt="M^\prime">, и наоборот. Теперь, если мы рассмотрим какой-то путь нечётной длины в графе <img class=tex src="../tex2png/cache/c81650f5b09e29586f6c77c5325ac538.png" alt="Q">, то получится, что в исходном графе <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> это будет увеличивающей цепью либо для паросочетания <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M">, либо для <img class=tex src="../tex2png/cache/6fa3b7b1df2447aac8af9a78f6c8751c.png" alt="M^\prime">. Но этого быть не могло, потому что в случае паросочетания <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> это противоречит с условием, а в случае <img class=tex src="../tex2png/cache/6fa3b7b1df2447aac8af9a78f6c8751c.png" alt="M^\prime"> &mdash; с его максимальностью (ведь мы уже доказали необходимость теоремы, из которой следует, что при существовании увеличивающей цепи паросочетание не может быть максимальным).<p>Докажем теперь аналогичное утверждение и для циклов: все циклы в графе <img class=tex src="../tex2png/cache/c81650f5b09e29586f6c77c5325ac538.png" alt="Q"> могут иметь только чётную длину. Это доказать совсем просто: понятно, что в цикле рёбра также должны чередоваться (принадлежать по очереди то <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M">, то <img class=tex src="../tex2png/cache/6fa3b7b1df2447aac8af9a78f6c8751c.png" alt="M^\prime">), но это условие не может выполниться в цикле нечётной длины &mdash; в нём обязательно найдутся два соседних ребра из одного паросочетания, что противоречит определению паросочетания.<p>Таким образом, все пути и циклы графа <img class=tex src="../tex2png/cache/74f17f2fe49915d3bf0e6c43a8ae48a5.png" alt="Q = M \oplus M^\prime"> имеют чётную длину. Следовательно, граф <img class=tex src="../tex2png/cache/c81650f5b09e29586f6c77c5325ac538.png" alt="Q"> содержит равное количество рёбер из <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> и из <img class=tex src="../tex2png/cache/6fa3b7b1df2447aac8af9a78f6c8751c.png" alt="M^\prime">. Но, учитывая, что в <img class=tex src="../tex2png/cache/c81650f5b09e29586f6c77c5325ac538.png" alt="Q"> содержатся все рёбра <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> и <img class=tex src="../tex2png/cache/6fa3b7b1df2447aac8af9a78f6c8751c.png" alt="M^\prime">, за исключением их общих рёбер, то отсюда следует, что мощность <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> и <img class=tex src="../tex2png/cache/6fa3b7b1df2447aac8af9a78f6c8751c.png" alt="M^\prime"> совпадают. Мы пришли к противоречию: по предположению паросочетание <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> было не максимальным, значит, теорема доказана.<p><p><h3 style="padding-top:15px;"> Алгоритм Куна </h3><p>Алгоритм Куна &mdash; непосредственное применение теоремы Бержа. Его можно кратко описать так: сначала возьмём пустое паросочетание, а потом &mdash; пока в графе удаётся найти увеличивающую цепь, &mdash; будем выполнять чередование паросочетания вдоль этой цепи, и повторять процесс поиска увеличивающей цепи. Как только такую цепь найти не удалось &mdash; процесс останавливаем, &mdash; текущее паросочетание и есть максимальное.<p>Осталось детализировать способ нахождения увеличивающих цепей. <b>Алгоритм Куна</b> &mdash; просто ищет любую из таких цепей с помощью <b><a href="dfs.html">обхода в глубину</b></a> или <b><a href="bfs.html">в ширину</b></a>. Алгоритм Куна просматривает все вершины графа по очереди, запуская из каждой обход, пытающийся найти увеличивающую цепь, начинающуюся в этой вершине.<p>Удобнее описывать этот алгоритм, считая, что граф уже разбит на две доли (хотя на самом деле алгоритм можно реализовать и так, чтобы ему не давался на вход граф, явно разбитый на две доли).<p>Алгоритм просматривает все вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> первой доли графа: <img class=tex src="../tex2png/cache/19e173198d53ca98b759326913bd4f11.png" alt="v = 1 \ldots n_1">. Если текущая вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> уже насыщена текущим паросочетанием (т.е. уже выбрано какое-то смежное ей ребро), то эту вершину пропускаем. Иначе &mdash; алгоритм пытается насытить эту вершину, для чего запускается поиск увеличивающей цепи, начинающейся с этой вершины.<p>Поиск увеличивающей цепи осуществляется с помощью специального обхода в глубину или ширину (обычно в целях простоты реализации используют именно обход в глубину). Изначально обход в глубину стоит в текущей ненасыщенной вершине <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> первой доли. Просматриваем все рёбра из этой вершины, пусть текущее ребро &mdash; это ребро <img class=tex src="../tex2png/cache/2f71535f4ca1feaf0a836a12914b1d88.png" alt="(v,to)">. Если вершина <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to"> ещё не насыщена паросочетанием, то, значит, мы смогли найти увеличивающую цепь: она состоит из единственного ребра <img class=tex src="../tex2png/cache/2f71535f4ca1feaf0a836a12914b1d88.png" alt="(v,to)">; в таком случае просто включаем это ребро в паросочетание и прекращаем поиск увеличивающей цепи из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Иначе, &mdash; если <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to"> уже насыщена каким-то ребром <img class=tex src="../tex2png/cache/bc3bb48bf80e3ead6fd4cb40845e7818.png" alt="(p,to)">, то попытаемся пройти вдоль этого ребра: тем самым мы попробуем найти увеличивающую цепь, проходящую через рёбра <img class=tex src="../tex2png/cache/2f71535f4ca1feaf0a836a12914b1d88.png" alt="(v,to)">, <img class=tex src="../tex2png/cache/a0c89987562644cc19420ffe5cc26694.png" alt="(to,p)">. Для этого просто перейдём в нашем обходе в вершину <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> &mdash; теперь мы уже пробуем найти увеличивающую цепь из этой вершины.<p>Можно понять, что в результате этот обход, запущенный из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, либо найдёт увеличивающую цепь, и тем самым насытит вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, либо же такой увеличивающей цепи не найдёт (и, следовательно, эта вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> уже не сможет стать насыщенной).<p>После того, как все вершины <img class=tex src="../tex2png/cache/19e173198d53ca98b759326913bd4f11.png" alt="v = 1 \ldots n_1"> будут просмотрены, текущее паросочетание будет максимальным.<p><p><h3 style="padding-top:15px;"> Время работы </h3><p>Итак, алгоритм Куна можно представить как серию из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> запусков обхода в глубину/ширину на всём графе. Следовательно, всего этот алгоритм исполняется за время <img class=tex src="../tex2png/cache/a6b2398465a599d7b0ac3127f16f0244.png" alt="O (n m)">, что в худшем случае есть <img class=tex src="../tex2png/cache/ee6e2ce73ecd60d80d4fa8f04d0691e9.png" alt="O (n^3)">.<p>Однако эту оценку можно немного <b>улучшить</b>. Оказывается, для алгоритма Куна важно то, какая доля выбрана за первую, а какая &mdash; за вторую. В самом деле, в описанной выше реализации запуски обхода в глубину/ширину происходят только из вершин первой доли, поэтому весь алгоритм исполняется за время <img class=tex src="../tex2png/cache/6d8ad3bc311fe015c93a2a8816fb10d4.png" alt="O (n_1 m)">, где <img class=tex src="../tex2png/cache/56b63fd991ee30598fff0a741b6b393e.png" alt="n_1"> &mdash; число вершин первой доли. В худшем случае это составляет <img class=tex src="../tex2png/cache/eeac18a6cfd2ce223bd07c559b1c1553.png" alt="O (n_1^2 n_2)"> (где <img class=tex src="../tex2png/cache/2e9c9bc72d100580d016be5e02d6a789.png" alt="n_2"> &mdash; число вершин второй доли). Отсюда видно, что выгоднее, когда первая доля содержит меньшее число вершин, нежели вторая. На очень несбалансированных графах (когда <img class=tex src="../tex2png/cache/56b63fd991ee30598fff0a741b6b393e.png" alt="n_1"> и <img class=tex src="../tex2png/cache/2e9c9bc72d100580d016be5e02d6a789.png" alt="n_2"> сильно отличаются) это выливается в значительную разницу времён работы.<p><p><h2 style="padding-top:40px;"> Реализация </h2><p>Приведём здесь реализацию вышеописанного алгоритма, основанную на обходе в глубину, и принимающей двудольный граф в виде явно разбитого на две доли графа. Эта реализация весьма лаконична, и, возможно, её стоит запомнить именно в таком виде.<p>Здесь <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> &mdash; число вершин в первой доле, <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> &mdash; во второй доле, <img class=tex src="../tex2png/cache/7fe07e18a35dc318b49ca0ee3c3683f0.png" alt="g[v]"> &mdash; список рёбер из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> первой доли (т.е. список номеров вершин, в которые ведут эти рёбра из <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">). Вершины в обеих долях занумерованы независимо, т.е. первая доля &mdash; с номерами <img class=tex src="../tex2png/cache/703638b38b37c914ea52b0b834b8fb1a.png" alt="1 \ldots n">, вторая &mdash; с номерами <img class=tex src="../tex2png/cache/2dfb32156cc1a12ca2e705205440bce5.png" alt="1 \ldots k">.<p>Дальше идут два вспомогательных массива: <img class=tex src="../tex2png/cache/1bec48868f13bbb6a67b25fbacfcb349.png" alt="\rm mt"> и <img class=tex src="../tex2png/cache/4ecdf68925044e45b2fd890bdbbe9ef5.png" alt="\rm used">. Первый &mdash; <img class=tex src="../tex2png/cache/1bec48868f13bbb6a67b25fbacfcb349.png" alt="\rm mt"> &mdash; содержит в себе информацию о текущем паросочетании. Для удобства программирования, информация эта содержится только для вершин второй доли: <img class=tex src="../tex2png/cache/31c9e20358b67cb713f07209f7070689.png" alt="mt[i]"> &mdash; это номер вершины первой доли, связанной ребром с вершиной <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> второй доли (или <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1">, если никакого ребра паросочетания из <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> не выходит). Второй массив &mdash; <img class=tex src="../tex2png/cache/4ecdf68925044e45b2fd890bdbbe9ef5.png" alt="\rm used"> &mdash; обычный массив "посещённостей" вершин в обходе в глубину (он нужен, просто чтобы обход в глубину не заходил в одну вершину дважды).<p>Функция <img class=tex src="../tex2png/cache/8812f1d3b5b758673295a24812101996.png" alt="\rm try\_kuhn"> &mdash; и есть обход в глубину. Она возвращает <img class=tex src="../tex2png/cache/d04c5eb60a53293d4878d3c73c349aa6.png" alt="\rm true">, если ей удалось найти увеличивающую цепь из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, при этом считается, что эта функция уже произвела чередование паросочетания вдоль найденной цепи.<p>Внутри функции просматриваются все рёбра, исходящие из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> первой доли, и затем проверяется: если это ребро ведёт в ненасыщенную вершину <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to">, либо если эта вершина <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to"> насыщена, но удаётся найти увеличивающую цепь рекурсивным запуском из <img class=tex src="../tex2png/cache/85516da918195bd0987acc68a5c35748.png" alt="\rm mt[to]">, то мы говорим, что мы нашли увеличивающую цепь, и перед возвратом из функции с результатом <img class=tex src="../tex2png/cache/d04c5eb60a53293d4878d3c73c349aa6.png" alt="\rm true"> производим чередование в текущем ребре: перенаправляем ребро, смежное с <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to">, в вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">.<p>В основной программе сначала указывается, что текущее паросочетание &mdash; пустое (список <img class=tex src="../tex2png/cache/1bec48868f13bbb6a67b25fbacfcb349.png" alt="\rm mt"> заполняется числами <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1">). Затем перебирается вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> первой доли, и из неё запускается обход в глубину <img class=tex src="../tex2png/cache/8812f1d3b5b758673295a24812101996.png" alt="\rm try\_kuhn">, предварительно обнулив массив <img class=tex src="../tex2png/cache/4ecdf68925044e45b2fd890bdbbe9ef5.png" alt="\rm used">.<p>Стоит заметить, что размер паросочетания легко получить как число вызовов <img class=tex src="../tex2png/cache/8812f1d3b5b758673295a24812101996.png" alt="\rm try\_kuhn"> в основной программе, вернувших результат <img class=tex src="../tex2png/cache/d04c5eb60a53293d4878d3c73c349aa6.png" alt="\rm true">. Само искомое максимальное паросочетание содержится в массиве <img class=tex src="../tex2png/cache/1bec48868f13bbb6a67b25fbacfcb349.png" alt="\rm mt">.<p><pre class="notranslate cpp"><span class="kw4">int</span> n, k<span class="sy4">;</span>
vector <span class="sy1">&lt;</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> g<span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> mt<span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span> used<span class="sy4">;</span>
&nbsp;
<span class="kw4">bool</span> try_kuhn <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>used<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span>  <span class="kw1">return</span> <span class="kw2">false</span><span class="sy4">;</span>
	used<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> to <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>mt<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy3">||</span> try_kuhn <span class="br0">&#40;</span>mt<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			mt<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
			<span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> <span class="kw2">false</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	... чтение графа ...
&nbsp;
	<span class="me1">mt</span>.<span class="me1">assign</span> <span class="br0">&#40;</span>k, <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> v<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		used.<span class="me1">assign</span> <span class="br0">&#40;</span>n, <span class="kw2">false</span><span class="br0">&#41;</span><span class="sy4">;</span>
		try_kuhn <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>k<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>mt<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
			<span class="kw3">printf</span> <span class="br0">&#40;</span><span class="st0">&quot;%d %d<span class="es1">\n</span>&quot;</span>, mt<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy2">+</span><span class="nu0">1</span>, i<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Ещё раз повторим, что алгоритм Куна легко реализовать и так, чтобы он работал на графах, про которые известно, что они двудольные, но явное их разбиение на две доли не найдено. В этом случае придётся отказаться от удобного разбиения на две доли, и всю информацию хранить для всех вершин графа. Для этого массив списков <img class=tex src="../tex2png/cache/016b9521e1847132b61db0423dfff527.png" alt="g"> теперь задаётся не только для вершин первой доли, а для всех вершин графа (понятно, теперь вершины обеих долей занумерованы в общей нумерации &mdash; от <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"> до <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">). Массивы <img class=tex src="../tex2png/cache/1bec48868f13bbb6a67b25fbacfcb349.png" alt="\rm mt"> и <img class=tex src="../tex2png/cache/4ecdf68925044e45b2fd890bdbbe9ef5.png" alt="\rm used"> теперь также определены для вершин обеих долей, и, соответственно, их нужно поддерживать в этом состоянии.<p><p><h2 style="padding-top:40px;"> Улучшенная реализация </h2><p>Модифицируем алгоритм следующим образом. До основного цикла алгоритма найдём каким-нибудь простым алгоритмом <b>произвольное паросочетание</b> (простым <b>эвристическим алгоритмом</b>), и лишь затем будем выполнять цикл с вызовами функции kuhn(), который будет улучшать это паросочетание. В результате алгоритм будет работать заметно быстрее на случайных графах &mdash; потому что в большинстве графов можно легко набрать паросочетание достаточно большого веса с помощью эвристики, а потом улучшить найденное паросочетание до максимального уже обычным алгоритмом Куна. Тем самым мы сэкономим на запусках обхода в глубину из тех вершин, которые мы уже включили с помощью эвристики в текущее паросочетание.<p><b>Например</b>, можно просто перебрать все вершины первой доли, и для каждой из них найти произвольное ребро, которое можно добавить в паросочетание, и добавить его. Даже такая простая эвристика способна ускорить алгоритм Куна в несколько раз.<p>Следует обратить внимание на то, что основной цикл придётся немного модифицировать. Поскольку при вызове функции <img class=tex src="../tex2png/cache/8812f1d3b5b758673295a24812101996.png" alt="\rm try\_kuhn"> в основном цикле предполагается, что текущая вершина ещё не входит в паросочетание, то нужно добавить соответствующую проверку.<p>В реализации изменится только код в функции main():<p><pre class="notranslate cpp"><span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	... чтение графа ...
&nbsp;
	<span class="me1">mt</span>.<span class="me1">assign</span> <span class="br0">&#40;</span>k, <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span> used1 <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>mt<span class="br0">&#91;</span>g<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				mt<span class="br0">&#91;</span>g<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
				used1<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
				<span class="kw1">break</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>used1<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>  <span class="kw1">continue</span><span class="sy4">;</span>
		used.<span class="me1">assign</span> <span class="br0">&#40;</span>n, <span class="kw2">false</span><span class="br0">&#41;</span><span class="sy4">;</span>
		try_kuhn <span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>k<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>mt<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
			<span class="kw3">printf</span> <span class="br0">&#40;</span><span class="st0">&quot;%d %d<span class="es1">\n</span>&quot;</span>, mt<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy2">+</span><span class="nu0">1</span>, i<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><b>Другой хорошей эвристикой</b> является следующая. На каждом шаге будет искать вершину наименьшей степени (но не изолированную), из неё выбирать любое ребро и добавлять его в паросочетание, затем удаляя обе эти вершины со всеми инцидентными им рёбрами из графа. Такая жадность работает очень хорошо на случайных графах, даже в большинстве случаев строит максимальное паросочетание (хотя и против неё есть тест, на котором она найдёт паросочетание значительно меньшей величины, чем максимальное).<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>