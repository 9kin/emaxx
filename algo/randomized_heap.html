<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Рандомизированная куча</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 17 Jul 2009 23:00<br>редактировано: 17 Jul 2009 23:00</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="randomized_heap.html#" id="contents-hide">[скрыть]</a><a href="randomized_heap.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Рандомизированная куча</h1><p>Рандомизированная куча (randomized heap) &mdash; это куча, которая за счёт применения генератора случайных чисел позволяет выполнять все необходимые операции за логарифмическое ожидаемое время.<p><b>Кучей</b> называется бинарное дерево, для любой вершины которого справедливо, что значение в этой вершине меньше либо равно значений во всех её потомках (это куча для минимума; разумеется, симметрично можно определить кучу для максимума). Таким образом, в корне кучи всегда находится минимум.<p>Стандартный набор операций, определяемый для куч, следующий:<ul><li>Добавление элемента<li>Нахождение минимума<li>Извлечение минимума (удаление его из дерева и возврат его значения)<li>Слияние двух куч (возвращается куча, содержащая элементы обеих куч; дубликаты не удаляются)<li>Удаление произвольного элемента (при известной позиции в дереве)</ul><p>Рандомизированная куча позволяет выполнять все эти операции за ожидаемое время <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)"> при очень простой реализации.<p><h2 style="padding-top:40px;">Структура данных</h2><p>Сразу опишем структуру данных, описывающую бинарную кучу:<pre class="notranslate cpp"><span class="kw4">struct</span> tree <span class="br0">&#123;</span>
	T value<span class="sy4">;</span>
	tree <span class="sy2">*</span> l, <span class="sy2">*</span> r<span class="sy4">;</span>
<span class="br0">&#125;</span><span class="sy4">;</span></pre>В вершине дерева хранится значение <img class=tex src="../tex2png/cache/8f26ec6314d35a3a42070a6e2033c77e.png" alt="\rm value"> некоторого типа <img class=tex src="../tex2png/cache/fd229fc82d92df5d0baa25cb623d54e5.png" alt="\rm T">, для которого определён оператор сравнения (<img class=tex src="../tex2png/cache/e8905fc5847342a2712fe106899592f4.png" alt="\rm operator\ <">). Кроме того, хранятся указатели на левого и правого сыновей (которые равны 0, если соответствующий сын отсутствует).<p><h2 style="padding-top:40px;">Выполнение операций</h2><p>Нетрудно понять, что все операции над кучей сводятся к одной операции: <b>слиянию</b> двух куч в одну. Действительно, добавление элемента в кучу равносильно слиянию этой кучи с кучей, состоящей из единственного добавляемого элемента. Нахождение минимума вообще не требует никаких действий &mdash; минимумом просто является корень кучи. Извлечение минимума эквивалентно тому, что куча заменяется результатом слияния левого и правого поддерева корня. Наконец, удаление произвольного элемента аналогично удалению минимума: всё поддерево с корнем в этой вершине заменяется результатом слияния двух поддеревьев-сыновей этой вершины.<p>Итак, нам фактически надо реализовать только операцию слияния двух куч, все остальные операции тривиально сводятся к этой операции.<p>Пусть даны две кучи <img class=tex src="../tex2png/cache/a2f072ddc61e2674990fe5a5d15eff0d.png" alt="T_1"> и <img class=tex src="../tex2png/cache/52eb7dbc62473ac2580a62bcb396072c.png" alt="T_2">, требуется вернуть их объединение. Понятно, что в корне каждой из этих куч находятся их минимумы, поэтому в корне результирующей кучи будет находиться минимум из этих двух значений. Итак, мы сравниваем, в корне какой из куч находится меньшее значение, его помещаем в корень результата, а теперь мы должны объединить сыновей выбранной вершины с оставшейся кучей. Если мы по какому-то признаку выберем одного из двух сыновей, то тогда нам надо будет просто объединить поддерево в корне с этим сыном с кучей. Таким образом, мы снова пришли к операции слияния. Рано или поздно этот процесс остановится (на это понадобится, понятно, не более чем сумма высот куч).<p>Таким образом, чтобы достичь логарифмической асимптотики в среднем, нам надо указать способ выбора одного из двух сыновей с тем, чтобы в среднем длина проходимого пути получалась бы порядка логарифма от количества элементов в куче. Нетрудно догадаться, что производить этот выбор мы будем <b>случайно</b>, таким образом, реализация операции слияния получается такой:<p><pre class="notranslate cpp">tree <span class="sy2">*</span> merge <span class="br0">&#40;</span>tree <span class="sy2">*</span> t1, tree <span class="sy2">*</span> t2<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>t1 <span class="sy3">||</span> <span class="sy3">!</span>t2<span class="br0">&#41;</span>
		<span class="kw1">return</span> t1 <span class="sy4">?</span> t1 <span class="sy4">:</span> t2<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>t2<span class="sy2">-</span><span class="sy1">&gt;</span>value <span class="sy1">&lt;</span> t1<span class="sy2">-</span><span class="sy1">&gt;</span>value<span class="br0">&#41;</span>
		swap <span class="br0">&#40;</span>t1, t2<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw3">rand</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy3">&amp;</span> <span class="nu0">1</span><span class="br0">&#41;</span>
		swap <span class="br0">&#40;</span>t1<span class="sy2">-</span><span class="sy1">&gt;</span>l, t1<span class="sy2">-</span><span class="sy1">&gt;</span>r<span class="br0">&#41;</span><span class="sy4">;</span>
	t1<span class="sy2">-</span><span class="sy1">&gt;</span>l <span class="sy1">=</span> merge <span class="br0">&#40;</span>t1<span class="sy2">-</span><span class="sy1">&gt;</span>l, t2<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">return</span> t1<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Здесь сначала проверяется, если хотя бы одна из куч пуста, то никаких действий по слиянию производить не надо. Иначе, мы делаем, чтобы куча <img class=tex src="../tex2png/cache/1560510e6a8c40e3b063ffe9f1c42194.png" alt="\rm t1"> была кучей с меньшим значением в корне (для чего обмениваем <img class=tex src="../tex2png/cache/1560510e6a8c40e3b063ffe9f1c42194.png" alt="\rm t1"> и <img class=tex src="../tex2png/cache/a298f58838672ee43b527fa478168db2.png" alt="\rm t2">, если надо). Наконец, мы считаем, что вторую кучу <img class=tex src="../tex2png/cache/a298f58838672ee43b527fa478168db2.png" alt="\rm t2"> будем сливать с левым сыном корня кучи <img class=tex src="../tex2png/cache/1560510e6a8c40e3b063ffe9f1c42194.png" alt="\rm t1">, поэтому мы случайным образом обмениваем левого и правого сыновей, а затем выполняем слияние левого сына и второй кучи.<p><h2 style="padding-top:40px;">Асимптотика</h2><p>Введём случайную величину <img class=tex src="../tex2png/cache/3ca8e3a84723ffa4dc34f654aab2312f.png" alt="h(T)">, обозначающую <b>длину случайного пути</b> от корня до листа (длина в числе рёбер). Понятно, что алгоритм <img class=tex src="../tex2png/cache/ec1152d4db339211ffdaa3c71fd54eca.png" alt="\rm merge"> выполняется за <img class=tex src="../tex2png/cache/30045454060d3afca8c2f8ef5cfde881.png" alt="O(h(T1)+h(T2))"> операций. Поэтому для исследования асимптотики алгоритма надо исследовать случайную величину <img class=tex src="../tex2png/cache/3ca8e3a84723ffa4dc34f654aab2312f.png" alt="h(T)">.<p><h3 style="padding-top:15px;">Математическое ожидание</h3><p>Утверждается, что математическое ожидание <img class=tex src="../tex2png/cache/3ca8e3a84723ffa4dc34f654aab2312f.png" alt="h(T)"> оценивается сверху логарифмом от числа <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершин в этой куче:<p class=formula><img class=tex src="../tex2png/cache/d4f1a04aa5aee7ca6a768d36f6c8035c.png" alt=" Eh(T) \le \log(n+1) "></p><p>Доказывается это легко по индукции. Пусть <img class=tex src="../tex2png/cache/88e54f90480ef3aeba329562335471f9.png" alt="L"> и <img class=tex src="../tex2png/cache/4f3105397250ea0969b057bde4dfb244.png" alt="R"> &mdash; соответственно левое и правое поддеревья корня кучи <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">, а <img class=tex src="../tex2png/cache/924589e0a575bc412a79170898c579c9.png" alt="n_L"> и <img class=tex src="../tex2png/cache/3de707e005881a38c67bf6c76d087aca.png" alt="n_R"> &mdash; количества вершин в них (понятно, что <img class=tex src="../tex2png/cache/6957d63761b60a6d9865f1414cc5a89d.png" alt="n = n_L+n_R+1">).<p>Тогда справедливо:<p class=formula><img class=tex src="../tex2png/cache/616dd1b71828904a200f8322d05836ef.png" alt=" Eh(T) = 1 + \frac{1}{2}(Eh(L) + Eh(R)) \le 1 + \f[...]"><br><img class=tex src="../tex2png/cache/d5820bf5a9ac49f8e0012d26d8b09e14.png" alt=" = 1 + \log \sqrt{ (n_L+1)(n_R+1) } = \log 2 \sqrt[...]"><br><img class=tex src="../tex2png/cache/88478fe624acafa82531eb8555ad4feb.png" alt=" \le \log \frac{ 2 ((n_L+1) + (n_R+1)) }{ 2 } = \l[...]"></p>что и требовалось доказать.<p><h3 style="padding-top:15px;">Превышение ожидаемой оценки</h3><p>Докажем, что вероятность превышения полученной выше оценки мала:<p class=formula><img class=tex src="../tex2png/cache/4d0755eb60c3f9aa3ba722d248b2ea37.png" alt=" P\{ h(T) > (c+1) \log n \} < \frac{1}{n^c} "></p>для любой положительной константы <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">.<p>Обозначим через <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> множество путей от корня кучи до листьев, длина которых превосходит <img class=tex src="../tex2png/cache/ce64821a2d850a54592eb5710b019824.png" alt="(c+1) \log n">. Заметим, что для любого пути <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> длины <img class=tex src="../tex2png/cache/fc8dc8d0464680315712057b1be634a5.png" alt="|p|"> вероятность того, в качестве случайного пути будет выбран именно он, равна <img class=tex src="../tex2png/cache/7ee083ad48ddf71ce47ed36089257ad5.png" alt="2^{-|p|}">. Тогда получаем:<p class=formula><img class=tex src="../tex2png/cache/1988902add42dd0242a03193baa2b52d.png" alt=" P\{ h(T) > (c+1) \log n \} = \sum_{p \in P} 2^{-|[...]"></p>что и требовалось доказать.<p><h3 style="padding-top:15px;">Асимптотика алгоритма</h3><p>Таким образом, алгоритм <img class=tex src="../tex2png/cache/ec1152d4db339211ffdaa3c71fd54eca.png" alt="\rm merge">, а, значит, и все остальные выраженные через него операции, выполняется за <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)"> в среднем.<p>Более того, для любой положительной константы <img class=tex src="../tex2png/cache/6e16d6243036ea0ea9b78982239e8eb0.png" alt="\epsilon"> найдётся такая положительная константа <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">, что вероятность того, что операция потребует больше чем <img class=tex src="../tex2png/cache/fcfcee952d975374261ffe74220f17cb.png" alt="c \log n"> операций, меньше <img class=tex src="../tex2png/cache/33ee2a4aa494c2ce53be8db37d1d12f8.png" alt="n^{-\epsilon}"> (это в некотором смысле описывает худшее поведение алгоритма).<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>