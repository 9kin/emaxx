<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Тернарный поиск</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 23 Jul 2009 12:53<br>редактировано: 23 Jul 2009 12:53</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="ternary_search.html#" id="contents-hide">[скрыть]</a><a href="ternary_search.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Тернарный поиск</h1><p><h2 style="padding-top:40px;">Постановка задачи</h2><p>Пусть дана функция <img class=tex src="../tex2png/cache/c08c01c7f11043de3440285568d82570.png" alt="f(x)">, <b>унимодальная</b> на некотором отрезке <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]">. Под унимодальностью понимается один из двух вариантов. Первый: функция сначала строго возрастает, потом достигает максимума (в одной точке или целом отрезке), потом строго убывает. Второй вариант, симметричный: функция сначала убывает убывает, достигает минимума, возрастает. В дальнейшем мы будем рассматривать первый вариант, второй будет абсолютно симметричен ему.<p>Требуется <b>найти максимум</b> функции <img class=tex src="../tex2png/cache/c08c01c7f11043de3440285568d82570.png" alt="f(x)"> на отрезке <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]">.<p><h2 style="padding-top:40px;">Алгоритм</h2><p>Возьмём любые две точки <img class=tex src="../tex2png/cache/36af2470df0fd4be6b85be05a4606757.png" alt="m_1"> и <img class=tex src="../tex2png/cache/e3db9fbdb136bd00442abe333d4a6558.png" alt="m_2"> в этом отрезке: <img class=tex src="../tex2png/cache/ff6ac69fa1a63667d31e5fdda3492e81.png" alt="l < m_1 < m_2 < r">. Посчитаем значения функции <img class=tex src="../tex2png/cache/143ad640714beb7eaf7702121e77a1af.png" alt="f(m_1)"> и <img class=tex src="../tex2png/cache/e4b3f54147eff26054b3a874654ad296.png" alt="f(m_2)">. Дальше у нас получается три варианта:<p><ul><p><li>Если окажется, что <img class=tex src="../tex2png/cache/c55848c3cd1497c222cd45bdeee4c05b.png" alt="f(m_1) < f(m_2)">, то искомый максимум не может находиться в левой части, т.е. в части <img class=tex src="../tex2png/cache/baa47d9b8834afb6a34562dcc4e23767.png" alt="[l;m_1]">. В этом легко убедиться: если в левой точке функция меньше, чем в правой, то либо эти две точки находятся в области "подъёма" функции, либо только левая точка находится там. В любом случае, это означает, что максимум дальше имеет смысл искать только в отрезке <img class=tex src="../tex2png/cache/368078542e6139f025f9cac6bfc7712a.png" alt="[m_1;r]">.<p><li>Если, наоборот, <img class=tex src="../tex2png/cache/1a13ed4868f0999014a184c7a99ea209.png" alt="f(m_1) > f(m_2)">, то ситуация аналогична предыдущей с точностью до симметрии. Теперь искомый максимум не может находиться в правой части, т.е. в части <img class=tex src="../tex2png/cache/ef5e852eccfa5e38fd893aed967f8bac.png" alt="[m_2;r]">, поэтому переходим к отрезку <img class=tex src="../tex2png/cache/5820c69d815a8703dc0f187dad3410d3.png" alt="[l;m_2]">.<p><li>Если <img class=tex src="../tex2png/cache/04b0d802f196fa09ace0cb61d7efbf2f.png" alt="f(m_1) = f(m_2)">, то либо обе эти точки находятся в области максимума, либо левая точка находится в области возрастания, а правая &mdash; в области убывания (здесь существенно используется то, что возрастание/убывание строгие). Таким образом, в дальнейшем поиск имеет смысл производить в отрезке <img class=tex src="../tex2png/cache/b4a89d29fd7b1155bdff002133f64b02.png" alt="[m_1;m_2]">, но (в целях упрощения кода) этот случай можно отнести к любому из двух предыдущих.</ul><p>Таким образом, по результату сравнения значений функции в двух внутренних точках мы вместо текущего отрезка поиска <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> находим новый отрезок <img class=tex src="../tex2png/cache/0b20321923ee0f30424665b8f72608ac.png" alt="[l^\prime;r^\prime]">. Повторим теперь все действия для этого нового отрезка, снова получим новый, строго меньший, отрезок, и т.д.<p>Рано или поздно длина отрезка станет маленькой, меньшей заранее определённой константы-точности, и процесс можно останавливать. Этот метод численный, поэтому после остановки алгоритма можно приближённо считать, что во всех точках отрезка <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> достигается максимум; в качестве ответа можно взять, например, точку <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l">.<p>Осталось заметить, что мы не накладывали никаких ограничений на выбор точек <img class=tex src="../tex2png/cache/36af2470df0fd4be6b85be05a4606757.png" alt="m_1"> и <img class=tex src="../tex2png/cache/e3db9fbdb136bd00442abe333d4a6558.png" alt="m_2">. От этого способа, понятно, будет зависеть скорость сходимости (но и возникающая погрешность). Наиболее распространённый способ &mdash; выбирать точки так, чтобы отрезок <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> делился ими на 3 равные части:<p class=formula><img class=tex src="../tex2png/cache/ed46d4a543beb1b5d91536d55704a80e.png" alt=" m_1 = l + \frac{r-l}{3} "><br><img class=tex src="../tex2png/cache/02a79b6568742760025e8c79b34d4b29.png" alt=" m_2 = r - \frac{r-l}{3} "></p><p>Впрочем, при другом выборе, когда <img class=tex src="../tex2png/cache/36af2470df0fd4be6b85be05a4606757.png" alt="m_1"> и <img class=tex src="../tex2png/cache/e3db9fbdb136bd00442abe333d4a6558.png" alt="m_2"> ближе друг к другу, скорость сходимости несколько увеличится.<p><h3 style="padding-top:15px;">Случай целочисленного аргумента</h3><p>Если аргумент функции <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> целочисленный, то отрезок <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> тоже становится дискретным, однако, поскольку мы не накладывали никаких ограничений на выбор точек <img class=tex src="../tex2png/cache/36af2470df0fd4be6b85be05a4606757.png" alt="m_1"> и <img class=tex src="../tex2png/cache/e3db9fbdb136bd00442abe333d4a6558.png" alt="m_2">, то на корректность алгоритма это никак не влияет. Можно по-прежнему выбирать <img class=tex src="../tex2png/cache/36af2470df0fd4be6b85be05a4606757.png" alt="m_1"> и <img class=tex src="../tex2png/cache/e3db9fbdb136bd00442abe333d4a6558.png" alt="m_2"> так, чтобы они делили отрезок <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> на 3 части, но уже равные только приблизительно.<p>Второй отличающийся момент &mdash; критерий остановки алгоритма. В данном случае тернарный поиск надо будет останавливать, когда станет <img class=tex src="../tex2png/cache/064da8cc7d380941fb0a845e6b5245a5.png" alt="r-l<3">, ведь в таком случае уже невозможно будет выбрать точки <img class=tex src="../tex2png/cache/36af2470df0fd4be6b85be05a4606757.png" alt="m_1"> и <img class=tex src="../tex2png/cache/e3db9fbdb136bd00442abe333d4a6558.png" alt="m_2"> так, чтобы были различными и отличались от <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> и <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">, и это может привести к зацикливанию. После того, как алгоритм тернарного поиска остановится и станет <img class=tex src="../tex2png/cache/064da8cc7d380941fb0a845e6b5245a5.png" alt="r-l<3">, из оставшихся нескольких точек-кандидатов <img class=tex src="../tex2png/cache/295620c0f76122847691209d7a50297c.png" alt="(l,l+1,\ldots,r)"> надо выбрать точку с максимальным значением функции.<p><h2 style="padding-top:40px;">Реализация</h2><p>Реализация для непрерывного случая (т.е. функция <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> имеет вид: <img class=tex src="../tex2png/cache/4a74eb7e9ed360dc20f369b90199900f.png" alt="\rm double\ f\ (double\ x)">):<p><pre class="notranslate cpp"><span class="kw4">double</span> l <span class="sy1">=</span> ..., r <span class="sy1">=</span> ..., EPS <span class="sy1">=</span> ...<span class="sy4">;</span> <span class="co1">// входные данные</span>
<span class="kw1">while</span> <span class="br0">&#40;</span>r <span class="sy2">-</span> l <span class="sy1">&gt;</span> EPS<span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw4">double</span> m1 <span class="sy1">=</span> l <span class="sy2">+</span> <span class="br0">&#40;</span>r <span class="sy2">-</span> l<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">3</span>,
      m2 <span class="sy1">=</span> r <span class="sy2">-</span> <span class="br0">&#40;</span>r <span class="sy2">-</span> l<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">3</span><span class="sy4">;</span>
   <span class="kw1">if</span> <span class="br0">&#40;</span>f <span class="br0">&#40;</span>m1<span class="br0">&#41;</span> <span class="sy1">&lt;</span> f <span class="br0">&#40;</span>m2<span class="br0">&#41;</span><span class="br0">&#41;</span>
      l <span class="sy1">=</span> m1<span class="sy4">;</span>
   <span class="kw1">else</span>
      r <span class="sy1">=</span> m2<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Здесь <img class=tex src="../tex2png/cache/1a0d8efafc744f1b3ed9f417a47f5e8d.png" alt="\rm EPS"> &mdash; фактически, <b>абсолютная погрешность</b> ответа (не считая погрешностей, связанных с неточным вычислением функции).<p>Вместо критерия "while (r - l > EPS)" можно выбрать и такой критерий останова:<pre class="notranslate cpp"><span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> it<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> it<span class="sy1">&lt;</span>iterations<span class="sy4">;</span> <span class="sy2">++</span>it<span class="br0">&#41;</span></pre><p>С одной стороны, придётся подобрать константу <img class=tex src="../tex2png/cache/6afa97452f09fde09590c006b10a2938.png" alt="\rm iterations">, чтобы обеспечить требуемую точность (обычно достаточно нескольких сотен, чтобы достичь максимальной точности). Но зато, с другой стороны, число итераций перестаёт зависеть от абсолютных величин <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> и <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">, т.е. мы фактически с помощью <img class=tex src="../tex2png/cache/6afa97452f09fde09590c006b10a2938.png" alt="\rm iterations"> задаём требуемую <b>относительную погрешность</b>.<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>