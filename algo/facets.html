<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Нахождение всех граней, внешней грани планарного графа</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 2 Mar 2009 17:45<br>редактировано: 24 Aug 2011 12:11</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="facets.html#" id="contents-hide">[скрыть]</a><a href="facets.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Нахождение всех граней, внешней грани планарного графа</h1><p>Дан планарный, уложенный на плоскости граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами. Требуется найти все его грани. Гранью называется часть плоскости, ограниченная рёбрами этого графа.<p>Одна из граней будет отличаться от остальных тем, что будет иметь бесконечную площадь, такая грань называется внешней гранью. В некоторых задачах требуется находить только внешнюю грань, алгоритм нахождения которой, как мы увидим, по сути ничем не отличается от алгоритма для всех граней.<p><p><h2 style="padding-top:40px;">Теорема Эйлера</h2><p>Приведём здесь теорему Эйлера и несколько следствий из неё, из которых будет следовать, что число рёбер и граней планарного простого (без петель и кратных рёбер) графа являются величинами порядка <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">.<p>Пусть планарный граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> является связным. Обозначим через <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> число вершин в графе, <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> &mdash; число рёбер, <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> &mdash; число граней. Тогда справедлива <b>теорема Эйлера</b>:<p class=formula><img class=tex src="../tex2png/cache/db567452441bdb2caaf955b558d12879.png" alt=" f + n - m = 2 "></p>Доказать эту формулу легко следующим образом. В случае дерева (<img class=tex src="../tex2png/cache/117c0eca351f467be1c94762780efdb0.png" alt="m=n-1">) формула легко проверяется. Если граф &mdash; не дерево, то удалим любое ребро, принадлежащее какому-либо циклу; при этом величина <img class=tex src="../tex2png/cache/8591c8255989c933ac126d8f69a507ca.png" alt="f+n-m"> не изменится. Будем повторять этот процесс, пока не придём к дереву, для которого тождество <img class=tex src="../tex2png/cache/0af3602e83bd557283933456b963d42f.png" alt="f+n-m=2"> уже установлено. Таким образом, теорема доказана.<p><b>Следствие</b>. Для произвольного планарного графа пусть <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> &mdash; количество компонент связности. Тогда выполняется:<p class=formula><img class=tex src="../tex2png/cache/273cc2d3c5a6d24ee1075a811c3d674a.png" alt=" f + n - m = 1 + k "></p><p><b>Следствие</b>. Число рёбер <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> простого планарного графа является величиной <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">.<p>Доказательство. Пусть граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> является связным и <img class=tex src="../tex2png/cache/57e74afb511d3977121a467b910ccd30.png" alt="n \ge 3"> (в случае <img class=tex src="../tex2png/cache/b5ab89d711f0bbbd47d63784f75e42b3.png" alt="n < 3"> утверждение получаем автоматически). Тогда, с одной стороны, каждая грань ограничена как минимум тремя рёбрами. С другой стороны, каждое ребро ограничивает максимум две грани. Следовательно, <img class=tex src="../tex2png/cache/9e113be3f8310b31a2ee9527da6fd64f.png" alt="3f \le 2m">, откуда, подставляя это в формулу Эйлера, получаем:<p class=formula><img class=tex src="../tex2png/cache/0c0a5ae3286871301079847aa017c458.png" alt=" f + n - m = 2\ \ \Leftrightarrow\ \ 3f = 6 - 3n +[...]"></p>Т.е. <img class=tex src="../tex2png/cache/1fcd8e6a8e088e333a391a6e03c3700d.png" alt="m = O(n)">.<p>Если граф не является связным, то, суммируя полученные оценки по его компонентам связности, снова получаем <img class=tex src="../tex2png/cache/1fcd8e6a8e088e333a391a6e03c3700d.png" alt="m = O(n)">, что и требовалось доказать.<p><b>Следствие</b>. Число граней <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> простого планарного графа является величиной <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">.<p>Это следствие вытекает из предыдущего следствия и связи <img class=tex src="../tex2png/cache/771232fd0c88d03c8c587af444e9ce8b.png" alt="f = 2 - n + m">.<p><p><h2 style="padding-top:40px;">Обход всех граней</h2><p>Всегда будем считать, что граф, если он не является связным, уложен на плоскости таким образом, что никакая компонента связности не лежит внутри другой (например, квадрат с лежащим строго внутри него отрезком &mdash; некорректный для нашего алгоритма тест).<p>Разумеется, считается, что граф корректно уложен на плоскости, т.е. никакие две вершины не совпадают, а рёбра не пересекаются в "несанкционированных" точках. Если во входном графе допускаются такие пересекающиеся рёбра, то предварительно надо избавиться от них, вводя в каждую точку пересечения дополнительную вершину (надо заметить, что в результате этого процесса вместо <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> точек мы можем получить порядка <img class=tex src="../tex2png/cache/69c69118ca9294d5cdd0f79417241516.png" alt="n^2"> точек). Более подробно об этом процессе см. ниже в соответствующем разделе.<p>Пусть для каждой вершины все исходящие из неё рёбра упорядочены по полярному углу. Если это не так, то их следует упорядочить, произведя сортировку каждого списка смежности (т.к. <img class=tex src="../tex2png/cache/1fcd8e6a8e088e333a391a6e03c3700d.png" alt="m = O(n)">, на это потребуется <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)"> операций).<p>Теперь выберем произвольное ребро <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> и пустим следующий обход. Приходя в какую-то вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> по некоторому ребру, выходить из этой вершины мы обязательно должны по следующему в порядке сортировки ребру.<p>Например, на первом шаге мы находимся в вершине <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">, и должны найти вершину <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> в списке смежности вершины <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">, тогда обозначим через <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> следующую вершину в списке смежности (если <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> была последней, то в качестве <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> возьмём первую вершину), и пройдём по ребру <img class=tex src="../tex2png/cache/ec4eb764ac2bcd260bb434e142f75832.png" alt="(b,c)">.<p>Повторяя этот процесс много раз, мы рано или поздно придём обратно к стартовому ребру <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)">, после чего надо остановиться. Нетрудно заметить, что при таком обходе мы обойдём ровно одну грань. Причём направление обхода будет против часовой стрелки для внешней грани, и по часовой стрелке &mdash; для внутренних граней. Иными словами, при таком обходе внутренность грани будет всегда по правую сторону от текущего ребра.<p>Итак, мы научились обходить одну грань, стартуя с любого ребра на её границе. Осталось научиться выбирать стартовые рёбра таким образом, чтобы получаемые грани не повторялись. Заметим, что у каждого ребра различаются два направления, в которых его можно обходить: при каждом из них будут получаться свои грани. С другой стороны, ясно, что одно такое ориентированное ребро принадлежит ровно одной грани. Таким образом, если мы будет помечать все рёбра каждой обнаруженной грани в некотором массиве <img class=tex src="../tex2png/cache/4ecdf68925044e45b2fd890bdbbe9ef5.png" alt="\rm used">, и не запускать обход из уже помеченных рёбер, то мы обойдём все грани (включая внешнюю), притом ровно по одному разу.<p>Приведём сразу <b>реализацию</b> этого обхода. Будем считать, что в графе <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> списки смежности уже упорядочены по углу, а кратные рёбра и петли отсутствуют.<p>Первый вариант реализации упрощённый, следующую вершину в списке смежности он ищет простым поиском. Такая реализация теоретически работает за <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)">, хотя на практике на многих тестах она работает весьма быстро (со скрытой константой, значительно меньшей единицы).<p><pre class="notranslate cpp"><span class="kw4">int</span> n<span class="sy4">;</span> <span class="co1">// число вершин</span>
vector <span class="sy1">&lt;</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> g<span class="sy4">;</span> <span class="co1">// граф</span>
&nbsp;
vector <span class="sy1">&lt;</span> vector<span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> used <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	used<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">resize</span> <span class="br0">&#40;</span>g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			used<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
			<span class="kw4">int</span> v <span class="sy1">=</span> g<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>,  pv <span class="sy1">=</span> i<span class="sy4">;</span>
			vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> facet<span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				facet.<span class="me1">push_back</span> <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
				vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">iterator</span> it <span class="sy1">=</span> find <span class="br0">&#40;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, pv<span class="br0">&#41;</span><span class="sy4">;</span>
				<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy2">++</span>it <span class="sy1">==</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>  it <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
				<span class="kw1">if</span> <span class="br0">&#40;</span>used<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>it<span class="sy2">-</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#93;</span><span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
				used<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>it<span class="sy2">-</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
				pv <span class="sy1">=</span> v,  v <span class="sy1">=</span> <span class="sy2">*</span>it<span class="sy4">;</span>
			<span class="br0">&#125;</span>
			... вывод facet <span class="sy2">-</span> текущей грани ...
		<span class="br0">&#125;</span></pre><p>Другой, более оптимизированный вариант реализации &mdash; пользуется тем, что вершине в списке смежности упорядочены по углу. Если реализовать функцию <img class=tex src="../tex2png/cache/c09f6a26d95a7456b37338e942d8bfea.png" alt="\rm cmp\_ang"> сравнения двух точек по полярному углу относительно третьей точки (например, оформив её в виде класса, как в примере ниже), то при поиске точки в списке смежности можно воспользоваться бинарным поиском. В результате получаем реализацию за <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">.<p><pre class="notranslate cpp"><span class="kw2">class</span> cmp_ang <span class="br0">&#123;</span>
	<span class="kw4">int</span> center<span class="sy4">;</span>
<span class="kw2">public</span><span class="sy4">:</span>
	cmp_ang <span class="br0">&#40;</span><span class="kw4">int</span> center<span class="br0">&#41;</span> <span class="sy4">:</span> center<span class="br0">&#40;</span>center<span class="br0">&#41;</span>
		<span class="br0">&#123;</span> <span class="br0">&#125;</span>
	<span class="kw4">bool</span> operator<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="kw4">const</span> <span class="br0">&#123;</span>
		... должна возвращать <span class="kw2">true</span>, если точка a имеет
		меньший чем b полярный угол относительно center ...
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
&nbsp;
&nbsp;
<span class="kw4">int</span> n<span class="sy4">;</span> <span class="co1">// число вершин</span>
vector <span class="sy1">&lt;</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> g<span class="sy4">;</span> <span class="co1">// граф</span>
&nbsp;
vector <span class="sy1">&lt;</span> vector<span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> used <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	used<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">resize</span> <span class="br0">&#40;</span>g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			used<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
			<span class="kw4">int</span> v <span class="sy1">=</span> g<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>,  pv <span class="sy1">=</span> i<span class="sy4">;</span>
			vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> facet<span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				facet.<span class="me1">push_back</span> <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
				vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">iterator</span> it <span class="sy1">=</span> lower_bound <span class="br0">&#40;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span>,
					pv, cmp_ang<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
				<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy2">++</span>it <span class="sy1">==</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>  it <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
				<span class="kw1">if</span> <span class="br0">&#40;</span>used<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>it<span class="sy2">-</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#93;</span><span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
				used<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>it<span class="sy2">-</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
				pv <span class="sy1">=</span> v,  v <span class="sy1">=</span> <span class="sy2">*</span>it<span class="sy4">;</span>
			<span class="br0">&#125;</span>
			... вывод facet <span class="sy2">-</span> текущей грани ...
		<span class="br0">&#125;</span></pre><p>Возможен и вариант, основанный на контейнере <img class=tex src="../tex2png/cache/fb80bd95620553bcf60b1b369ca11fae.png" alt="map">, ведь нам нужно всего лишь быстро узнавать позиции чисел в массиве. Разумеется, такая реализация также будет работать <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">.<p>Следует отметить, что алгоритм не совсем корректно работает с <b>изолированными</b> вершинами &mdash; такие вершины он просто не обнаружит как отдельные грани, хотя, с математической точки зрения, они должны представлять собой отдельные компоненты связности и грани.<p>Кроме того, особой гранью является <b>внешняя грань</b>. Как её отличать от "обычных" граней, описано в следующем разделе. Следует заметить, что если граф является не связным, то внешняя грань будет состоять из нескольких контуров, и каждый из этих контуров будет найден алгоритмом отдельно.<p><p><h2 style="padding-top:40px;">Выделение внешней грани</h2><p>Приведённый выше код выводит все грани, не делая различия между внешней гранью и внутренними гранями. На практике обычно, наоборот, требуется найти или только внешнюю грань, или только внутренние. Есть несколько приёмов выделения внешней грани.<p>Например, её можно определять по площади &mdash; внешняя грань должна иметь наибольшую площадь (следует только учесть, что внутренняя грань может иметь ту же площадь, что и внешняя). Этот способ не будет работать, если данный планарный граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> не является связным.<p>Другой, более надёжный критерий &mdash; по направлению обхода. Как уже отмечалось выше, все грани, кроме внешней, обходятся в направлении по часовой стрелки. Внешняя грань, даже если она состоит из нескольких контуров, обойдётся алгоритмом против часовой стрелки. Определить направление обхода можно, просто посчитав <a href="polygon_area.html">знаковую площадь многоугольника</a>. Площадь можно считать прямо по ходу внутреннего цикла. Однако и у этого метода есть своя тонкость &mdash; обработка граней нулевой площади. Например, если граф состоит из единственного ребра, то алгоритм найдёт единственную грань, площадь которой будет нулевой. По-видимому, если грань имеет нулевую площадь, то она является внешней гранью.<p>В некоторых случаях бывает применим и такой критерий, как количество вершин. Например, если граф представляет собой выпуклый многоугольник с проведёнными в нём непересекающимися диагоналями, то его внешняя грань будет содержать все вершины. Но снова надо быть аккуратным со случаем, когда и внешняя, и внутренняя грани имеют одинаковое число вершин.<p>Наконец есть и следующий метод нахождения внешней грани: можно специально запуститься от такого ребра, что найденная в результате грань будет внешней. Например, можно взять самую левую вершину (если таких несколько, то подойдёт любая) и выбрать из неё ребро, идущее первым в порядке сортировки. В результате обход из этого ребра найдёт внешнюю грань. Этот способ можно распространить и на случай несвязного графа: нужно в каждой компоненте связности найти самую левую вершину и запускать обход из первого ребра из неё.<p>Приведём реализацию самого простого метода, основанного на знаке площади (сам обход я для примера взял за <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)">, здесь это неважно). Если граф не связный, то код "... грань является внешней ..." выполнится отдельно для каждого контура, составляющего внешнюю грань.<p><pre class="notranslate cpp">			... обычный код по обнаружению граней ...
			... сразу после цикла, обнаруживающего очередную грань<span class="sy4">:</span> ...
&nbsp;
			<span class="co1">// считаем площадь</span>
			<span class="kw4">double</span> area <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
			<span class="co1">// добавляем фиктивную точку для простоты подсчёта площади</span>
			facet.<span class="me1">push_back</span> <span class="br0">&#40;</span>facet<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> k<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> k<span class="sy2">+</span><span class="nu0">1</span><span class="sy1">&lt;</span>facet.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>k<span class="br0">&#41;</span>
				area <span class="sy2">+</span><span class="sy1">=</span> <span class="br0">&#40;</span>p<span class="br0">&#91;</span>facet<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#93;</span>.<span class="me1">first</span> <span class="sy2">+</span> p<span class="br0">&#91;</span>facet<span class="br0">&#91;</span>k<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#93;</span>.<span class="me1">first</span><span class="br0">&#41;</span>
					<span class="sy2">*</span> <span class="br0">&#40;</span>p<span class="br0">&#91;</span>facet<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#93;</span>.<span class="me1">second</span> <span class="sy2">-</span> p<span class="br0">&#91;</span>facet<span class="br0">&#91;</span>k<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#93;</span>.<span class="me1">second</span><span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>area <span class="sy1">&lt;</span> EPS<span class="br0">&#41;</span>
				... грань является внешней ...
		<span class="br0">&#125;</span></pre><p><p><h2 style="padding-top:40px;">Построение планарного графа</h2><p>Для вышеописанных алгоритмов существенно то, что входной граф является корректно уложенным планарным графом. Однако на практике часто на вход программе подаётся набор отрезков, возможно, пересекающихся между собой в "несанкционированных" точках, и нужно по этим отрезкам построить планарный граф.<p>Реализовать построение планарного графа можно следующим образом. Зафиксируем какой-либо входной отрезок. Теперь пересечём этот отрезок со всеми остальными отрезками. Найденные точки пересечения, а также концы самого отрезка положим в вектор, и его отсортируем стандартным образом (т.е. сначала по одной координате, при равенстве &mdash; по другой). Потом пройдёмся по этому вектору и будет добавлять рёбра между соседними в этом векторе точками (разумеется, следя, чтобы мы не добавили петли). Выполнив этот процесс для всех отрезков, т.е. за <img class=tex src="../tex2png/cache/ef47bd4cb586bcaa0d840195d143a1be.png" alt="O(n^2 \log n)">, мы построим соответствующий планарный граф (в котором будет <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)"> точек).<p>Реализация:<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">double</span> EPS <span class="sy1">=</span> <span class="nu19">1E-9</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">struct</span> point <span class="br0">&#123;</span>
	<span class="kw4">double</span> x, y<span class="sy4">;</span>
	<span class="kw4">bool</span> operator<span class="sy1">&lt;</span> <span class="br0">&#40;</span><span class="kw4">const</span> point <span class="sy3">&amp;</span> p<span class="br0">&#41;</span> <span class="kw4">const</span> <span class="br0">&#123;</span>
		<span class="kw1">return</span> x <span class="sy1">&lt;</span> p.<span class="me1">x</span> <span class="sy2">-</span> EPS <span class="sy3">||</span> <span class="kw3">abs</span> <span class="br0">&#40;</span>x <span class="sy2">-</span> p.<span class="me1">x</span><span class="br0">&#41;</span> <span class="sy1">&lt;</span> EPS <span class="sy3">&amp;&amp;</span> y <span class="sy1">&lt;</span> p.<span class="me1">y</span> <span class="sy2">-</span> EPS<span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
&nbsp;
map<span class="sy1">&lt;</span>point,<span class="kw4">int</span><span class="sy1">&gt;</span> ids<span class="sy4">;</span>
vector<span class="sy1">&lt;</span>point<span class="sy1">&gt;</span> p<span class="sy4">;</span>
vector <span class="sy1">&lt;</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> g<span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> get_point_id <span class="br0">&#40;</span>point pt<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>ids.<span class="me1">count</span><span class="br0">&#40;</span>pt<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		ids<span class="br0">&#91;</span>pt<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>p.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		p.<span class="me1">push_back</span> <span class="br0">&#40;</span>pt<span class="br0">&#41;</span><span class="sy4">;</span>
		g.<span class="me1">resize</span> <span class="br0">&#40;</span>g.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> ids<span class="br0">&#91;</span>p<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> intersect <span class="br0">&#40;</span>pair<span class="sy1">&lt;</span>point,point<span class="sy1">&gt;</span> a, pair<span class="sy1">&lt;</span>point,point<span class="sy1">&gt;</span> b, vector<span class="sy1">&lt;</span>point<span class="sy1">&gt;</span> <span class="sy3">&amp;</span> res<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	... стандартная процедура, пересекает два отрезка a и b и закидывает результат в res ...
	... если отрезки перекрываются, то закидывает те концы, которые попали внутрь первого отрезка ...
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="co1">// входные данные</span>
	<span class="kw4">int</span> m<span class="sy4">;</span>
	vector <span class="sy1">&lt;</span> pair<span class="sy1">&lt;</span>point,point<span class="sy1">&gt;</span> <span class="sy1">&gt;</span> a <span class="br0">&#40;</span>m<span class="br0">&#41;</span><span class="sy4">;</span>
	... чтение ...
&nbsp;
	<span class="co1">// построение графа</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>m<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		vector<span class="sy1">&lt;</span>point<span class="sy1">&gt;</span> cur<span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>m<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			intersect <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span>, a<span class="br0">&#91;</span>j<span class="br0">&#93;</span>, cur<span class="br0">&#41;</span><span class="sy4">;</span>
		sort <span class="br0">&#40;</span>cur.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, cur.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy2">+</span><span class="nu0">1</span><span class="sy1">&lt;</span>cur.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> x <span class="sy1">=</span> get_id <span class="br0">&#40;</span>cur<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span>,  y <span class="sy1">=</span> get_id <span class="br0">&#40;</span>cur<span class="br0">&#91;</span>j<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>x <span class="sy3">!</span><span class="sy1">=</span> y<span class="br0">&#41;</span> <span class="br0">&#123;</span>
				g<span class="br0">&#91;</span>x<span class="br0">&#93;</span>.<span class="me1">push_back</span> <span class="br0">&#40;</span>y<span class="br0">&#41;</span><span class="sy4">;</span>
				g<span class="br0">&#91;</span>y<span class="br0">&#93;</span>.<span class="me1">push_back</span> <span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> g.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="co1">// сортировка по углу и удаление кратных рёбер</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		sort <span class="br0">&#40;</span>g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, cmp_ang <span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">erase</span> <span class="br0">&#40;</span>unique <span class="br0">&#40;</span>g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>, g<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>