<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Быстрое преобразование Фурье за O (N log N). Применение к умножению двух полиномов или длинных чисел</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 19:04<br>редактировано: 9 Nov 2012 12:38</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="fft_multiply.html#" id="contents-hide">[скрыть]</a><a href="fft_multiply.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Быстрое преобразование Фурье за O (N log N). Применение к умножению двух полиномов или длинных чисел </h1><p>Здесь мы рассмотрим алгоритм, который позволяет перемножить два полинома длиной <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> за время <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">, что значительно лучше времени <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)">, достигаемого тривиальным алгоритмом умножения. Очевидно, что умножение двух длинных чисел можно свести к умножению полиномов, поэтому два длинных числа также можно перемножить за время <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">.<p>Изобретение Быстрого преобразования Фурье приписывается Кули (Coolet) и Таки (Tukey) &mdash; 1965 г. На самом деле БПФ неоднократно изобреталось до этого, но важность его в полной мере не осознавалась до появления современных компьютеров. Некоторые исследователи приписывают открытие БПФ Рунге (Runge) и Кёнигу (Konig) в 1924 г. Наконец, открытие этого метода приписывается ещё Гауссу (Gauss) в 1805 г.<p><p><h2 style="padding-top:40px;"> Дискретное преобразование Фурье (ДПФ) </h2><p>Пусть имеется многочлен <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">-ой степени:<p><p class=formula><img class=tex src="../tex2png/cache/6a5901348971c9b68cbb920419e01cd7.png" alt=" A(x) = a_0 x^0 + a_1 x^1 + \ldots + a_{n-1} x^{n-[...]"></p><p>Не теряя общности, можно считать, что <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> является степенью 2. Если в действительности <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> не является степенью 2, то мы просто добавим недостающие коэффициенты, положив их равными нулю.<p>Из теории функций комплексного переменного известно, что комплексных корней <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">-ой степени из единицы существует ровно <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Обозначим эти корни через <img class=tex src="../tex2png/cache/ae0bb0815e9720aafd488db954490afc.png" alt="w_{n,k}, k = 0 \ldots {n-1}">, тогда известно, что <img class=tex src="../tex2png/cache/dc368fcdcf91c93375168100816dc7d8.png" alt="w_{n,k} = e^{ i \frac{ 2 \pi k }{ n } }">. Кроме того, один из этих корней <img class=tex src="../tex2png/cache/8afa65ef8c8ce28b1a86ae9711478925.png" alt="w_n = w_{n,1} = e^{ i \frac{ 2 \pi }{ n } }"> (называемый главным значением корня <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">-ой степени из единицы) таков, что все остальные корни являются его степенями: <img class=tex src="../tex2png/cache/32a5e8ce7ba0b6d2ecffdc5151a5ce58.png" alt="w_{n,k} = (w_n)^k">.<p>Тогда <b>дискретным преобразованием Фурье (ДПФ)</b> (discrete Fourier transform, DFT) многочлена <img class=tex src="../tex2png/cache/bfbf3a2ed6be542e1ef311ffc47b5e24.png" alt="A(x)"> (или, что то же самое, ДПФ вектора его коэффициентов <img class=tex src="../tex2png/cache/2f27cab82e859df79a9fb92a7bb6967f.png" alt="(a_0, a_1, \dots, a_{n-1})">) называются значения этого многочлена в точках <img class=tex src="../tex2png/cache/5f38beb12bf634779989a60db9c48071.png" alt="x = w_{n,k}">, т.е. это вектор:<p><p class=formula><img class=tex src="../tex2png/cache/e3049c4bd26ff715655bbf7c601e862a.png" alt=" {\rm DFT}(a_0, a_1, \ldots, a_{n-1}) = (y_0, y_1,[...]"><br><img class=tex src="../tex2png/cache/ddd77b9ce4f657603a42eac89a13df3d.png" alt=" = (A(w_n^0), A(w_n^1), \ldots, A(w_n^{n-1})). "></p><p>Аналогично определяется и <b>обратное дискретное преобразование Фурье</b> (InverseDFT). Обратное ДПФ для вектора значений многочлена <img class=tex src="../tex2png/cache/a32055f2d229506c925d5641832a6e65.png" alt="(y_0, y_1, \ldots y_{n-1})"> &mdash; это вектор коэффициентов многочлена <img class=tex src="../tex2png/cache/f1110fe4590a21303ba8c627258e377d.png" alt="(a_0, a_1, \ldots, a_{n-1})">:<p><p class=formula><img class=tex src="../tex2png/cache/7faa9281195db956b77f5d4a48ed1b50.png" alt=" {\rm InverseDFT}(y_0, y_1, \ldots, y_{n-1}) = (a_[...]"></p><p>Таким образом, если прямое ДПФ переходит от коэффициентов многочлена к его значениям в комплексных корнях <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">-ой степени из единицы, то обратное ДПФ &mdash; наоборот, по значениям многочлена восстанавливает коэффициенты многочлена.<p><p><h2 style="padding-top:40px;"> Применение ДПФ для быстрого умножения полиномов </h2><p>Пусть даны два многочлена <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> и <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B">. Посчитаем ДПФ для каждого из них: <img class=tex src="../tex2png/cache/8817f4b92fcc74baee6a5301a1bfe514.png" alt="{\rm DFT}(A)"> и <img class=tex src="../tex2png/cache/ab3fe69393e031dba8b0b046a5375fc9.png" alt="{\rm DFT}(B)"> &mdash; это два вектора-значения многочленов.<p>Теперь, что происходит при умножении многочленов? Очевидно, в каждой точке их значения просто перемножаются, т.е.<p><p class=formula><img class=tex src="../tex2png/cache/51493e5c089318550f07c75ecd8ed4a1.png" alt=" (A \times B)(x) = A(x) \times B(x). "></p><p>Но это означает, что если мы перемножим вектора <img class=tex src="../tex2png/cache/8817f4b92fcc74baee6a5301a1bfe514.png" alt="{\rm DFT}(A)"> и <img class=tex src="../tex2png/cache/ab3fe69393e031dba8b0b046a5375fc9.png" alt="{\rm DFT}(B)">, просто умножив каждый элемент одного вектора на соответствующий ему элемент другого вектора, то мы получим не что иное, как ДПФ от многочлена <img class=tex src="../tex2png/cache/843e52c900eb5c2dea54f40be87a141c.png" alt="A \times B">:<p><p class=formula><img class=tex src="../tex2png/cache/602db1c065ff7cd0c78001b0c4e11453.png" alt=" {\rm DFT} (A \times B) = {\rm DFT} (A) \times {\r[...]"></p><p>Наконец, применяя обратное ДПФ, получаем:<p><p class=formula><img class=tex src="../tex2png/cache/a98523e9d12a30717674997fb4397a93.png" alt=" A \times B = {\rm InverseDFT}( {\rm DFT} (A) \tim[...]"></p><p>где, повторимся, справа под произведением двух ДПФ понимается попарные произведения элементов векторов. Такое произведение, очевидно, требует для вычисления только <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> операций. Таким образом, если мы научимся вычислять ДПФ и обратное ДПФ за время <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">, то и произведение двух полиномов (а, следовательно, и двух длинных чисел) мы сможем найти за ту же асимптотику.<p>Следует заметить, что, во-первых, два многочлена следует привести к одной степени (просто дополнив коэффициенты одного из них нулями). Во-вторых, в результате произведения двух многочленов степени <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> получается многочлен степени <img class=tex src="../tex2png/cache/072e6ac03ecf104f2cadad60066d7d36.png" alt="2n-1">, поэтому, чтобы результат получился корректным, предварительно нужно удвоить степени каждого многочлена (опять же, дополнив их нулевыми коэффициентами).<p><p><h2 style="padding-top:40px;"> Быстрое преобразование Фурье </h2><p><b>Быстрое преобразование Фурье</b> (fast Fourier transform) &mdash; это метод, позволяющий вычислять ДПФ за время <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">. Этот метод основывается на свойствах комплексных корней из единицы (а именно, на том, что степени одних корней дают другие корни).<p>Основная идея БПФ заключается в разделении вектора коэффициентов на два вектора, рекурсивном вычислении ДПФ для них, и объединении результатов в одно БПФ.<p>Итак, пусть имеется многочлен <img class=tex src="../tex2png/cache/bfbf3a2ed6be542e1ef311ffc47b5e24.png" alt="A(x)"> степени <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, где <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> &mdash; степень двойки, и <img class=tex src="../tex2png/cache/40452ebc2b7f250462dd96af60521c95.png" alt="n>1">:<p><p class=formula><img class=tex src="../tex2png/cache/6a5901348971c9b68cbb920419e01cd7.png" alt=" A(x) = a_0 x^0 + a_1 x^1 + \ldots + a_{n-1} x^{n-[...]"></p><p>Разделим его на два многочлена, один &mdash; с чётными, а другой &mdash; с нечётными коэффициентами:<p><p class=formula><img class=tex src="../tex2png/cache/5b804433ddd32ab8801df0b86d1e0df6.png" alt=" A_0(x) = a_0 x^0 + a_2 x^1 + \ldots + a_{n-2} x^{[...]"><br><img class=tex src="../tex2png/cache/dd58af595538c6c0daacf3b8a061bf32.png" alt=" A_1(x) = a_1 x^0 + a_3 x^1 + \ldots + a_{n-1} x^{[...]"></p><p>Нетрудно убедиться, что:<p><p class=formula><img class=tex src="../tex2png/cache/ff0caed19983dbeb83f90d4b21fd3b1f.png" alt=" A(x) = A_0(x^2) + x A_1(x^2). ~~~~~~~(1) "></p><p>Многочлены <img class=tex src="../tex2png/cache/a2a21e36fabe6b4c4ee8a23807c47d78.png" alt="A_0"> и <img class=tex src="../tex2png/cache/cbf522547b41e347e97ce35c1ff8868b.png" alt="A_1"> имеют вдвое меньшую степень, чем многочлен <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A">. Если мы сможем за линейное время по вычисленным <img class=tex src="../tex2png/cache/06b525a533ef0a434f9c9dcbffb3e847.png" alt="{\rm DFT}(A_0)"> и <img class=tex src="../tex2png/cache/08f78588dccac67ee8e29a01ce58a2ec.png" alt="{\rm DFT}(A_1)"> вычислить <img class=tex src="../tex2png/cache/8817f4b92fcc74baee6a5301a1bfe514.png" alt="{\rm DFT}(A)">, то мы и получим искомый алгоритм быстрого преобразования Фурье (т.к. это стандартная схема алгоритма "разделяй и властвуй", и для неё известна асимптотическая оценка <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">).<p>Итак, пусть мы имеем вычисленные вектора <img class=tex src="../tex2png/cache/d668973caa5f4f8defcd67e6e0d40755.png" alt="\{ y_k^0 \}_{k=0}^{n/2-1} = {\rm DFT}(A_0)"> и <img class=tex src="../tex2png/cache/fdea6d6006054cb35de613d583f40b31.png" alt="\{ y_k^1 \}_{k=0}^{n/2-1} = {\rm DFT}(A_1)">. Найдём выражения для <img class=tex src="../tex2png/cache/18c5b5d6a4e7a567dc5331ce74d92886.png" alt="\{ y_k \}_{k=0}^{n-1} = {\rm DFT}(A)">.<p>Во-первых, вспоминая (1), мы сразу получаем значения для первой половины коэффициентов:<p><p class=formula><img class=tex src="../tex2png/cache/2f6d61e44ea21c2ba95b023c513af4b7.png" alt=" y_k = y_k^0 + w_n^k y_k^1, ~~~~k = 0 \ldots n/2-1[...]"></p><p>Для второй половины коэффициентов после преобразований также получаем простую формулу:<p><p class=formula><img class=tex src="../tex2png/cache/a56e5dc055fc96ced1531419311416c1.png" alt=" y_{k+n/2} = A(w_n^{k+n/2}) = A_0(w_n^{2k+n}) + w_[...]"><br><img class=tex src="../tex2png/cache/321b8a486b2d89963b5c9d11e7b6f8ce.png" alt=" = A_0(w_n^{2k}) - w_n^k A_1(w_n^{2k}) = y_k^0 - w[...]"></p><p>(Здесь мы воспользовались (1), а также тождествами <img class=tex src="../tex2png/cache/881ca23330d9e4d651c116dd154f3748.png" alt="w_n^n = 1">, <img class=tex src="../tex2png/cache/e55ff0206822dc65547b211cc2c200c2.png" alt="w_n^{n/2} = -1">.)<p>Итак, в результате мы получили формулы для вычисления всего вектора <img class=tex src="../tex2png/cache/3fb0039dd19d9bf8cded34b4c935f724.png" alt="\{ y_k \}">:<p><p class=formula><img class=tex src="../tex2png/cache/040823e5aa878991074cef09c28cbcc4.png" alt=" y_k = y_k^0 + w_n^k y_k^1, \ \ \ \ k = 0 \ldots n[...]"><br><img class=tex src="../tex2png/cache/52f6ad5dc4ea216a05ab0fdcf42fea94.png" alt=" y_{k+n/2} = y_k^0 - w_n^k y_k^1, \ \ \ \ k = 0 \l[...]"></p><p>(эти формулы, т.е. две формулы вида <img class=tex src="../tex2png/cache/d239542aeb46cc04bda21c01dc8a21ec.png" alt="a+bc"> и <img class=tex src="../tex2png/cache/064f5c1480977040b3ca966433c576d3.png" alt="a-bc">, иногда называют "преобразование бабочки" ("butterfly operation"))<p>Тем самым, мы окончательно построили алгоритм БПФ.<p><p><h2 style="padding-top:40px;"> Обратное БПФ </h2><p>Итак, пусть дан вектор <img class=tex src="../tex2png/cache/5705597992b789ba6aa7f68851575d92.png" alt="(y_0, y_1, \ldots, y_{n-1})"> &mdash; значения многочлена <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> степени <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> в точках <img class=tex src="../tex2png/cache/32b7839b46ba4ff3051d1e6c0fc38050.png" alt="x = w_n^k">. Требуется восстановить коэффициенты <img class=tex src="../tex2png/cache/f1110fe4590a21303ba8c627258e377d.png" alt="(a_0, a_1, \ldots, a_{n-1})"> многочлена. Эта известная задача называется <b>интерполяцией</b>, для этой задачи есть и общие алгоритмы решения, однако в данном случае будет получен очень простой алгоритм (простой тем, что он практически не отличается от прямого БПФ).<p>ДПФ мы можем записать, согласно его определению, в матричном виде:<p><p class=formula><img class=tex src="../tex2png/cache/b55df3e3ca59f857d8cb3d60aebdee4e.png" alt=" \pmatrix{ w_n^0 & w_n^0 & w_n^0 & w_n^0 & \cdots [...]"></p><p>Тогда вектор <img class=tex src="../tex2png/cache/f1110fe4590a21303ba8c627258e377d.png" alt="(a_0, a_1, \ldots, a_{n-1})"> можно найти, умножив вектор <img class=tex src="../tex2png/cache/5705597992b789ba6aa7f68851575d92.png" alt="(y_0, y_1, \ldots, y_{n-1})"> на обратную матрицу к матрице, стоящей слева (которая, кстати, называется матрицей Вандермонда):<p><p class=formula><img class=tex src="../tex2png/cache/a2423a3d733522b775e18632a4dbe74d.png" alt=" \pmatrix{ a_0 \cr a_1 \cr a_2 \cr a_3 \cr \vdots [...]"></p><p>Непосредственной проверкой можно убедиться в том, что эта обратная матрица такова:<p><p class=formula><img class=tex src="../tex2png/cache/436ce57811714289fc98a5f9502fa35b.png" alt=" \frac{1}{n} \pmatrix{ w_n^0 & w_n^0 & w_n^0 & w_n[...]"></p><p>Таким образом, получаем формулу:<p><p class=formula><img class=tex src="../tex2png/cache/2e40264ef544517ae369e48475c42615.png" alt=" a_k = \frac{1}{n} \sum_{j=0}^{n-1} y_j w_n^{-kj}.[...]"></p><p>Сравнивая её с формулой для <img class=tex src="../tex2png/cache/134a7d3afcf0f1246e5e9b3af50ba87b.png" alt="y_k">:<p><p class=formula><img class=tex src="../tex2png/cache/f768653457b54c5fb971b44486468e81.png" alt=" y_k = \sum_{j=0}^{n-1} a_j w_n^{kj}, "></p><p>мы замечаем, что эти две задачи почти ничем не отличаются, поэтому коэффициенты <img class=tex src="../tex2png/cache/f74cd5e7479be5ae104fef83192347a1.png" alt="a_k"> можно находить таким же алгоритмом "разделяй и властвуй", как и прямое БПФ, только вместо <img class=tex src="../tex2png/cache/0761653b7b8ed54ddce7240e4572145d.png" alt="w_n^k"> везде надо использовать <img class=tex src="../tex2png/cache/538de2f61b798f389f48b21ae2b3eada.png" alt="w_n^{-k}">, а каждый элемент результата надо разделить на <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">.<p>Таким образом, вычисление обратного ДПФ почти не отличается от вычисления прямого ДПФ, и его также можно выполнять за время <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">.<p><p><h2 style="padding-top:40px;"> Реализация </h2><p>Рассмотрим простую рекурсивную <b>реализацию БПФ</b> и обратного БПФ, реализуем их в виде одной функции, поскольку различия между прямым и обратным БПФ минимальны. Для хранения комплексных чисел воспользуемся стандартным в C++ STL типом complex (определённым в заголовочном файле &lt;complex>).<p><pre class="notranslate cpp"><span class="kw4">typedef</span> complex<span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span> base<span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> fft <span class="br0">&#40;</span>vector<span class="sy1">&lt;</span>base<span class="sy1">&gt;</span> <span class="sy3">&amp;</span> a, <span class="kw4">bool</span> invert<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>n <span class="sy1">==</span> <span class="nu0">1</span><span class="br0">&#41;</span>  <span class="kw1">return</span><span class="sy4">;</span>
&nbsp;
	vector<span class="sy1">&lt;</span>base<span class="sy1">&gt;</span> a0 <span class="br0">&#40;</span>n<span class="sy2">/</span><span class="nu0">2</span><span class="br0">&#41;</span>,  a1 <span class="br0">&#40;</span>n<span class="sy2">/</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span>, j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">+</span><span class="sy1">=</span><span class="nu0">2</span>, <span class="sy2">++</span>j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		a0<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		a1<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	fft <span class="br0">&#40;</span>a0, invert<span class="br0">&#41;</span><span class="sy4">;</span>
	fft <span class="br0">&#40;</span>a1, invert<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw4">double</span> ang <span class="sy1">=</span> <span class="nu0">2</span><span class="sy2">*</span>PI<span class="sy2">/</span>n <span class="sy2">*</span> <span class="br0">&#40;</span>invert <span class="sy4">?</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy4">:</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	base w <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span>,  wn <span class="br0">&#40;</span><span class="kw3">cos</span><span class="br0">&#40;</span>ang<span class="br0">&#41;</span>, <span class="kw3">sin</span><span class="br0">&#40;</span>ang<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy2">/</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> a0<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">+</span> w <span class="sy2">*</span> a1<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		a<span class="br0">&#91;</span>i<span class="sy2">+</span>n<span class="sy2">/</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy1">=</span> a0<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">-</span> w <span class="sy2">*</span> a1<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>invert<span class="br0">&#41;</span>
			a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">/</span><span class="sy1">=</span> <span class="nu0">2</span>,  a<span class="br0">&#91;</span>i<span class="sy2">+</span>n<span class="sy2">/</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy2">/</span><span class="sy1">=</span> <span class="nu0">2</span><span class="sy4">;</span>
		w <span class="sy2">*</span><span class="sy1">=</span> wn<span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>В аргумент <img class=tex src="../tex2png/cache/bf8b70d760786cee9c0906bcf01cf666.png" alt="\rm a"> функции передаётся входной вектор коэффициентов, в нём же и будет содержаться результат. Аргумент <img class=tex src="../tex2png/cache/55b7ec4ceabb3769220549936beba27f.png" alt="\rm invert"> показывает, прямое или обратное ДПФ следует вычислить. Внутри функции сначала проверяется, что если длина вектора <img class=tex src="../tex2png/cache/bf8b70d760786cee9c0906bcf01cf666.png" alt="\rm a"> равна единице, то ничего делать не надо - он сам и является ответом. Иначе вектор <img class=tex src="../tex2png/cache/bf8b70d760786cee9c0906bcf01cf666.png" alt="\rm a"> разделяется на два вектора <img class=tex src="../tex2png/cache/9d6d876f7afec666a89e210f108d9620.png" alt="\rm a0"> и <img class=tex src="../tex2png/cache/2b4c651910283fed8824668a51b71471.png" alt="\rm a1">, для которых рекурсивно вычисляется ДПФ. Затем вычисляется величина <img class=tex src="../tex2png/cache/f12b737c8c65734e041f13f902fce36a.png" alt="w_n">, и заводится переменная <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">, содержащая текущую степень <img class=tex src="../tex2png/cache/f12b737c8c65734e041f13f902fce36a.png" alt="w_n">. Затем вычисляются элементы результирующего ДПФ по вышеописанным формулам.<p>Если указан флаг <img class=tex src="../tex2png/cache/a3b410c91e279644c05e4033253073b2.png" alt="\rm invert = true">, то <img class=tex src="../tex2png/cache/f12b737c8c65734e041f13f902fce36a.png" alt="w_n"> заменяется на <img class=tex src="../tex2png/cache/e42ff37eaeded937d425915bec3785f4.png" alt="w_n^{-1}">, а каждый элемент результата делится на 2 (учитывая, что эти деления на 2 произойдут в каждом уровне рекурсии, то в итоге как раз получится, что все элементы поделятся на <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">).<p>Тогда функция для <b>перемножения двух многочленов</b> будет выглядеть следующим образом:<p><pre class="notranslate cpp"><span class="kw4">void</span> multiply <span class="br0">&#40;</span><span class="kw4">const</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> a, <span class="kw4">const</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> b, vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> res<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	vector<span class="sy1">&lt;</span>base<span class="sy1">&gt;</span> fa <span class="br0">&#40;</span>a.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, a.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>,  fb <span class="br0">&#40;</span>b.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, b.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw4">size_t</span> n <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>n <span class="sy1">&lt;</span> max <span class="br0">&#40;</span>a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, b.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>  n <span class="sy1">&lt;&lt;=</span> <span class="nu0">1</span><span class="sy4">;</span>
	n <span class="sy1">&lt;&lt;=</span> <span class="nu0">1</span><span class="sy4">;</span>
	fa.<span class="me1">resize</span> <span class="br0">&#40;</span>n<span class="br0">&#41;</span>,  fb.<span class="me1">resize</span> <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	fft <span class="br0">&#40;</span>fa, <span class="kw2">false</span><span class="br0">&#41;</span>,  fft <span class="br0">&#40;</span>fb, <span class="kw2">false</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		fa<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">*</span><span class="sy1">=</span> fb<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
	fft <span class="br0">&#40;</span>fa, <span class="kw2">true</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	res.<span class="me1">resize</span> <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		res<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>fa<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">real</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy2">+</span> <span class="nu16">0.5</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Эта функция работает с многочленами с целочисленными коэффициентами (хотя, понятно, теоретически ничто не мешает ей работать и с дробными коэффициентами). Однако здесь проявляется проблема большой погрешности при вычислении ДПФ: погрешность может оказаться значительной, поэтому округлять числа лучше самым надёжным способом &mdash; прибавлением 0.5 и последующим округлением вниз (<b>внимание</b>: это будет работать неправильно для отрицательных чисел, если таковые могут появиться в вашем применении).<p>Наконец, функция для <b>перемножения двух длинных чисел</b> практически ничем не отличается от функции для перемножения многочленов. Единственная особенность &mdash; что после выполнения умножения чисел как многочлены их следует нормализовать, т.е. выполнить все переносы разрядов:<p><pre class="notranslate cpp">	<span class="kw4">int</span> carry <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		res<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> carry<span class="sy4">;</span>
		carry <span class="sy1">=</span> res<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">/</span> <span class="nu0">10</span><span class="sy4">;</span>
		res<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">%</span><span class="sy1">=</span> <span class="nu0">10</span><span class="sy4">;</span>
	<span class="br0">&#125;</span></pre><p>(Поскольку длина произведения двух чисел никогда не превзойдёт суммарной длины чисел, то размера вектора <img class=tex src="../tex2png/cache/085b69d1bd01278654eebf737d429b9a.png" alt="\rm res"> хватит, чтобы выполнить все переносы.)<p><p><h2 style="padding-top:40px;"> Улучшенная реализация: вычисления "на месте" без дополнительной памяти </h2><p>Для увеличения эффективности откажемся от рекурсии в явном виде. В приведённой выше рекурсивной реализации мы явно разделяли вектор <img class=tex src="../tex2png/cache/bf8b70d760786cee9c0906bcf01cf666.png" alt="\rm a"> на два вектора &mdash; элементы на чётных позициях отнесли к одному временно созданному вектору, а на нечётных &mdash; к другому. Однако, если бы мы переупорядочили элементы определённым образом, то необходимость в создании временных векторов тогда бы отпала (т.е. все вычисления мы могли бы производить "на месте", прямо в самом векторе <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">).<p>Заметим, что на первом уровне рекурсии элементы, младшие (первые) биты позиций которых равны нулю, относятся к вектору <img class=tex src="../tex2png/cache/f356b4e4422ce4fce9cd16686f0ca8ef.png" alt="a_0">, а младшие биты позиций которых равны единице &mdash; к вектору <img class=tex src="../tex2png/cache/72c05ff251132298d5760955158f1052.png" alt="a_1">. На втором уровне рекурсии выполняется то же самое, но уже для вторых битов, и т.д. Поэтому если мы в позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> каждого элемента <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]"> инвертируем порядок битов, и переупорядочим элементы массива <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> в соответствии с новыми индексами, то мы и получим искомый порядок (он называется <b>поразрядно обратной перестановкой</b> (bit-reversal permutation)).<p>Например, для <img class=tex src="../tex2png/cache/1773f914f4444e282c8f936249b6edb9.png" alt="n=8"> этот порядок имеет вид:<p><p class=formula><img class=tex src="../tex2png/cache/64d2b150180449b21a63ef4fe93b646f.png" alt=" a = \biggl\{ \Bigl[ (a_0,a_4), (a_2, a_6) \Bigr] [...]"></p><p>Действительно, на первом уровне рекурсии (окружено фигурными скобками) обычного рекурсивного алгоритма происходит разделение вектора на две части: <img class=tex src="../tex2png/cache/46746c25c4cce21e8001214cccce7a53.png" alt="[a_0,a_2,a_4,a_6]"> и <img class=tex src="../tex2png/cache/150638cbc6a10b0083affd00b788daac.png" alt="[a_1,a_3,a_5,a_7]">. Как мы видим, в поразрядно обратной перестановке этому соответствует просто разделение вектора на две половинки: первые <img class=tex src="../tex2png/cache/48b1c5206b1d914c2ec894c9078c06ca.png" alt="n/2"> элементов, и последние <img class=tex src="../tex2png/cache/48b1c5206b1d914c2ec894c9078c06ca.png" alt="n/2"> элементов. Затем происходит рекурсивный вызов от каждой половинки; пусть результирующее ДПФ от каждой из них было возвращено на месте самих элементов (т.е. в первой и второй половинах вектора <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> соответственно):<p><p class=formula><img class=tex src="../tex2png/cache/5d71a8ccf515388c91ae4c988a55ac37.png" alt=" a = \biggl\{ \Bigl[ y_0^0,\ y_1^0,\ y_2^0,\ y_3^0[...]"></p><p>Теперь нам надо выполнить объединение двух ДПФ в одно для всего вектора. Но элементы встали так удачно, что и объединение можно выполнить прямо в этом массиве. Действительно, возьмём элементы <img class=tex src="../tex2png/cache/848d90a7136f50999e99e8606d3a27eb.png" alt="y_0^0"> и <img class=tex src="../tex2png/cache/b0a3837fb349b723518cc8389f5dfe79.png" alt="y_0^1">, применим к ним преобразование бабочки, и результат поставим на их месте &mdash; и это место и окажется тем самым, которое и должно было получиться:<p><p class=formula><img class=tex src="../tex2png/cache/c8dd2788449848cb4ffc2ba85317a264.png" alt=" a = \biggl\{ \Bigl[ y_0^0+w_n^0y_0^1,\ y_1^0,\ y_[...]"></p><p>Аналогично, применяем преобразование бабочки к <img class=tex src="../tex2png/cache/2b7fd2de2a85f89064f84383b9414437.png" alt="y_1^0"> и <img class=tex src="../tex2png/cache/f1a53d88dbafd8315a52d6333951f816.png" alt="y_1^1"> и результат ставим на их место, и т.д. В итоге получаем:<p><p class=formula><img class=tex src="../tex2png/cache/1178444e053e39067b1b5900f9780e04.png" alt=" a = \biggl\{ \Bigl[ y_0^0+w_n^0y_0^1,\ y_1^0+w_n^[...]"><br><img class=tex src="../tex2png/cache/9f0332cff11837832089ba53fb0c833f.png" alt=" ~~~~~~~~ \Bigl[ y_0^0-w_n^0y_0^1,\ y_1^0-w_n^1y_1[...]"></p><p>Т.е. мы получили именно искомое ДПФ от вектора <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">.<p>Мы описали процесс вычисления ДПФ на первом уровне рекурсии, но понятно, что те же самые рассуждения верны и для всех остальных уровней рекурсии. Таким образом, <b>после применения поразрядно обратной перестановки вычислять ДПФ можно на месте</b>, без привлечения дополнительных массивов.<p>Но теперь можно <b>избавиться и от рекурсии</b> в явном виде. Итак, мы применили поразрядно обратную перестановку элементов. Теперь выполним всю работу, выполняемую нижним уровнем рекурсии, т.е. вектор <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> разделим на пары элементов, для каждого применим преобразование бабочки, в результате в векторе <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> будут находиться результаты работы нижнего уровня рекурсии. На следующем шаге разделим вектор <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> на четвёрки элементов, к каждой применим преобразование бабочки, в результате получим ДПФ для каждой четвёрки. И так далее, наконец, на последнем шаге мы, получив результаты ДПФ для двух половинок вектора <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, применим к ним преобразование бабочки и получим ДПФ для всего вектора <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">.<p>Итак, реализация:<p><pre class="notranslate cpp"><span class="kw4">typedef</span> complex<span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span> base<span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> rev <span class="br0">&#40;</span><span class="kw4">int</span> num, <span class="kw4">int</span> lg_n<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> res <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>lg_n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>num <span class="sy3">&amp;</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>i<span class="br0">&#41;</span><span class="br0">&#41;</span>
			res <span class="sy3">|</span><span class="sy1">=</span> <span class="nu0">1</span><span class="sy1">&lt;&lt;</span><span class="br0">&#40;</span>lg_n<span class="sy2">-</span><span class="nu0">1</span><span class="sy2">-</span>i<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">return</span> res<span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> fft <span class="br0">&#40;</span>vector<span class="sy1">&lt;</span>base<span class="sy1">&gt;</span> <span class="sy3">&amp;</span> a, <span class="kw4">bool</span> invert<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw4">int</span> lg_n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="nu0">1</span> <span class="sy1">&lt;&lt;</span> lg_n<span class="br0">&#41;</span> <span class="sy1">&lt;</span> n<span class="br0">&#41;</span>  <span class="sy2">++</span>lg_n<span class="sy4">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy1">&lt;</span> rev<span class="br0">&#40;</span>i,lg_n<span class="br0">&#41;</span><span class="br0">&#41;</span>
			swap <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span>, a<span class="br0">&#91;</span>rev<span class="br0">&#40;</span>i,lg_n<span class="br0">&#41;</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> len<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> len<span class="sy1">&lt;=</span>n<span class="sy4">;</span> len<span class="sy1">&lt;&lt;=</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">double</span> ang <span class="sy1">=</span> <span class="nu0">2</span><span class="sy2">*</span>PI<span class="sy2">/</span>len <span class="sy2">*</span> <span class="br0">&#40;</span>invert <span class="sy4">?</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy4">:</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
		base wlen <span class="br0">&#40;</span><span class="kw3">cos</span><span class="br0">&#40;</span>ang<span class="br0">&#41;</span>, <span class="kw3">sin</span><span class="br0">&#40;</span>ang<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">+</span><span class="sy1">=</span>len<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			base w <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
				base u <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="br0">&#93;</span>,  v <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="sy2">+</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy2">*</span> w<span class="sy4">;</span>
				a<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> u <span class="sy2">+</span> v<span class="sy4">;</span>
				a<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="sy2">+</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy1">=</span> u <span class="sy2">-</span> v<span class="sy4">;</span>
				w <span class="sy2">*</span><span class="sy1">=</span> wlen<span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>invert<span class="br0">&#41;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">/</span><span class="sy1">=</span> n<span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;</pre><p>Вначале к вектору <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> применяется поразрядно обратная перестановка, для чего вычисляется количество значащих бит (<img class=tex src="../tex2png/cache/5c4ea7d0a9d2f455c81228570ea1bdf1.png" alt="\rm lg\_n">) в числе <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, и для каждой позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> находится соответствующая ей позиция, битовая запись которой есть битовая запись числа <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, записанная в обратном порядке. Если получившаяся в результате позиция оказалась больше <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, то элементы в этих двух позициях надо обменять (если не это условие, то каждая пара обменяется дважды, и в итоге ничего не произойдёт).<p>Затем выполняется <img class=tex src="../tex2png/cache/23176441ed4c7dcbd41a23de28abea36.png" alt="\lg n - 1"> стадий алгоритма, на <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ой из которых (<img class=tex src="../tex2png/cache/7da079f1920effd7e8802d7f3cb8e481.png" alt="k=2 \ldots \lg n">) вычисляются ДПФ для блоков длины <img class=tex src="../tex2png/cache/a631b6ee74bdfc6711813da7ca95a648.png" alt="2^k">. Для всех этих блоков будет одно и то же значение первообразного корня <img class=tex src="../tex2png/cache/9a7bfc843a91062f48df6a61cc049563.png" alt="w_{2^k}">, которое и запоминается в переменной <img class=tex src="../tex2png/cache/867b01a3802da1e476dc7a7743d664d2.png" alt="\rm wlen">. Цикл по <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> итерируется по блокам, а вложенный в него цикл по <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> применяет преобразование бабочки ко всем элементам блока.<p>Можно выполнить дальнейшую <b>оптимизацию реверса битов</b>. В предыдущей реализации мы явно проходили по всем битам числа, попутно строя поразрядно инвертированное число. Однако реверс битов можно выполнять и по-другому.<p>Например, пусть <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> &mdash; уже подсчитанное число, равное обратной перестановке битов числа <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">. Тогда, при переходе к следующему числу <img class=tex src="../tex2png/cache/4ec332d2c63d7695c3b676e8e6dd9881.png" alt="i+1"> мы должны и к числу <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> прибавить единицу, но прибавить её в такой "инвертированной" системе счисления. В обычной двоичной системе счисления прибавить единицу &mdash; значит удалить все единицы, стоящие на конце числа (т.е. группу младших единиц), а перед ними поставить единицу. Соответственно, в "инвертированной" системе мы должны идти по битам числа, начиная со старших, и пока там стоят единицы, удалять их и переходить к следующему биту; когда же встретится первый нулевой бит, поставить в него единицу и остановиться.<p>Итак, получаем такую реализацию:<p><pre class="notranslate cpp"><span class="kw4">typedef</span> complex<span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span> base<span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> fft <span class="br0">&#40;</span>vector<span class="sy1">&lt;</span>base<span class="sy1">&gt;</span> <span class="sy3">&amp;</span> a, <span class="kw4">bool</span> invert<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span>, j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> bit <span class="sy1">=</span> n <span class="sy1">&gt;&gt;</span> <span class="nu0">1</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;</span> j<span class="sy1">&gt;=</span>bit<span class="sy4">;</span> bit<span class="sy1">&gt;&gt;=</span><span class="nu0">1</span><span class="br0">&#41;</span>
			j <span class="sy2">-</span><span class="sy1">=</span> bit<span class="sy4">;</span>
		j <span class="sy2">+</span><span class="sy1">=</span> bit<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy1">&lt;</span> j<span class="br0">&#41;</span>
			swap <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span>, a<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> len<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> len<span class="sy1">&lt;=</span>n<span class="sy4">;</span> len<span class="sy1">&lt;&lt;=</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">double</span> ang <span class="sy1">=</span> <span class="nu0">2</span><span class="sy2">*</span>PI<span class="sy2">/</span>len <span class="sy2">*</span> <span class="br0">&#40;</span>invert <span class="sy4">?</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy4">:</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
		base wlen <span class="br0">&#40;</span><span class="kw3">cos</span><span class="br0">&#40;</span>ang<span class="br0">&#41;</span>, <span class="kw3">sin</span><span class="br0">&#40;</span>ang<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">+</span><span class="sy1">=</span>len<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			base w <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
				base u <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="br0">&#93;</span>,  v <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="sy2">+</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy2">*</span> w<span class="sy4">;</span>
				a<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> u <span class="sy2">+</span> v<span class="sy4">;</span>
				a<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="sy2">+</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy1">=</span> u <span class="sy2">-</span> v<span class="sy4">;</span>
				w <span class="sy2">*</span><span class="sy1">=</span> wlen<span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>invert<span class="br0">&#41;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">/</span><span class="sy1">=</span> n<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h2 style="padding-top:40px;"> Дополнительные оптимизации </h2><p>Приведём также список других оптимизаций, которые в совокупности позволяют заметно ускорить приведённую выше "улучшенную" реализацию:<p><ul><p><li><b>Предпосчитать реверс битов</b> для всех чисел в некоторой глобальной таблице. Особенно легко это, когда размер <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> при всех вызовах одинаков.<p>Эта оптимизация становится заметной при большом количестве вызовов <img class=tex src="../tex2png/cache/d6c92bc69cebabac3eadda2d0cf0053f.png" alt="fft()">. Впрочем, эффект от неё можно заметить даже при трёх вызовах (три вызова &mdash; наиболее распространённая ситуация, т.е. когда требуется один раз перемножить два многочлена).<p><li>Отказаться от использования <img class=tex src="../tex2png/cache/34f8b10596e5ad6a9b0d89adee5103d1.png" alt="\rm vector"> (<b>перейти на обычные массивы</b>).<p>Эффект от этого зависит от конкретного компилятора, однако обычно он присутствует и составляет примерно 10%-20%.<p><li>Предпосчитать <b>все степени</b> числа <img class=tex src="../tex2png/cache/986001e31b752a6225d355b07eb01fb1.png" alt="wlen">. В самом деле, в этом цикле алгоритма раз за разом производится проход по всем степеням числа <img class=tex src="../tex2png/cache/986001e31b752a6225d355b07eb01fb1.png" alt="wlen"> от <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0"> до <img class=tex src="../tex2png/cache/c5d5c263e97733d7b240423537f05d37.png" alt="len/2-1">:<p><pre class="notranslate cpp">		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">+</span><span class="sy1">=</span>len<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			base w <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
				<span class="br0">&#91;</span>...<span class="br0">&#93;</span>
				w <span class="sy2">*</span><span class="sy1">=</span> wlen<span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span></pre><p>Соответственно, перед этим циклом мы можем предпосчитать в некотором массиве все требуемые степени, и избавиться тем самым от лишних умножений во вложенном цикле.<p>Ориентировочное ускорение &mdash; 5-10%.<p><li>Избавиться от <b>обращений к массивам по индексам</b>, использовать вместо этого указатели на текущие элементы массивов, продвигая их на 1 вправо на каждой итерации.<p>На первый взгляд, оптимизирующие компиляторы должны быть способны самостоятельно справиться с этим, однако на практике оказывается, что замена обращений к массивам <img class=tex src="../tex2png/cache/ad9dc6bfe8abaec4ab385419457c3a6e.png" alt="a[i+j]"> и <img class=tex src="../tex2png/cache/1db09b2df88a0ce1245e3f6ab3447d3f.png" alt="a[i+j+len/2]"> на указатели ускоряет программу в распространённых компиляторах. Выигрыш составляет 5-10%.<p><li><b>Отказаться от стандартного типа комплексных чисел</b> <img class=tex src="../tex2png/cache/2a3e1e044ef99df5524ab2c5d81444f8.png" alt="\rm complex">, переписав его на собственную реализацию.<p>Опять же, это может показаться удивительным, но даже в современных компиляторах выигрыш от такого переписывания может составлять до нескольких десятков процентов! Это косвенно подтверждает расхожее утверждение, что компиляторы хуже справляются с шаблонными типами данных, оптимизируя работу с ними гораздо хуже, чем с не-шаблонными типами.<p><li>Другой полезной оптимизацией является <b>отсечение по длине</b>: когда длина рабочего блока становится маленькой (скажем, 4), вычислять ДПФ для него "вручную". Если расписать эти случаи в виде явных формул при длине, равной <img class=tex src="../tex2png/cache/2f54b964e9395dd3e3900f753a28af80.png" alt="4/2">, то значения синусов-косинусов примут целочисленные значения, за счёт чего можно получить прирост скорости ещё на несколько десятков процентов.<p></ul><p>Приведём здесь реализацию с описанными улучшениями (за исключением двух последних пунктов, которые приводят к чрезмерному разрастанию кода):<p><pre class="notranslate cpp"><span class="kw4">int</span> rev<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
base wlen_pw<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> fft <span class="br0">&#40;</span>base a<span class="br0">&#91;</span><span class="br0">&#93;</span>, <span class="kw4">int</span> n, <span class="kw4">bool</span> invert<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy1">&lt;</span> rev<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>
			swap <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span>, a<span class="br0">&#91;</span>rev<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> len<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> len<span class="sy1">&lt;=</span>n<span class="sy4">;</span> len<span class="sy1">&lt;&lt;=</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">double</span> ang <span class="sy1">=</span> <span class="nu0">2</span><span class="sy2">*</span>PI<span class="sy2">/</span>len <span class="sy2">*</span> <span class="br0">&#40;</span>invert<span class="sy4">?</span><span class="sy2">-</span><span class="nu0">1</span><span class="sy4">:</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw4">int</span> len2 <span class="sy1">=</span> len<span class="sy1">&gt;&gt;</span><span class="nu0">1</span><span class="sy4">;</span>
&nbsp;
		base wlen <span class="br0">&#40;</span><span class="kw3">cos</span><span class="br0">&#40;</span>ang<span class="br0">&#41;</span>, <span class="kw3">sin</span><span class="br0">&#40;</span>ang<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		wlen_pw<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy1">=</span> base <span class="br0">&#40;</span><span class="nu0">1</span>, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>len2<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			wlen_pw<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> wlen_pw<span class="br0">&#91;</span>i<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy2">*</span> wlen<span class="sy4">;</span>
&nbsp;
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">+</span><span class="sy1">=</span>len<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			base t,
				<span class="sy2">*</span>pu <span class="sy1">=</span> a<span class="sy2">+</span>i,
				<span class="sy2">*</span>pv <span class="sy1">=</span> a<span class="sy2">+</span>i<span class="sy2">+</span>len2, 
				<span class="sy2">*</span>pu_end <span class="sy1">=</span> a<span class="sy2">+</span>i<span class="sy2">+</span>len2,
				<span class="sy2">*</span>pw <span class="sy1">=</span> wlen_pw<span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;</span> pu<span class="sy3">!</span><span class="sy1">=</span>pu_end<span class="sy4">;</span> <span class="sy2">++</span>pu, <span class="sy2">++</span>pv, <span class="sy2">++</span>pw<span class="br0">&#41;</span> <span class="br0">&#123;</span>
				t <span class="sy1">=</span> <span class="sy2">*</span>pv <span class="sy2">*</span> <span class="sy2">*</span>pw<span class="sy4">;</span>
				<span class="sy2">*</span>pv <span class="sy1">=</span> <span class="sy2">*</span>pu <span class="sy2">-</span> t<span class="sy4">;</span>
				<span class="sy2">*</span>pu <span class="sy2">+</span><span class="sy1">=</span> t<span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">&#40;</span>invert<span class="br0">&#41;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">/</span><span class="sy1">=</span> n<span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> calc_rev <span class="br0">&#40;</span><span class="kw4">int</span> n, <span class="kw4">int</span> log_n<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		rev<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>log_n<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy3">&amp;</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="sy1">&lt;&lt;</span>j<span class="br0">&#41;</span><span class="br0">&#41;</span>
				rev<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy3">|</span><span class="sy1">=</span> <span class="nu0">1</span><span class="sy1">&lt;&lt;</span><span class="br0">&#40;</span>log_n<span class="sy2">-</span><span class="nu0">1</span><span class="sy2">-</span>j<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>На распространённых компиляторах данная реализация быстрее предыдущего "улучшенного" варианта в 2-3 раза.<p><p><h2 style="padding-top:40px;"> Дискретное преобразование Фурье в модульной арифметике </h2><p>В основе дискретного преобразования Фурье лежат комплексные числа, корни <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">-ой степени из единицы. Для эффективного его вычисления использовались такие особенности корней, как существование <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> различных корней, образующих группу (т.е. степень одного корня &mdash; всегда другой корень; среди них есть один элемент &mdash; генератор группы, называемый примитивным корнем).<p>Но то же самое верно и в отношении корней <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">-ой степени из единицы в модульной арифметике. Точнее, не для любого модуля <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> найдётся <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> различных корней из единицы, однако такие модули всё же существуют. По-прежнему нам важно найти среди них примитивный корень, т.е.:<p><p class=formula><img class=tex src="../tex2png/cache/54beb7122de9abe0dfc40217bdaa489f.png" alt=" (w_n)^n = 1 \pmod p, "><br><img class=tex src="../tex2png/cache/99c6f6e83dfa048916359626a67fce5e.png" alt=" (w_n)^k \ne 1 {\pmod p}, ~~~~~1 \le k < n. "></p><p>Все остальные <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> корней <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">-ой степени из единицы по модулю <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> можно получить как степени примитивного корня <img class=tex src="../tex2png/cache/f12b737c8c65734e041f13f902fce36a.png" alt="w_n"> (как и в комплексном случае).<p>Для применения в алгоритме Быстрого преобразования Фурье нам было нужно, чтобы примивный корень существовал для некоторого <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, являвшегося степенью двойки, а также всех меньших степеней. И если в комплексном случае примитивный корень существовал для любого <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, то в случае модульной арифметики это, вообще говоря, не так. Однако, заметим, что если <img class=tex src="../tex2png/cache/b09e0620fa231823bd22c4bce636cb20.png" alt="n = 2^k">, т.е. <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ая степень двойки, то по модулю <img class=tex src="../tex2png/cache/542697e97c5bdd71ab45c84bf63d4599.png" alt="m = 2^{k-1}"> имеем:<p><p class=formula><img class=tex src="../tex2png/cache/0d55283e79a32ad821ba3e8761856e99.png" alt=" (w_n^2)^m = (w_n)^n = 1 \pmod p, "><br><img class=tex src="../tex2png/cache/bd564076c8f0f342329c19cfffa49913.png" alt=" (w_n^2)^k = w_n^{2k} \ne 1 {\pmod p}, ~~~~~1 \le [...]"></p><p>Таким образом, если <img class=tex src="../tex2png/cache/f12b737c8c65734e041f13f902fce36a.png" alt="w_n"> &mdash; примитивный корень <img class=tex src="../tex2png/cache/ca4d42af0cda4cba14f030af06e82669.png" alt="n=2^k">-ой степени из единицы, то <img class=tex src="../tex2png/cache/71631eff088d00cdeb713d1f2c23ac59.png" alt="w_n^2"> &mdash; примитивный корень <img class=tex src="../tex2png/cache/97c42e4ca4ce993e5a52c7ece2343aaa.png" alt="2^{k-1}">-ой степени из единицы. Следовательно, для всех степеней двойки, меньших <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, примитивные корни нужной степени также существуют, и могут быть вычислены как соответствующие степени <img class=tex src="../tex2png/cache/f12b737c8c65734e041f13f902fce36a.png" alt="w_n">.<p>Последний штрих &mdash; для обратного ДПФ мы использовали вместо <img class=tex src="../tex2png/cache/f12b737c8c65734e041f13f902fce36a.png" alt="w_n"> обратный ему элемент: <img class=tex src="../tex2png/cache/e42ff37eaeded937d425915bec3785f4.png" alt="w_n^{-1}">. Но по простому модулю <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> обратный элемент также всегда найдётся.<p>Таким образом, все нужные нам свойства соблюдаются и в случае модульной арифметики, при условии, что мы выбрали некоторый достаточно большой модуль <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> и нашли в нём примитивный корень <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">-ой степени из единицы.<p>Например, можно взять такие значения: модуль <img class=tex src="../tex2png/cache/59f73131909c16cd8716241ba09be567.png" alt="p = 7340033">, <img class=tex src="../tex2png/cache/a523adba4d4099815209c03b64762b27.png" alt="w_{2^{20}} = 5">. Если этого модуля будет недостаточно, для нахождения другой пары можно воспользоваться фактом, что для модулей вида <img class=tex src="../tex2png/cache/7a78e35b111a54289d4ba09778d3b979.png" alt="c 2^k + 1"> (но по-прежнему обязательно простых) всегда найдётся примитивный корень степени <img class=tex src="../tex2png/cache/a631b6ee74bdfc6711813da7ca95a648.png" alt="2^k"> из единицы.<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> mod <span class="sy1">=</span> <span class="nu0">7340033</span><span class="sy4">;</span>
<span class="kw4">const</span> <span class="kw4">int</span> root <span class="sy1">=</span> <span class="nu0">5</span><span class="sy4">;</span>
<span class="kw4">const</span> <span class="kw4">int</span> root_1 <span class="sy1">=</span> <span class="nu0">4404020</span><span class="sy4">;</span>
<span class="kw4">const</span> <span class="kw4">int</span> root_pw <span class="sy1">=</span> <span class="nu0">1</span><span class="sy1">&lt;&lt;</span><span class="nu0">20</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> fft <span class="br0">&#40;</span>vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy3">&amp;</span> a, <span class="kw4">bool</span> invert<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span>, j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> bit <span class="sy1">=</span> n <span class="sy1">&gt;&gt;</span> <span class="nu0">1</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;</span> j<span class="sy1">&gt;=</span>bit<span class="sy4">;</span> bit<span class="sy1">&gt;&gt;=</span><span class="nu0">1</span><span class="br0">&#41;</span>
			j <span class="sy2">-</span><span class="sy1">=</span> bit<span class="sy4">;</span>
		j <span class="sy2">+</span><span class="sy1">=</span> bit<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy1">&lt;</span> j<span class="br0">&#41;</span>
			swap <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span>, a<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> len<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> len<span class="sy1">&lt;=</span>n<span class="sy4">;</span> len<span class="sy1">&lt;&lt;=</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> wlen <span class="sy1">=</span> invert <span class="sy4">?</span> root_1 <span class="sy4">:</span> root<span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>len<span class="sy4">;</span> i<span class="sy1">&lt;</span>root_pw<span class="sy4">;</span> i<span class="sy1">&lt;&lt;=</span><span class="nu0">1</span><span class="br0">&#41;</span>
			wlen <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>wlen <span class="sy2">*</span> 1ll <span class="sy2">*</span> wlen <span class="sy2">%</span> mod<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> i<span class="sy2">+</span><span class="sy1">=</span>len<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> w <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
				<span class="kw4">int</span> u <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="br0">&#93;</span>,  v <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="sy2">+</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy2">*</span> 1ll <span class="sy2">*</span> w <span class="sy2">%</span> mod<span class="br0">&#41;</span><span class="sy4">;</span>
				a<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> u<span class="sy2">+</span>v <span class="sy1">&lt;</span> mod <span class="sy4">?</span> u<span class="sy2">+</span>v <span class="sy4">:</span> u<span class="sy2">+</span>v<span class="sy2">-</span>mod<span class="sy4">;</span>
				a<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="sy2">+</span>len<span class="sy2">/</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy1">=</span> u<span class="sy2">-</span>v <span class="sy1">&gt;=</span> <span class="nu0">0</span> <span class="sy4">?</span> u<span class="sy2">-</span>v <span class="sy4">:</span> u<span class="sy2">-</span>v<span class="sy2">+</span>mod<span class="sy4">;</span>
				w <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>w <span class="sy2">*</span> 1ll <span class="sy2">*</span> wlen <span class="sy2">%</span> mod<span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>invert<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> nrev <span class="sy1">=</span> reverse <span class="br0">&#40;</span>n, mod<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">*</span> 1ll <span class="sy2">*</span> nrev <span class="sy2">%</span> mod<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Здесь функция <img class=tex src="../tex2png/cache/1a5d1b394d00175648cba193ac491862.png" alt="\rm reverse"> находит обратный к <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> элемент по модулю <img class=tex src="../tex2png/cache/0f658920d255fe5d822d94a912891318.png" alt="\rm mod"> (см. <a href="reverse_element.html">Обратный элемент в поле по модулю</a>). Константы <img class=tex src="../tex2png/cache/0f658920d255fe5d822d94a912891318.png" alt="\rm mod">, <img class=tex src="../tex2png/cache/40e0e810bf54145c555375778ebb3918.png" alt="\rm root"> <img class=tex src="../tex2png/cache/7670cd6a51354cded32d8d4c70ce2233.png" alt="\rm root\_pw"> определяют модуль и примитивный корень, а <img class=tex src="../tex2png/cache/474339a5ad9c59e050089b9daa1108b5.png" alt="\rm root\_1"> &mdash; обратный к <img class=tex src="../tex2png/cache/40e0e810bf54145c555375778ebb3918.png" alt="\rm root"> элемент по модулю <img class=tex src="../tex2png/cache/0f658920d255fe5d822d94a912891318.png" alt="\rm mod">.<p>Как показывает практика, реализация целочисленного ДПФ работает даже медленней реализации с комплексными числами (из-за огромного количества операций взятия по модулю), однако она имеет такие преимущества, как меньшее использование памяти и отсутствие погрешностей округления.<p><p><h2 style="padding-top:40px;"> Некоторые применения </h2><p>Помимо непосредственного применения для перемножения многочленов или длинных чисел, опишем здесь некоторые другие приложения дискретного преобразования Фурье.<p><p><h3 style="padding-top:15px;"> Всевозможные суммы </h3><p>Задача: даны два массива <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]"> и <img class=tex src="../tex2png/cache/8112797623a2578c9b348cfa624f6f79.png" alt="b[]">. Требуется найти всевозможные числа вида <img class=tex src="../tex2png/cache/0f35d1a20408744c92470de9cf7bb042.png" alt="a[i]+b[j]">, и для каждого такого числа вывести количество способов получить его.<p>Например, для <img class=tex src="../tex2png/cache/65d903f1ae7bcdfa82a27f12efcd31c8.png" alt="a = (1,2,3)"> и <img class=tex src="../tex2png/cache/b6de7a94d6a9070aedde76d3b261586f.png" alt="b = (2,4)"> получаем: число 3 можно получить 1 способом, 4 &mdash; также одним, 5 &mdash; 2, 6 &mdash; 1, 7 &mdash; 1.<p>Построим по массивам <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> два многочлена <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> и <img class=tex src="../tex2png/cache/fb8234db4e6ea317a7c2aef7a38775ba.png" alt="B">. В качестве степеней в многочлене будут выступать сами числа, т.е. значения <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]"> (<img class=tex src="../tex2png/cache/e875235207203e3980be2bd509460e7a.png" alt="b[i]">), а в качестве коэффициентов при них &mdash; сколько раз это число встречается в массиве <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> (<img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">).<p>Тогда, перемножив эти два многочлена за <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">, мы получим многочлен <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C">, где в качестве степеней будут всевозможные числа вида <img class=tex src="../tex2png/cache/0f35d1a20408744c92470de9cf7bb042.png" alt="a[i]+b[j]">, а коэффициенты при них будут как раз искомыми количествами<p><p><h3 style="padding-top:15px;"> Всевозможные скалярные произведения </h3><p>Даны два массива <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]"> и <img class=tex src="../tex2png/cache/8112797623a2578c9b348cfa624f6f79.png" alt="b[]"> одной длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Требуется вывести значения каждого скалярного произведения вектора <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> на очередной циклический сдвиг вектора <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">.<p>Инвертируем массив <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и припишем к нему в конец <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> нулей, а к массиву <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> &mdash; просто припишем самого себя. Затем перемножим их как многочлены. Теперь рассмотрим коэффициенты произведения <img class=tex src="../tex2png/cache/744ddd580d3dacc50790fa5b5e0b4435.png" alt="c[n \ldots 2n-1]"> (как всегда, все индексы в 0-индексации). Имеем:<p><p class=formula><img class=tex src="../tex2png/cache/d7e32e6ede26056e2aaf351b7ef1de4c.png" alt=" c[k] = \sum_{i+j=k} a[i] b[j]. "></p><p>Поскольку все элементы <img class=tex src="../tex2png/cache/e77111c05fcc8869462e359c96e152c7.png" alt="a[i]=0,\ i=n \ldots 2n-1">, то мы получаем:<p><p class=formula><img class=tex src="../tex2png/cache/ec4dbda38ee816fd1a8d9c1b318b0a8e.png" alt=" c[k] = \sum_{i=0}^{n-1} a[i] b[k-i]. "></p><p>Нетрудно увидеть в этой сумме, что это именно скалярное произведение вектора <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> на <img class=tex src="../tex2png/cache/c1a3c44eefee914a472a57b2be82e59b.png" alt="k-n-1">-ый циклический сдвиг. Таким образом, эти коэффициенты (начиная с <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">-го и закачивая <img class=tex src="../tex2png/cache/8544b63735ac13dc1cad3999e9840daf.png" alt="2n-2">-ым) &mdash; и есть ответ на задачу.<p>Решение получилось с асимптотикой <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">.<p><p><h3 style="padding-top:15px;"> Две полоски </h3><p>Даны две полоски, заданные как два булевских (т.е. числовых со значениями 0 или 1) массива <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]"> и <img class=tex src="../tex2png/cache/8112797623a2578c9b348cfa624f6f79.png" alt="b[]">. Требуется найти все такие позиции на первой полоске, что если приложить, начиная с этой позиции, вторую полоску, ни в каком месте не получится <img class=tex src="../tex2png/cache/d04c5eb60a53293d4878d3c73c349aa6.png" alt="\rm true"> сразу на обеих полосках. Эту задачу можно переформулировать таким образом: дана карта полоски, в виде 0/1 &mdash; можно вставать в эту клетку или нет, и дана некоторая фигурка в виде шаблона (в виде массива, в котором 0 &mdash; нет клетки, 1 &mdash; есть), требуется найти все позиции в полоске, к которым можно приложить фигурку.<p>Эта задача фактически ничем не отличается от предыдущей задачи &mdash; задачи о скалярном произведении. Действительно, скалярное произведение двух 0/1 массивов &mdash; это количество элементов, в которых одновременно оказались единицы. Наша задача в том, чтобы найти все циклические сдвиги второй полоски так, чтобы не нашлось ни одного элемента, в котором бы в обеих полосках оказались единицы. Т.е. мы должны найти все циклические сдвиги второго массива, при которых скалярное произведение равно нулю.<p>Таким образом, эту задачу мы решили за <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">.<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>