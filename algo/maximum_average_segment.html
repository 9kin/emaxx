<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Поиск подотрезка массива с максимальной/минимальной суммой</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 23 Aug 2011 12:40<br>редактировано: 15 Jul 2014 22:21</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="maximum_average_segment.html#" id="contents-hide">[скрыть]</a><a href="maximum_average_segment.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Поиск подотрезка массива с максимальной/минимальной суммой </h1><p>Здесь мы рассмотрим задачу о поиске подотрезка массива с максимальной суммой ("maximum subarray problem" на английском), а также некоторые её вариации (в том числе алгоритм решения варианта этой задачи в режиме онлайн &mdash; описанный автором алгоритма &mdash; KADR (Ярослав Твердохлеб)).<p><p><h2 style="padding-top:40px;"> Постановка задачи </h2><p>Дан массив чисел <img class=tex src="../tex2png/cache/882c9eac4789d4397cc304ec6933ec6e.png" alt="a[1 \ldots n]">. Требуется найти такой его подотрезок <img class=tex src="../tex2png/cache/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a[l \ldots r]">, что сумма на нём <b>максимальна</b>:<p><p class=formula><img class=tex src="../tex2png/cache/dded728c7eb73fd156decc1b7123ef18.png" alt=" \max_{ 1 \le l \le r \le n } \sum_{i=l}^{r} a[i].[...]"></p><p>Например, если бы все числа массива <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]"> были бы неотрицательными, то в качестве ответа можно было бы взять весь массив. Решение нетривиально, когда массив может содержать как положительные, так и отрицательные числа.<p>Понятно, что задача о поиске <b>минимального</b> подотрезка &mdash; по сути та же самая, достаточно лишь изменить знаки всех чисел на противоположные.<p><p><h2 style="padding-top:40px;"> Алгоритм 1 </h2><p>Здесь мы рассмотрим практически очевидный алгоритм. (Дальше мы рассмотрим другой алгоритм, который чуть сложнее придумать, однако его реализация получается ещё короче.)<p><h3 style="padding-top:15px;"> Описание алгоритма </h3><p>Алгоритм весьма прост.<p>Введём для удобства <b>обозначение</b>: <img class=tex src="../tex2png/cache/ad58ca76f622257b8a5d8dd87bcc2388.png" alt="s[i] = \sum_{j=1}^{i} a[j]">. Т.е. массив <img class=tex src="../tex2png/cache/fd6f470cea3a6f4a8e40703f1a939deb.png" alt="s[i]"> &mdash; это массив частичных сумм массива <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]">. Также положим значение <img class=tex src="../tex2png/cache/040401921fa1910351208b423682a95d.png" alt="s[0] = 0">.<p>Будем теперь <b>перебирать</b> индекс <img class=tex src="../tex2png/cache/a319af1cb11d358ab29ff4f331512efe.png" alt="r = 1 \ldots n">, и научимся для каждого текущего значения <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> быстро находить оптимальное <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l">, при котором достигается максимальная сумма на подотрезке <img class=tex src="../tex2png/cache/5c26a4cd50987390e0b0b9667b72b520.png" alt="[l; r]">.<p>Формально это означает, что нам надо для текущего <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> найти такое <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> (не превосходящее <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">), чтобы величина <img class=tex src="../tex2png/cache/ad4946514130652388ecb2f12ea2ed11.png" alt="s[r] - s[l-1]"> была максимальной. После тривиального преобразования мы получаем, что нам надо найти в массиве <img class=tex src="../tex2png/cache/0b31500b7c97893de1733555c7ce29cd.png" alt="s[]"> минимум на отрезке <img class=tex src="../tex2png/cache/d2bfe02067adb6d7c81756c7e92909e7.png" alt="[0;r-1]">.<p>Отсюда мы сразу получаем алгоритм решения: мы просто будем хранить, где в массиве <img class=tex src="../tex2png/cache/0b31500b7c97893de1733555c7ce29cd.png" alt="s[]"> находится текущий минимум. Используя этот минимум, мы за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> находим текущий оптимальный индекс <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l">, а при переходе от текущего индекса <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> к следующему мы просто обновляем этот минимум.<p>Очевидно, этот алгоритм работает за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> и асимптотически оптимален.<p><h3 style="padding-top:15px;"> Реализация </h3><p>Для реализации нам даже не понадобится явно хранить массив частичных сумм <img class=tex src="../tex2png/cache/0b31500b7c97893de1733555c7ce29cd.png" alt="s[]"> &mdash; от него нам будет требоваться только текущий элемент.<p>Реализация приводится в 0-индексированных массивах, а не в 1-нумерации, как было описано выше.<p>Приведём сначала решение, которое находит просто численный ответ, не находя индексы искомого отрезка:<p><pre class="notranslate cpp"><span class="kw4">int</span> ans <span class="sy1">=</span> a<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>,
	sum <span class="sy1">=</span> <span class="nu0">0</span>,
	min_sum <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> r<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> r<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>r<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	sum <span class="sy2">+</span><span class="sy1">=</span> a<span class="br0">&#91;</span>r<span class="br0">&#93;</span><span class="sy4">;</span>
	ans <span class="sy1">=</span> max <span class="br0">&#40;</span>ans, sum <span class="sy2">-</span> min_sum<span class="br0">&#41;</span><span class="sy4">;</span>
	min_sum <span class="sy1">=</span> min <span class="br0">&#40;</span>min_sum, sum<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Теперь приведём полный вариант решения, который параллельно с числовым решением находит границы искомого отрезка:<p><pre class="notranslate cpp"><span class="kw4">int</span> ans <span class="sy1">=</span> a<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>,
	ans_l <span class="sy1">=</span> <span class="nu0">0</span>,
	ans_r <span class="sy1">=</span> <span class="nu0">0</span>,
	sum <span class="sy1">=</span> <span class="nu0">0</span>,
	min_sum <span class="sy1">=</span> <span class="nu0">0</span>,
	min_pos <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> r<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> r<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>r<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	sum <span class="sy2">+</span><span class="sy1">=</span> a<span class="br0">&#91;</span>r<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw4">int</span> cur <span class="sy1">=</span> sum <span class="sy2">-</span> min_sum<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>cur <span class="sy1">&gt;</span> ans<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		ans <span class="sy1">=</span> cur<span class="sy4">;</span>
		ans_l <span class="sy1">=</span> min_pos <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
		ans_r <span class="sy1">=</span> r<span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">&#40;</span>sum <span class="sy1">&lt;</span> min_sum<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		min_sum <span class="sy1">=</span> sum<span class="sy4">;</span>
		min_pos <span class="sy1">=</span> r<span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p><p><h2 style="padding-top:40px;"> Алгоритм 2 </h2><p>Здесь мы рассмотрим другой алгоритм. Его чуть сложнее понять, но зато он более элегантен, чем приведённый выше, и реализуется чуть-чуть короче. Этот алгоритм был предложен Джеем Каданом (Jay Kadane) в 1984 г.<p><h3 style="padding-top:15px;"> Описание алгоритма </h3><p>Сам <b>алгоритм</b> выглядит следующим образом. Будем идти по массиву и накапливать в некоторой переменной <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> текущую частичную сумму. Если в какой-то момент <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> окажется отрицательной, то мы просто присвоим <img class=tex src="../tex2png/cache/d519c64f3b1016d353ee76e6bff95cb7.png" alt="s=0">. Утверждается, что максимум из всех значений переменной <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, случившихся за время работы, и будет ответом на задачу.<p><b>Докажем</b> этот алгоритм.<p>В самом деле, рассмотрим первый момент времени, когда сумма <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> стала отрицательной. Это означает, что, стартовав с нулевой частичной суммы, мы в итоге пришли к отрицательной частичной сумме &mdash; значит, и весь этот префикс массива, равно как и любой его суффикс имеют отрицательную сумму. Следовательно, от всего этого префикса массива в дальнейшем не может быть никакой пользы: он может дать только отрицательную прибавку к ответу.<p>Однако этого недостаточно для доказательства алгоритма. В алгоритме мы, фактически, ограничиваемся в поиске ответа только такими отрезками, которые начинаются непосредственно после мест, когда случалось <img class=tex src="../tex2png/cache/e0c3e834299ebce7b7f6e58ef2941d80.png" alt="s<0">.<p>Но, в самом деле, рассмотрим произвольный отрезок <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]">, причём <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> не находится в такой "критической" позиции (т.е. <img class=tex src="../tex2png/cache/35875d2a47055f8d85be3c3b634fbc52.png" alt="l > p+1">, где <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> &mdash; последняя такая позиция, в которой <img class=tex src="../tex2png/cache/e0c3e834299ebce7b7f6e58ef2941d80.png" alt="s<0">). Поскольку последняя критическая позиция находится строго раньше, чем в <img class=tex src="../tex2png/cache/03c1cf2db41f780718f2da36f1152230.png" alt="l-1">, то получается, что сумма <img class=tex src="../tex2png/cache/facdace2584c2a0cd97f613281dd3303.png" alt="a[p+1 \ldots l-1]"> неотрицательна. Это означает, что, сдвинув <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> в позицию <img class=tex src="../tex2png/cache/7bfdbd20cc6bda0ce171a5dfbd5e4cfe.png" alt="p+1">, мы увеличим ответ или, в крайнем случае, не изменим его.<p>Так или иначе, но получается, что действительно при поиске ответа можно ограничиться только отрезками, начинающимися сразу после позиций, в которых оказывалось <img class=tex src="../tex2png/cache/e0c3e834299ebce7b7f6e58ef2941d80.png" alt="s<0">. Это доказывает правильность алгоритма.<p><h3 style="padding-top:15px;"> Реализация </h3><p>Как и в алгоритме 1, приведём сначала упрощённую реализацию, которая ищет только числовой ответ, не находя границ искомого отрезка:<p><pre class="notranslate cpp"><span class="kw4">int</span> ans <span class="sy1">=</span> a<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>,
	sum <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> r<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> r<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>r<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	sum <span class="sy2">+</span><span class="sy1">=</span> a<span class="br0">&#91;</span>r<span class="br0">&#93;</span><span class="sy4">;</span>
	ans <span class="sy1">=</span> max <span class="br0">&#40;</span>ans, sum<span class="br0">&#41;</span><span class="sy4">;</span>
	sum <span class="sy1">=</span> max <span class="br0">&#40;</span>sum, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Полный вариант решения, с поддержанием индексов-границ искомого отрезка:<p><pre class="notranslate cpp"><span class="kw4">int</span> ans <span class="sy1">=</span> a<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>,
	ans_l <span class="sy1">=</span> <span class="nu0">0</span>,
	ans_r <span class="sy1">=</span> <span class="nu0">0</span>,
	sum <span class="sy1">=</span> <span class="nu0">0</span>,
	minus_pos <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> r<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> r<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>r<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	sum <span class="sy2">+</span><span class="sy1">=</span> a<span class="br0">&#91;</span>r<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">&#40;</span>sum <span class="sy1">&gt;</span> ans<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		ans <span class="sy1">=</span> sum<span class="sy4">;</span>
		ans_l <span class="sy1">=</span> minus_pos <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
		ans_r <span class="sy1">=</span> r<span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">&#40;</span>sum <span class="sy1">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		sum <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
		minus_pos <span class="sy1">=</span> r<span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p><p><h2 style="padding-top:40px;"> Смежные задачи </h2><p><h3 style="padding-top:15px;"> Поиск максимального/минимального подотрезка с ограничениями </h3><p>Если в условии задачи на искомый отрезок <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> накладываются дополнительные ограничения (например, что длина <img class=tex src="../tex2png/cache/d0bf83db096d18f786c1580c83900aeb.png" alt="r-l+1"> отрезка должна находиться в заданных пределах), то описанный алгоритм скорее всего легко обобщается на эти случаи &mdash; так или иначе, задача будет по-прежнему заключаться в поиске минимума в массиве <img class=tex src="../tex2png/cache/0b31500b7c97893de1733555c7ce29cd.png" alt="s[]"> при заданных дополнительных ограничениях.<p><h3 style="padding-top:15px;"> Двумерный случай задачи: поиск максимальной/минимальной подматрицы </h3><p>Описанная в данной статье задача естественно обобщается на большие размерности. Например, в двумерном случае она превращается в поиск такой подматрицы <img class=tex src="../tex2png/cache/9d096151064ccd9e8e85132f942f3016.png" alt="[l_1 \ldots r_1; l_2 \ldots r_2]"> заданной матрицы, которая имеет максимальную сумму чисел в ней.<p>Из описанного выше решения для одномерного случая <b>легко получить</b> решение за <img class=tex src="../tex2png/cache/5333bf52919bd2805f33a181851ebbf4.png" alt="O(n^3)">: переберём <img class=tex src="../tex2png/cache/91bfa45247ac88d05f75403d6ecb5d68.png" alt="l_1"> и <img class=tex src="../tex2png/cache/9b82d10f1951fedc8090fea9cee623bc.png" alt="r_1">, и посчитаем массив сумм с <img class=tex src="../tex2png/cache/91bfa45247ac88d05f75403d6ecb5d68.png" alt="l_1"> по <img class=tex src="../tex2png/cache/9b82d10f1951fedc8090fea9cee623bc.png" alt="r_1"> в каждой строке матрицы; мы пришли к одномерной задаче поиска индексов <img class=tex src="../tex2png/cache/999b7ef5ab10bdfeecdbbdc720766fb4.png" alt="l_2"> и <img class=tex src="../tex2png/cache/5a0746e655144644eb95b409a4f938d5.png" alt="r_2"> в этом массиве, которую уже можно решать за линейное время.<p><b>Более быстрые</b> алгоритмы решения этой задачи хотя и известны, однако они не сильно быстрее <img class=tex src="../tex2png/cache/5333bf52919bd2805f33a181851ebbf4.png" alt="O(n^3)">, и при этом весьма сложны (настолько сложны, что по скрытой константе многие из них уступают тривиальному алгоритму при всех разумных ограничениях). По всей видимости, лучший из известных алгоритмов работает за <img class=tex src="../tex2png/cache/75abca045b42ae27a5fa753fafb7049f.png" alt="O \left( n^3 \frac{ \log^3 \log n }{ \log^2 n} \right)"> (T. Chan 2007 "More algorithms for all-pairs shortest paths in weighted graphs").<p>Этот алгоритм Chan, а также многие другие результаты в данной области на самом деле описывают <b>быстрое умножение</b> матриц (где под умножением матриц подразумевается модифицированное умножение: вместо сложения используется минимум, а вместо умножения &mdash; сложение). Дело в том, что задача о поиске подматрицы с наибольшей суммой сводится к задаче о поиске кратчайших путей между всеми парами вершин, а эта задача, в свою очередь &mdash; сводится к такому умножению матриц.<p><h3 style="padding-top:15px;"> Поиск подотрезка с максимальной/минимальной средней суммой </h3><p>Эта задача заключается в том, что надо найти такой отрезок <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]">, чтобы среднее значение на нём было максимальным:<p><p class=formula><img class=tex src="../tex2png/cache/bc0b71840164faf673e566833af3975e.png" alt=" \max_{l \le r} \frac{ 1 }{ r-l+1 } \sum_{i=l}^{r}[...]"></p><p>Конечно, если на искомый отрезок <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> по условию не наложено других условий, то решением всегда будет являться отрезок длины <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"> в точке-максимуме массива. Задача имеет смысл, только если имеются <b>дополнительные ограничения</b> (например, длина искомого отрезка ограничена снизу).<p>В таком случае применим <b>стандартный приём</b> при работе с задачами о среднем значении: будем подбирать искомую максимальную среднюю величину <b>двоичным поиском</b>.<p>Для этого нам надо научиться решать такую подзадачу: дано число <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">, и надо проверить, есть ли подотрезок массива <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]"> (конечно, удовлетворяющий всем дополнительным ограничениям задачи), на котором среднее значение больше <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">.<p>Чтобы решить эту подзадачу, отнимем <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> от каждого элемента массива <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]">. Тогда наша подзадача фактически превращается в такую: есть или нет в данном массиве подотрезок положительной суммы. А эту задачу мы уже умеем решать.<p>Таким образом, мы получили решение за асимпотику <img class=tex src="../tex2png/cache/0f91f1e8965daa23d558a835e3f6b6f7.png" alt="O (T(n) \log W)">, где <img class=tex src="../tex2png/cache/0db91522b80ae7e260c1404e2d143808.png" alt="W"> &mdash; требуемая точность, <img class=tex src="../tex2png/cache/d6fc6b4d622783678ffe9beb4007b66d.png" alt="T(n)"> &mdash; время решения подзадачи для массива длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> (которое может варьироваться в зависимости от конкретных накладываемых дополнительных ограничений).<p><h3 style="padding-top:15px;"> Решение задачи в режиме онлайн </h3><p>Условие задачи таково: дан массив из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> чисел, а также дано число <img class=tex src="../tex2png/cache/88e54f90480ef3aeba329562335471f9.png" alt="L">. Поступают запросы вида <img class=tex src="../tex2png/cache/5da5090de09ee020bba6974c7d377e42.png" alt="(l,r)">, и в ответ на запрос требуется найти подотрезок отрезка <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> длины не менее <img class=tex src="../tex2png/cache/88e54f90480ef3aeba329562335471f9.png" alt="L"> с максимально возможным средним арифметическим.<p>Алгоритм решения этой задачи достаточно сложен. Автор данного алгоритма &mdash; KADR (Ярослав Твердохлеб) &mdash; <a href="http://e-maxx.ru/forum/viewtopic.php?id=410">описал данный алгоритм в своём сообщении на форуме</a>.<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>