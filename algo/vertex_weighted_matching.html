<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Нахождение наибольшего по весу вершинно-взвешенного паросочетания</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 11 Jul 2008 15:37<br>редактировано: 11 Jul 2008 17:13</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="vertex_weighted_matching.html#" id="contents-hide">[скрыть]</a><a href="vertex_weighted_matching.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Нахождение наибольшего по весу вершинно-взвешенного паросочетания</h1>
<p>Дан двудольный граф G. Для каждой вершины первой доли указан её вес. Требуется найти паросочетание наибольшего веса, т.е. с наибольшей суммой весов насыщенных вершин.</p>
<p>Ниже мы опишем и докажем алгоритм, основанный на <a href="kuhn_matching.html">алгоритме Куна</a>, который будет находить оптимальное решение.</p>
<h2>Алгоритм</h2>
<p>Сам алгоритм чрезвычайно прост. <b>Отсортируем</b> вершины первой доли в порядке убывания (точнее говоря, невозрастания) весов, и применим к полученному графу <b><a href="kuhn_matching.html">алгоритм Куна</a></b>.</p>
<p>Утверждается, что полученное при этом максимальное (с точки зрения количества рёбер) паросочетание будет и оптимальным с точки зрения суммы весов насыщенных вершин (несмотря на то, что после сортировки мы фактически больше не используем эти веса).</p>
<p>Таким образом, реализация будет примерно такой:</p>
<pre>int n;
vector &lt; vector&lt;int> > g (n);
vector<char> used (n);
vector&lt;int> order (n); // список вершин, отсортированный по весу
... чтение ...

for (int i=0; i&lt;n; ++i) {
	int v = order[i];
	used.assign (n, false);
	try_kuhn (v);
}</pre>
<p>Функция try_kuhn() берётся безо всяких изменений из алгоритма Куна.</p>
<h2>Доказательство</h2>
<p>Напомним основные положения <b>теории матроидов</b>.</p>
<p>Матроид M - это упорядоченная пара (S,I), где S - некоторое множество, I - непустое семейство подмножеств множества S, которые удовлетворяют следующим условиям:</p>
<ol>
<li>Множество S конечное.</li>
<li>Семейство I является наследственным, т.е. если какое-то множество принадлежит I, то все его подмножества также принадлежат I.</li>
<li>Структура M обладает свойством замены, т.е. если A&isin;I, и B&isin;I, и |A|&lt;|B|, то найдётся такой элемент x&isin;A-B, что A&cup;x&isin;I.</li>
</ol>
<p>Элементы семейства I называются независимыми подмножествами.</p>
<p>Матроид называется взвешенным, если для каждого элемента x&isin;S определён некоторый вес. Весом подмножества называется сумма весов его элементов.</p>
<p>Наконец, важнейшая теорема в теории взвешенных матроидов: чтобы получить оптимальный ответ, т.е. независимое подмножество с наибольшим весом, нужно действовать жадно: начиная с пустого подмножества, будем добавлять (если, конечно, текущий элемент можно добавить без нарушения независимости) все элементы по одному в порядке уменьшения (точнее, невозрастания) их весов:</p>
<pre>отсортировать множество S по невозрастанию веса;
ans = [];
foreach (x in S)
	if (ans &cup; x &isin; I)
		ans = ans &cup; x;</pre>
<p>Утверждается, что по окончании этого процесса мы получим подмножество с наибольшим весом.</p>
<p>Теперь <b>докажем</b>, что <b>наша задача -</b> не что иное, как взвешенный <b>матроид</b>.</p>
<p>Пусть S - множество всех вершин первой доли. Чтобы свести нашу задачу в двудольном графе к матроиду относительно вершин первой доли, поставим в соответствие каждому паросочетанию такое подмножество S, которое равно множеству насыщенных вершин первой доли. Можно также определить и обратное соответствие (из множества насыщенных вершин - в паросочетание), которое, хотя и не будет однозначным, однако вполне нас будет устраивать.</p>
<p>Тогда определим семейство I как семейство таких подмножеств множества S, для которых найдётся хотя бы одно соответствующее паросочетание.</p>
<p>Далее, для каждого элемента S, т.е. для каждой вершины первой доли, по условию определён некоторый вес. Причём вес подмножества, как нам и требуется в рамках теории матроидов, определяется как сумма весов элементов в нём.</p>
<p>Тогда задача о нахождении паросочетания наибольшего веса теперь переформулируется как задача нахождения независимого подмножества наибольшего веса.</p>
<p>Осталось проверить, что выполнены 3 вышеописанных условия, наложенных на матроид. Во-первых, очевидно, что S является конечным. Во-вторых, очевидно, что удаление ребра из паросочетания эквивалентно удалению вершины из множества насыщенных вершин, а потому свойство наследственности выполняется. В-третьих, как следует из корректности алгоритма Куна, если текущее паросочетание не максимально, то всегда найдётся такая вершина, которую можно будет насытить, не удаляя из множества насыщенных вершин другие вершины.</p>
<p>Итак, мы показали, что наша задача является взвешенным матроидом относительно множества насыщенных вершин первой доли, а потому к ней применим жадный алгоритм.</p>
<p>Осталось показать, что <b>алгоритм Куна является этим жадным алгоритмом</b>.</p>
<p>Однако это довольно очевидный факт. Алгоритм Куна на каждом шаге пытается насытить текущую вершину - либо просто проводя ребро в ненасыщенную вершину второй доли, либо находя удлиняющую цепь и чередуя паросочетание вдоль неё. И в том, и в другом случае никакие уже насыщенные вершины не перестают быть ненасыщенными, а ненасыщенные на предыдущих шагах вершины первой доли не насыщаются и на этом шаге. Таким образом, алгоритм Куна является жадным алгоритмом, строящим оптимальное независимое подмножества матроида, что и завершает наше доказательство.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>