<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Длинная арифметика</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 18:06<br>редактировано: 23 Mar 2012 3:45</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="big_integer.html#" id="contents-hide">[скрыть]</a><a href="big_integer.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Длинная арифметика </h1><p>Длинная арифметика &mdash; это набор программных средств (структуры данных и алгоритмы), которые позволяют работать с числами гораздо больших величин, чем это позволяют стандартные типы данных.<p><p><h2 style="padding-top:40px;"> Виды целочисленной длинной арифметики </h2><p>Вообще говоря, даже только в олимпиадных задачах набор средств достаточно велик, поэтому произведём классификацию различных видов длинной арифметики.<p><p><h3 style="padding-top:15px;"> Классическая длинная арифметика </h3><p>Основная идея заключается в том, что число хранится в виде массива его цифр.<p>Цифры могут использоваться из той или иной системы счисления, обычно применяются десятичная система счисления и её степени (десять тысяч, миллиард), либо двоичная система счисления.<p>Операции над числами в этом виде длинной арифметики производятся с помощью "школьных" алгоритмов сложения, вычитания, умножения, деления столбиком. Впрочем, к ним также применимы алгоритмы быстрого умножения: <a href="fft_multiply.html">Быстрое преобразование Фурье</a> и Алгоритм Карацубы.<p>Здесь описана работа только с неотрицательными длинными числами. Для поддержки отрицательных чисел необходимо ввести и поддерживать дополнительный флаг "отрицательности" числа, либо же работать в дополняющих кодах.<p><p><h4> Структура данных </h4><p>Хранить длинные числа будем в виде вектора чисел <img class=tex src="../tex2png/cache/23ebdff93fb4e6a6fa0e0151a362318d.png" alt="int">, где каждый элемент &mdash; это одна цифра числа.<p><pre class="notranslate cpp"><span class="kw4">typedef</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> lnum<span class="sy4">;</span></pre><p>Для повышения эффективности будем работать в системе по основанию миллиард, т.е. каждый элемент вектора <img class=tex src="../tex2png/cache/9b1d46b948208bcedd8d4c1ab12afa5f.png" alt="lnum"> содержит не одну, а сразу <img class=tex src="../tex2png/cache/141aa12977eb90edab9130cae519bccf.png" alt="9"> цифр:<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> base <span class="sy1">=</span> <span class="nu0">1000</span><span class="sy2">*</span><span class="nu0">1000</span><span class="sy2">*</span><span class="nu0">1000</span><span class="sy4">;</span></pre><p>Цифры будут храниться в векторе в таком порядке, что сначала идут наименее значимые цифры (т.е. единицы, десятки, сотни, и т.д.).<p>Кроме того, все операции будут реализованы таким образом, что после выполнения любой из них лидирующие нули (т.е. лишние нули в начале числа) отсутствуют (разумеется, в предположении, что перед каждой операцией лидирующие нули также отсутствуют). Следует отметить, что в представленной реализации для числа ноль корректно поддерживаются сразу два представления: пустой вектор цифр, и вектор цифр, содержащий единственный элемент &mdash; ноль.<p><p><h4> Вывод </h4><p>Самое простое &mdash; это вывод длинного числа.<p>Сначала мы просто выводим самый последний элемент вектора (или <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0">, если вектор пустой), а затем выводим все оставшиеся элементы вектора, дополняя их нулями до <img class=tex src="../tex2png/cache/141aa12977eb90edab9130cae519bccf.png" alt="9"> символов:<p><pre class="notranslate cpp"><span class="kw3">printf</span> <span class="br0">&#40;</span><span class="st0">&quot;%d&quot;</span>, a.<span class="me1">empty</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy4">?</span> <span class="nu0">0</span> <span class="sy4">:</span> a.<span class="me1">back</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy2">-</span><span class="nu0">2</span><span class="sy4">;</span> i<span class="sy1">&gt;=</span><span class="nu0">0</span><span class="sy4">;</span> <span class="sy2">--</span>i<span class="br0">&#41;</span>
	<span class="kw3">printf</span> <span class="br0">&#40;</span><span class="st0">&quot;%09d&quot;</span>, a<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p>(здесь небольшой тонкий момент: нужно не забыть записать приведение типа <img class=tex src="../tex2png/cache/cc9ec7487cb727db44e6b7377061050b.png" alt="(int)">, поскольку в противном случае число <img class=tex src="../tex2png/cache/10737885d69ffc2b1964311055e6d60e.png" alt="a.size()"> будут беззнаковым, и если <img class=tex src="../tex2png/cache/ab16de9f17309d04fe2e34b52949b987.png" alt="a.size() \le 1">, то при вычитании произойдёт переполнение)<p><p><h4> Чтение </h4><p>Считываем строку в <img class=tex src="../tex2png/cache/77b88044fc7ba5b45e1d30c350f92c04.png" alt="string">, и затем преобразовываем её в вектор:<p><pre class="notranslate cpp"><span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>s.<span class="me1">length</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> i<span class="sy1">&gt;</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy2">-</span><span class="sy1">=</span><span class="nu0">9</span><span class="br0">&#41;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy1">&lt;</span> <span class="nu0">9</span><span class="br0">&#41;</span>
		a.<span class="me1">push_back</span> <span class="br0">&#40;</span><span class="kw3">atoi</span> <span class="br0">&#40;</span>s.<span class="me1">substr</span> <span class="br0">&#40;</span><span class="nu0">0</span>, i<span class="br0">&#41;</span>.<span class="me1">c_str</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">else</span>
		a.<span class="me1">push_back</span> <span class="br0">&#40;</span><span class="kw3">atoi</span> <span class="br0">&#40;</span>s.<span class="me1">substr</span> <span class="br0">&#40;</span>i<span class="sy2">-</span><span class="nu0">9</span>, <span class="nu0">9</span><span class="br0">&#41;</span>.<span class="me1">c_str</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p>Если использовать вместо <img class=tex src="../tex2png/cache/77b88044fc7ba5b45e1d30c350f92c04.png" alt="string"> массив <img class=tex src="../tex2png/cache/b34d0d931345439cb6c4d49f972480bb.png" alt="char">'ов, то код получится ещё компактнее:<p><pre class="notranslate cpp"><span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="kw3">strlen</span><span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="sy4">;</span> i<span class="sy1">&gt;</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy2">-</span><span class="sy1">=</span><span class="nu0">9</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	s<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	a.<span class="me1">push_back</span> <span class="br0">&#40;</span><span class="kw3">atoi</span> <span class="br0">&#40;</span>i<span class="sy1">&gt;=</span><span class="nu0">9</span> <span class="sy4">?</span> s<span class="sy2">+</span>i<span class="sy2">-</span><span class="nu0">9</span> <span class="sy4">:</span> s<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Если во входном числе уже могут быть лидирующие нули, то их после чтения можно удалить таким образом:<p><pre class="notranslate cpp"><span class="kw1">while</span> <span class="br0">&#40;</span>a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">&gt;</span> <span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> a.<span class="me1">back</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
	a.<span class="me1">pop_back</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p><p><h4> Сложение </h4><p>Прибавляет к числу <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> число <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> и сохраняет результат в <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">:<p><pre class="notranslate cpp"><span class="kw4">int</span> carry <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>max<span class="br0">&#40;</span>a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span>,b.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy3">||</span> carry<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy1">==</span> a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
		a.<span class="me1">push_back</span> <span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
	a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> carry <span class="sy2">+</span> <span class="br0">&#40;</span>i <span class="sy1">&lt;</span> b.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy4">?</span> b<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy4">:</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
	carry <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&gt;=</span> base<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>carry<span class="br0">&#41;</span>  a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">-</span><span class="sy1">=</span> base<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h4> Вычитание </h4><p>Отнимает от числа <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> число <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> (<img class=tex src="../tex2png/cache/cf19c8805af6ab7c32fc9553d45ed7be.png" alt="a \ge b">) и сохраняет результат в <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">:<p><pre class="notranslate cpp"><span class="kw4">int</span> carry <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>b.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy3">||</span> carry<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">-</span><span class="sy1">=</span> carry <span class="sy2">+</span> <span class="br0">&#40;</span>i <span class="sy1">&lt;</span> b.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy4">?</span> b<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy4">:</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
	carry <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&lt;</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>carry<span class="br0">&#41;</span>  a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> base<span class="sy4">;</span>
<span class="br0">&#125;</span>
<span class="kw1">while</span> <span class="br0">&#40;</span>a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">&gt;</span> <span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> a.<span class="me1">back</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
	a.<span class="me1">pop_back</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p>Здесь мы после выполнения вычитания удаляем лидирующие нули, чтобы поддерживать предикат о том, что таковые отсутствуют.<p><p><h4> Умножение длинного на короткое </h4><p>Умножает длинное <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> на короткое <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> (<img class=tex src="../tex2png/cache/1d31f83e942998da9f13db14bb08d5a5.png" alt="b < {\rm base}">) и сохраняет результат в <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">:<p><pre class="notranslate cpp"><span class="kw4">int</span> carry <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy3">||</span> carry<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy1">==</span> a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
		a.<span class="me1">push_back</span> <span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw4">long</span> <span class="kw4">long</span> cur <span class="sy1">=</span> carry <span class="sy2">+</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">*</span> 1ll <span class="sy2">*</span> b<span class="sy4">;</span>
	a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>cur <span class="sy2">%</span> base<span class="br0">&#41;</span><span class="sy4">;</span>
	carry <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>cur <span class="sy2">/</span> base<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
<span class="kw1">while</span> <span class="br0">&#40;</span>a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">&gt;</span> <span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> a.<span class="me1">back</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
	a.<span class="me1">pop_back</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p>Здесь мы после выполнения деления удаляем лидирующие нули, чтобы поддерживать предикат о том, что таковые отсутствуют.<p>(Примечание: способ <b>дополнительной оптимизации</b>. Если скорость работы чрезвычайно важна, то можно попробовать заменить два деления одним: посчитать только целую часть от деления (в коде это переменная <img class=tex src="../tex2png/cache/3461d3f8dbf7272ad674d24a58e0c8c2.png" alt="carry">), а затем уже посчитать по ней остаток от деления (с помощью одной операции умножения). Как правило, этот приём позволяет ускорить код, хотя и не очень значительно.)<p><p><h4> Умножение двух длинных чисел </h4><p>Умножает <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> на <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> и результат сохраняет в <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">:<p><pre class="notranslate cpp">lnum c <span class="br0">&#40;</span>a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy2">+</span>b.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span>, carry<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>b.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy3">||</span> carry<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">long</span> <span class="kw4">long</span> cur <span class="sy1">=</span> c<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="br0">&#93;</span> <span class="sy2">+</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">*</span> 1ll <span class="sy2">*</span> <span class="br0">&#40;</span>j <span class="sy1">&lt;</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>b.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy4">?</span> b<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy4">:</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="sy2">+</span> carry<span class="sy4">;</span>
		c<span class="br0">&#91;</span>i<span class="sy2">+</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>cur <span class="sy2">%</span> base<span class="br0">&#41;</span><span class="sy4">;</span>
		carry <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>cur <span class="sy2">/</span> base<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="kw1">while</span> <span class="br0">&#40;</span>c.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">&gt;</span> <span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> c.<span class="me1">back</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
	c.<span class="me1">pop_back</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p><p><h4> Деление длинного на короткое </h4><p>Делит длинное <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> на короткое <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> (<img class=tex src="../tex2png/cache/1d31f83e942998da9f13db14bb08d5a5.png" alt="b < {\rm base}">), частное сохраняет в <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, остаток в <img class=tex src="../tex2png/cache/3461d3f8dbf7272ad674d24a58e0c8c2.png" alt="carry">:<p><pre class="notranslate cpp"><span class="kw4">int</span> carry <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&gt;=</span><span class="nu0">0</span><span class="sy4">;</span> <span class="sy2">--</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">long</span> <span class="kw4">long</span> cur <span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">+</span> carry <span class="sy2">*</span> 1ll <span class="sy2">*</span> base<span class="sy4">;</span>
	a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>cur <span class="sy2">/</span> b<span class="br0">&#41;</span><span class="sy4">;</span>
	carry <span class="sy1">=</span> <span class="kw4">int</span> <span class="br0">&#40;</span>cur <span class="sy2">%</span> b<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
<span class="kw1">while</span> <span class="br0">&#40;</span>a.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">&gt;</span> <span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> a.<span class="me1">back</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
	a.<span class="me1">pop_back</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p><p><h3 style="padding-top:15px;"> Длинная арифметика в факторизованном виде </h3><p>Здесь идея заключается в том, чтобы хранить не само число, а его факторизацию, т.е. степени каждого входящего в него простого.<p>Этот метод также весьма прост для реализации, и в нём очень легко производить операции умножения и деления, однако невозможно произвести сложение или вычитание. С другой стороны, этот метод значительно экономит память в сравнении с "классическим" подходом, и позволяет производить умножение и деление значительно (асимптотически) быстрее.<p>Этот метод часто применяется, когда необходимо производить деление по непростому модулю: тогда достаточно хранить число в виде степеней по простым делителям этого модуля, и ещё одного числа &mdash; остатка по этому же модулю.<p><p><h3 style="padding-top:15px;"> Длинная арифметика по системе простых модулей (Китайская теорема или схема Гарнера) </h3><p>Суть в том, что выбирается некоторая система модулей (обычно небольших, помещающихся в стандартные типы данных), и число хранится в виде вектора из остатков от его деления на каждый из этих модулей.<p>Как утверждает Китайская теорема об остатках, этого достаточно, чтобы однозначно хранить любое число в диапазоне от 0 до произведения этих модулей минус один. При этом имеется <a href="chinese_theorem.html">Алгоритм Гарнера</a>, который позволяет произвести это восстановление из модульного вида в обычную, "классическую", форму числа.<p>Таким образом, этот метод позволяет экономить память по сравнению с "классической" длинной арифметикой (хотя в некоторых случаях не столь радикально, как метод факторизации). Крому того, в модульном виде можно очень быстро производить сложения, вычитания и умножения, &mdash; все за асимптотически однаковое время, пропорциональное количеству модулей системы.<p>Однако всё это даётся ценой весьма трудоёмкого перевода числа из этого модульного вида в обычный вид, для чего, помимо немалых временных затрат, потребуется также реализация "классической" длинной арифметики с умножением.<p>Помимо этого, производить <b>деление</b> чисел в таком представлении по системе простых модулей не представляется возможным.<p><p><h2 style="padding-top:40px;"> Виды дробной длинной арифметики </h2><p>Операции над дробными числами встречаются в олимпиадных задачах гораздо реже, и работать с огромными дробными числами значительно сложнее, поэтому в олимпиадах встречается только специфическое подмножество дробной длинной арифметики.<p><p><h3 style="padding-top:15px;"> Длинная арифметика в несократимых дробях </h3><p>Число представляется в виде несократимой дроби <img class=tex src="../tex2png/cache/00b27cc89a05bcc9758d5a5dcfd967dd.png" alt="\frac{a}{b}">, где <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> &mdash; целые числа. Тогда все операции над дробными числами нетрудно свести к операциям над числителями и знаменателями этих дробей.<p>Обычно при этом для хранения числителя и знаменателя приходится также использовать длинную арифметику, но, впрочем, самый простой её вид &mdash; "классическая" длинная арифметика, хотя иногда оказывается достаточно встроенного 64-битного числового типа.<p><p><h3 style="padding-top:15px;"> Выделение позиции плавающей точки в отдельный тип </h3><p>Иногда в задаче требуется производить расчёты с очень большими либо очень маленькими числами, но при этом не допускать их переполнения. Встроенный <img class=tex src="../tex2png/cache/8b0472a11a25614b41e1b6a98ebc1f19.png" alt="8-10">-байтовый тип <img class=tex src="../tex2png/cache/9a674bdbb4c0af3f380acb194964317f.png" alt="double">, как известно, допускает значения экспоненты в диапазоне <img class=tex src="../tex2png/cache/1af1f3429da0fb6c41eb9b0dd6bb45e7.png" alt="[-308; 308]">, чего иногда может оказаться недостаточно.<p>Приём, собственно, очень простой &mdash; вводится ещё одна целочисленная переменная, отвечающая за экспоненту, а после выполнения каждой операции дробное число "нормализуется", т.е. возвращается в отрезок <img class=tex src="../tex2png/cache/ef79a92cad539477dbf46c3ff05331c7.png" alt="[0.1; 1)">, путём увеличения или уменьшения экспоненты.<p>При перемножении или делении двух таких чисел надо соответственно сложить либо вычесть их экспоненты. При сложении или вычитании перед выполнением этой операции числа следует привести к одной экспоненте, для чего одно из них домножается на <img class=tex src="../tex2png/cache/77eea7320c40609bb16e074403809134.png" alt="10"> в степени разности экспонент.<p>Наконец, понятно, что не обязательно выбирать <img class=tex src="../tex2png/cache/77eea7320c40609bb16e074403809134.png" alt="10"> в качестве основания экспоненты. Исходя из устройства встроенных типов с плавающей точкой, самым выгодным представляется класть основание равным <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2">.<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>