<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Нахождение кратчайших путей между заданной вершиной и всеми остальными вершинами алгоритмом Форда-Беллмана за O (N M)</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 19:37<br>редактировано: 24 Aug 2011 15:45</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="ford_bellman.html#" id="contents-hide">[скрыть]</a><a href="ford_bellman.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Алгоритм Форда-Беллмана</h1><p>Пусть дан ориентированный взвешенный граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами и <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> рёбрами, и указана некоторая вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Требуется найти <b>длины кратчайших путей</b> от вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> до всех остальных вершин.<p>В отличие от <a href="dijkstra.html">алгоритма Дейкстры</a>, этот алгоритм применим также и к графам, содержащим рёбра отрицательного веса. Впрочем, если граф содержит отрицательный цикл, то, понятно, кратчайшего пути до некоторых вершин может не существовать (по причине того, что вес кратчайшего пути должен быть равен минус бесконечности); впрочем, этот алгоритм можно модифицировать, чтобы он сигнализировал о наличии цикла отрицательного веса, или даже выводил сам этот цикл.<p>Алгоритм носит имя двух американских учёных: Ричарда <b>Беллмана</b> (Richard Bellman) и Лестера <b>Форда</b> (Lester Ford). Форд фактически изобрёл этот алгоритм в 1956 г. при изучении другой математической задачи, подзадача которой свелась к поиску кратчайшего пути в графе, и Форд дал набросок решающего эту задачу алгоритма. Беллман в 1958 г. опубликовал статью, посвящённую конкретно задаче нахождения кратчайшего пути, и в этой статье он чётко сформулировал алгоритм в том виде, в котором он известен нам сейчас.<p><p><h2 style="padding-top:40px;">Описание алгоритма</h2><p>Мы считаем, что граф не содержит цикла отрицательного веса. Случай наличия отрицательного цикла будет рассмотрен ниже в отдельном разделе.<p>Заведём массив расстояний <img class=tex src="../tex2png/cache/38d695526225bef162865943225ab63c.png" alt="d[0 \ldots n-1]">, который после отработки алгоритма будет содержать ответ на задачу. В начале работы мы заполняем его следующим образом: <img class=tex src="../tex2png/cache/2039f1b5f7152829991f0cb9c2ab56c6.png" alt="d[v] = 0">, а все остальные элементы <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]"> равны бесконечности <img class=tex src="../tex2png/cache/3d40198f44abce2dbb7a7eb7fba559c9.png" alt="\infty">.<p>Сам алгоритм Форда-Беллмана представляет из себя несколько фаз. На каждой фазе просматриваются все рёбра графа, и алгоритм пытается произвести <b>релаксацию</b> (relax, ослабление) вдоль каждого ребра <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> стоимости <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">. Релаксация вдоль ребра &mdash; это попытка улучшить значение <img class=tex src="../tex2png/cache/3a020ef79585c047a3ae043a50ccf33f.png" alt="d[b]"> значением <img class=tex src="../tex2png/cache/4bf5c9fe8b858392964a088aa8847e6f.png" alt="d[a] + c">. Фактически это значит, что мы пытаемся улучшить ответ для вершины <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">, пользуясь ребром <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> и текущим ответом для вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">.<p>Утверждается, что достаточно <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> фазы алгоритма, чтобы корректно посчитать длины всех кратчайших путей в графе (повторимся, мы считаем, что циклы отрицательного веса отсутствуют). Для недостижимых вершин расстояние <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]"> останется равным бесконечности <img class=tex src="../tex2png/cache/3d40198f44abce2dbb7a7eb7fba559c9.png" alt="\infty">.<p><p><h2 style="padding-top:40px;">Реализация</h2><p>Для алгоритма Форда-Беллмана, в отличие от многих других графовых алгоритмов, более удобно представлять граф в виде одного списка всех рёбер (а не <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> списков рёбер &mdash; рёбер из каждой вершины). В приведённой реализации заводится структура данных <img class=tex src="../tex2png/cache/7d2534953dd5361383f47378efadf1fe.png" alt="\rm edge"> для ребра. Входными данными для алгоритма являются числа <img class=tex src="../tex2png/cache/24f39e9f566eb07e53c3ed17c736a22c.png" alt="n, m">, список <img class=tex src="../tex2png/cache/2bf99a261c50e78801be552f1a6ebeb2.png" alt="e"> рёбер, и номер стартовой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Все номера вершин нумеруются с <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0"> по <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">.<p><h3 style="padding-top:15px;">Простейшая реализация</h3><p>Константа <img class=tex src="../tex2png/cache/a7edbf6ce4bf393cf5db4311b9f2d11c.png" alt="\rm INF"> обозначает число "бесконечность" &mdash; её надо подобрать таким образом, чтобы она заведомо превосходила все возможные длины путей.<p><pre class="notranslate cpp"><span class="kw4">struct</span> edge <span class="br0">&#123;</span>
	<span class="kw4">int</span> a, b, cost<span class="sy4">;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> n, m, v<span class="sy4">;</span>
vector<span class="sy1">&lt;</span>edge<span class="sy1">&gt;</span> e<span class="sy4">;</span>
<span class="kw4">const</span> <span class="kw4">int</span> INF <span class="sy1">=</span> <span class="nu0">1000000000</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> solve<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> d <span class="br0">&#40;</span>n, INF<span class="br0">&#41;</span><span class="sy4">;</span>
	d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>m<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="br0">&#93;</span> <span class="sy1">&lt;</span> INF<span class="br0">&#41;</span>
				d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">b</span><span class="br0">&#93;</span> <span class="sy1">=</span> min <span class="br0">&#40;</span>d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">b</span><span class="br0">&#93;</span>, d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="br0">&#93;</span> <span class="sy2">+</span> e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">cost</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="co1">// вывод d, например, на экран</span>
<span class="br0">&#125;</span></pre><p>Проверка "if (d[e[j].a] &lt; INF)" нужна, только если граф содержит рёбра отрицательного веса: без такой проверки бы происходили релаксации из вершин, до которых пути ещё не нашли, и появлялись бы некорректные расстояния вида <img class=tex src="../tex2png/cache/1659a6d9c47d17f755c03e2ec253896a.png" alt="\infty - 1">, <img class=tex src="../tex2png/cache/19999d3e8ed58047238a209cf1021f04.png" alt="\infty - 2">, и т.д.<p><h3 style="padding-top:15px;">Улучшенная реализация</h3><p>Этот алгоритм можно несколько ускорить: зачастую ответ находится уже за несколько фаз, а оставшиеся фазы никакой полезной работы не происходит, лишь впустую просматриваются все рёбра. Поэтому будем хранить флаг того, изменилось что-то на текущей фазе или нет, и если на какой-то фазе ничего не произошло, то алгоритм можно останавливать. (Эта оптимизация не улучшает асимптотику, т.е. на некоторых графах по-прежнему будут нужны все <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> фаза, но значительно ускоряет поведение алгоритма "в среднем", т.е. на случайных графах.)<p>С такой оптимизацией становится вообще ненужным ограничивать вручную число фаз алгоритма числом <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> &mdash; он сам остановится через нужное число фаз.<p><pre class="notranslate cpp"><span class="kw4">void</span> solve<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> d <span class="br0">&#40;</span>n, INF<span class="br0">&#41;</span><span class="sy4">;</span>
	d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">bool</span> any <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>m<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="br0">&#93;</span> <span class="sy1">&lt;</span> INF<span class="br0">&#41;</span>
				<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">b</span><span class="br0">&#93;</span> <span class="sy1">&gt;</span> d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="br0">&#93;</span> <span class="sy2">+</span> e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">cost</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
					d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">b</span><span class="br0">&#93;</span> <span class="sy1">=</span> d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="br0">&#93;</span> <span class="sy2">+</span> e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">cost</span><span class="sy4">;</span>
					any <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
				<span class="br0">&#125;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>any<span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="co1">// вывод d, например, на экран</span>
<span class="br0">&#125;</span></pre><p><h3 style="padding-top:15px;">Восстановление путей</h3><p>Рассмотрим теперь, как можно модифицировать алгоритм Форда-Беллмана так, чтобы он не только находил длины кратчайших путей, но и позволял восстанавливать сами кратчайшие пути.<p>Для этого заведём ещё один массив <img class=tex src="../tex2png/cache/9ff50b5f8fed0fbedd5d2edbbbd08679.png" alt="p[0 \ldots n-1]">, в котором для каждой вершины будем хранить её "предка", т.е. предпоследнюю вершину в кратчайшем пути, ведущем в неё. В самом деле, кратчайший путь до какой-то вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> является кратчайшим путём до какой-то вершины <img class=tex src="../tex2png/cache/eb2dd10d0d8f33cba2e46a80aac68c1f.png" alt="p[a]">, к которому приписали в конец вершину <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">.<p>Заметим, что алгоритм Форда-Беллмана работает по такой же логике: он, предполагая, что кратчайшее расстояние до одной вершины уже посчитано, пытается улучшить кратчайшее расстояние до другой вершины. Следовательно, в момент улучшения нам надо просто запоминать в <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]">, из какой вершины это улучшение произошло.<p>Приведём реализацию Форда-Беллмана с восстановлением пути до какой-то заданной вершины <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">:<p><pre class="notranslate cpp"><span class="kw4">void</span> solve<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> d <span class="br0">&#40;</span>n, INF<span class="br0">&#41;</span><span class="sy4">;</span>
	d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> p <span class="br0">&#40;</span>n, <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">bool</span> any <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>m<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="br0">&#93;</span> <span class="sy1">&lt;</span> INF<span class="br0">&#41;</span>
				<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">b</span><span class="br0">&#93;</span> <span class="sy1">&gt;</span> d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="br0">&#93;</span> <span class="sy2">+</span> e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">cost</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
					d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">b</span><span class="br0">&#93;</span> <span class="sy1">=</span> d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="br0">&#93;</span> <span class="sy2">+</span> e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">cost</span><span class="sy4">;</span>
					p<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">b</span><span class="br0">&#93;</span> <span class="sy1">=</span> e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="sy4">;</span>
					any <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
				<span class="br0">&#125;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>any<span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>t<span class="br0">&#93;</span> <span class="sy1">==</span> INF<span class="br0">&#41;</span>
		<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;No path from &quot;</span> <span class="sy1">&lt;&lt;</span> v <span class="sy1">&lt;&lt;</span> <span class="st0">&quot; to &quot;</span> <span class="sy1">&lt;&lt;</span> t <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;.&quot;</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> path<span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> cur<span class="sy1">=</span>t<span class="sy4">;</span> cur<span class="sy3">!</span><span class="sy1">=</span><span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> cur<span class="sy1">=</span>p<span class="br0">&#91;</span>cur<span class="br0">&#93;</span><span class="br0">&#41;</span>
			path.<span class="me1">push_back</span> <span class="br0">&#40;</span>cur<span class="br0">&#41;</span><span class="sy4">;</span>
		reverse <span class="br0">&#40;</span>path.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, path.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
		<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;Path from &quot;</span> <span class="sy1">&lt;&lt;</span> v <span class="sy1">&lt;&lt;</span> <span class="st0">&quot; to &quot;</span> <span class="sy1">&lt;&lt;</span> t <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;: &quot;</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>path.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> path<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&lt;&lt;</span> <span class="st0">' '</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Здесь мы сначала проходимся по предкам, начиная с вершины <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">, и сохраняем весь пройденный путь в списке <img class=tex src="../tex2png/cache/dd065ec366c22504eb4451430b3854d0.png" alt="\rm path">. В этом списке получается кратчайший путь от <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> до <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">, но в обратном порядке, поэтому мы вызываем <img class=tex src="../tex2png/cache/1a5d1b394d00175648cba193ac491862.png" alt="\rm reverse"> от него и затем выводим.<p><p><h2 style="padding-top:40px;">Доказательство алгоритма</h2><p>Во-первых, сразу заметим, что для недостижимых из <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> вершин алгоритм отработает корректно: для них метка <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]"> так и останется равной бесконечности (т.к. алгоритм Форда-Беллмана найдёт какие-то пути до всех достижимых из <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> вершин, а релаксация во всех остальных вершинах не произойдёт ни разу).<p>Докажем теперь следующее <b>утверждение</b>: после выполнения <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> фаз алгоритм Форда-Беллмана корректно находит все кратчайшие пути, длина которых (по числу рёбер) не превосходит <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">.<p>Иными словами, для любой вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> обозначим через <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> число рёбер в кратчайшем пути до неё (если таких путей несколько, можно взять любой). Тогда это утверждение говорит о том, что после <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> фаз этот кратчайший путь будет найден гарантированно. <p><b>Доказательство</b>. Рассмотрим произвольную вершину <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, до которой существует путь из стартовой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, и рассмотрим кратчайший путь до неё: <img class=tex src="../tex2png/cache/38d9d5057f48318707615947edbbdfd7.png" alt="(p_0=v, p_1, \ldots, p_k=a)">. Перед первой фазой кратчайший путь до вершины <img class=tex src="../tex2png/cache/3954e33da9fc352fb1f8b3f5dcef7832.png" alt="p_0=v"> найден корректно. Во время первой фазы ребро <img class=tex src="../tex2png/cache/5d7abeb25998b98428baac587287b00a.png" alt="(p_0,p_1)"> было просмотрено алгоритмом Форда-Беллмана, следовательно, расстояние до вершины <img class=tex src="../tex2png/cache/3004a92c72fcce1f45bc5afc7f7e1503.png" alt="p_1"> было корректно посчитано после первой фазы. Повторяя эти утверждения <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> раз, получаем, что после <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-й фазы расстояние до вершины <img class=tex src="../tex2png/cache/b149668bde2f5c4a06b44a0d25fa0662.png" alt="p_k=a"> посчитано корректно, что и требовалось доказать.<p>Последнее, что надо заметить &mdash; это то, что любой кратчайший путь не может иметь более <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> ребра. Следовательно, алгоритму достаточно произвести только <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> фазу. После этого ни одна релаксация гарантированно не может завершиться улучшением расстояния до какой-то вершины.<p><p><h2 style="padding-top:40px;">Случай отрицательного цикла</h2><p>Выше мы везде считали, что отрицательного цикла в графе нет (уточним, нас интересует отрицательный цикл, достижимый из стартовой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, а недостижимые циклы ничего в вышеописанном алгоритме не меняют). При его наличии возникают дополнительные сложности, связанные с тем, что расстояния до всех вершин на этом цикле, а также расстояния до достижимых из этого цикла вершин не определены &mdash; они должны быть равны минус бесконечности.<p>Нетрудно понять, что алгоритм Форда-Беллмана сможет <b>бесконечно делать релаксации</b> среди всех вершин этого цикла и вершин, достижимых из него. Следовательно, если не ограничивать число фаз числом <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">, то алгоритм будет работать бесконечно, постоянно улучшая расстояния до этих вершин.<p>Отсюда мы получаем <b>критерий наличия достижимого цикла отрицательного веса</b>: если после <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> фазы мы выполним ещё одну фазу, и на ней произойдёт хотя бы одна релаксация, то граф содержит цикл отрицательного веса, достижимый из <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">; в противном случае, такого цикла нет.<p>Более того, если такой цикл обнаружился, то алгоритм Форда-Беллмана можно модифицировать таким образом, чтобы он выводил сам этот цикл в виде последовательности вершин, входящих в него. Для этого достаточно запомнить номер вершины <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">, в которой произошла релаксация на <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">-ой фазе. Эта вершина будет либо лежать на цикле отрицательного веса, либо она достижима из него. Чтобы получить вершину, которая гарантированно лежит на цикле, достаточно, например, <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> раз пройти по предкам, начиная от вершины <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">. Получив номер <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> вершины, лежащей на цикле, надо пройтись от этой вершины по предкам, пока мы не вернёмся в эту же вершину <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> (а это обязательно произойдёт, потому что релаксации в цикле отрицательного веса происходят по кругу).<p>Реализация:<p><pre class="notranslate cpp"><span class="kw4">void</span> solve<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> d <span class="br0">&#40;</span>n, INF<span class="br0">&#41;</span><span class="sy4">;</span>
	d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> p <span class="br0">&#40;</span>n, <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw4">int</span> x<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		x <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>m<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="br0">&#93;</span> <span class="sy1">&lt;</span> INF<span class="br0">&#41;</span>
				<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">b</span><span class="br0">&#93;</span> <span class="sy1">&gt;</span> d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="br0">&#93;</span> <span class="sy2">+</span> e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">cost</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
					d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">b</span><span class="br0">&#93;</span> <span class="sy1">=</span> max <span class="br0">&#40;</span><span class="sy2">-</span>INF, d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="br0">&#93;</span> <span class="sy2">+</span> e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">cost</span><span class="br0">&#41;</span><span class="sy4">;</span>
					p<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">b</span><span class="br0">&#93;</span> <span class="sy1">=</span> e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="sy4">;</span>
					x <span class="sy1">=</span> e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">b</span><span class="sy4">;</span>
				<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">&#40;</span>x <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
		<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;No negative cycle from &quot;</span> <span class="sy1">&lt;&lt;</span> v<span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> y <span class="sy1">=</span> x<span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			y <span class="sy1">=</span> p<span class="br0">&#91;</span>y<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
		vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> path<span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> cur<span class="sy1">=</span>y<span class="sy4">;</span> <span class="sy4">;</span> cur<span class="sy1">=</span>p<span class="br0">&#91;</span>cur<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			path.<span class="me1">push_back</span> <span class="br0">&#40;</span>cur<span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>cur <span class="sy1">==</span> y <span class="sy3">&amp;&amp;</span> path.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">&gt;</span> <span class="nu0">1</span><span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
		reverse <span class="br0">&#40;</span>path.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, path.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
		<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;Negative cycle: &quot;</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>path.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> path<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&lt;&lt;</span> <span class="st0">' '</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Поскольку при наличии отрицательного цикла за <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> итераций алгоритма расстояния могли уйти далеко в минус (по всей видимости, до отрицательных чисел порядка <img class=tex src="../tex2png/cache/d82a123dfb07e110feef274cbae833cd.png" alt="-2^n">), в коде приняты дополнительные меры против такого целочисленного переполнения:<p><pre class="notranslate cpp">d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">b</span><span class="br0">&#93;</span> <span class="sy1">=</span> max <span class="br0">&#40;</span><span class="sy2">-</span>INF, d<span class="br0">&#91;</span>e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">a</span><span class="br0">&#93;</span> <span class="sy2">+</span> e<span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">cost</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p>В приведённой выше реализации ищется отрицательный цикл, достижимый из некоторой стартовой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">; однако алгоритм можно модифицировать, чтобы он искал просто <b>любой отрицательный цикл</b> в графе. Для этого надо положить все расстояния <img class=tex src="../tex2png/cache/a1fc654329221233840e1ce43c252646.png" alt="d[i]"> равными нулю, а не бесконечности &mdash; так, как будто бы мы ищем кратчайший путь изо всех вершин одновременно; на корректность обнаружения отрицательного цикла это не повлияет.<p>Дополнительно на тему этой задачи &mdash; см. отдельную статью <a href="negative_cycle.html"><b>"Поиск отрицательного цикла в графе"</b></a>.<p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Список задач, которые можно решить с помощью алгоритма Форда-Беллмана:<p><ul><p><li><a href="http://www.e-olimp.com.ua/problems/1453">E-OLIMP #1453 <b>"Форд-Беллман"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><p><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=364">UVA #423 <b>"MPI Maelstrom"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><p><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=7&page=show_problem&problem=475">UVA #534 <b>"Frogger"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=12&page=show_problem&problem=1040">UVA #10099 <b>"The Tourist Guide"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p><li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=456">UVA #515 <b>"King"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p></ul><p>См. также список задач в статье <a href="negative_cycle.html"><b>"Поиск отрицательного цикла"</b></a>.<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>