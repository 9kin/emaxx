<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Алгоритм Евклида</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 17:54<br>редактировано: 31 Aug 2011 14:48</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="euclid_algorithm.html#" id="contents-hide">[скрыть]</a><a href="euclid_algorithm.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Алгоритм Евклида нахождения НОД (наибольшего общего делителя)</h1><p>Даны два целых неотрицательных числа <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">. Требуется найти их наибольший общий делитель, т.е. наибольшее число, которое является делителем одновременно и <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">. На английском языке "наибольший общий делитель" пишется "greatest common divisor", и распространённым его обозначением является <img class=tex src="../tex2png/cache/4827c88d7cbaf5c36877b8b784eae8a8.png" alt="{\rm gcd}">:<p class=formula><img class=tex src="../tex2png/cache/e49f97b41b2449d76d33517b580fef68.png" alt=" {\rm gcd}(a,b) = \max_{k=1 \ldots \infty \ :\  k|[...]"></p>(здесь символом "<img class=tex src="../tex2png/cache/f5e094ec28e11473b748664f849d4bd5.png" alt="|">" обозначена делимость, т.е. "<img class=tex src="../tex2png/cache/a9246e7b4ff8f87f6fbd839e1f99f6b1.png" alt="k|a">" обозначает "<img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> делит <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">")<p>Когда оно из чисел равно нулю, а другое отлично от нуля, их наибольшим общим делителем, согласно определению, будет это второе число. Когда оба числа равны нулю, результат не определён (подойдёт любое бесконечно большое число), мы положим в этом случае наибольший общий делитель равным нулю. Поэтому можно говорить о таком правиле: если одно из чисел равно нулю, то их наибольший общий делитель равен второму числу.<p><b>Алгоритм Евклида</b>, рассмотренный ниже, решает задачу нахождения наибольшего общего делителя двух чисел <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> за <img class=tex src="../tex2png/cache/f4f7318efddd9946d9e8298b9afb2361.png" alt="O (\log \min(a,b))">.<p>Данный алгоритм был впервые описан в книге Евклида "Начала" (около 300 г. до н.э.), хотя, вполне возможно, этот алгоритм имеет более раннее происхождение.<p><p><h2 style="padding-top:40px;">Алгоритм</h2><p>Сам алгоритм чрезвычайно прост и описывается следующей формулой:<p><p class=formula><img class=tex src="../tex2png/cache/b8e1571eb429ef8ef1c06bc060dec3e7.png" alt=" {\rm gcd}(a,b) = \cases{ a, & {\rm if} b=0 \cr {\[...]"><p></p><p><h2 style="padding-top:40px;">Реализация</h2><p><pre class="notranslate cpp"><span class="kw4">int</span> gcd <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>b <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> a<span class="sy4">;</span>
	<span class="kw1">else</span>
		<span class="kw1">return</span> gcd <span class="br0">&#40;</span>b, a <span class="sy2">%</span> b<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Используя тернарный условный оператор C++, алгоритм можно записать ещё короче:<p><pre class="notranslate cpp"><span class="kw4">int</span> gcd <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">return</span> b <span class="sy4">?</span> gcd <span class="br0">&#40;</span>b, a <span class="sy2">%</span> b<span class="br0">&#41;</span> <span class="sy4">:</span> a<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Наконец, приведём и нерекурсивную форму алгоритма:<p><pre class="notranslate cpp"><span class="kw4">int</span> gcd <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		a <span class="sy2">%</span><span class="sy1">=</span> b<span class="sy4">;</span>
		swap <span class="br0">&#40;</span>a, b<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> a<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h2 style="padding-top:40px;">Доказательство корректности</h2><p>Сначала заметим, что при каждой итерации алгоритма Евклида его второй аргумент строго убывает, следовательно, посколько он неотрицательный, то алгоритм Евклида <b>всегда завершается</b>.<p>Для <b>доказательства корректности</b> нам необходимо показать, что <img class=tex src="../tex2png/cache/240cb8971429a8c79fd44e182c6b35b3.png" alt="{\rm gcd}(a,b) = {\rm gcd} (b, a\ {\rm mod}\ b)"> для любых <img class=tex src="../tex2png/cache/8f46c96cfee6bae1efacd11b4c37d5e9.png" alt="a \ge 0, b > 0">.<p>Покажем, что величина, стоящая в левой части равенства, делится на настоящую в правой, а стоящая в правой &mdash; делится на стоящую в левой. Очевидно, это будет означать, что левая и правая части совпадают, что и докажет корректность алгоритма Евклида.<p>Обозначим <img class=tex src="../tex2png/cache/b74f768228ddbcb4b42db206fce7fa9a.png" alt="d = {\rm gcd}(a,b)">. Тогда, по определению, <img class=tex src="../tex2png/cache/46c26882dd604ddcf55ce2f4a4fd722d.png" alt="d|a"> и <img class=tex src="../tex2png/cache/9e1ab0b6558a439a6f0cc6ba3b1bfa38.png" alt="d|b">.<p>Далее, разложим остаток от деления <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> на <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> через их частное:<p class=formula><img class=tex src="../tex2png/cache/ad604a58d5faf878aeaa5492d8f28d12.png" alt=" a\ {\rm mod}\ b = a - b \left\lfloor \frac{a}{b} [...]"></p><p>Но тогда отсюда следует:<p class=formula><img class=tex src="../tex2png/cache/85feaf22c5f69e1d19617467cdab7a04.png" alt=" d\ |\ (a\ {\rm mod}\ b) "></p><p>Итак, вспоминая утверждение <img class=tex src="../tex2png/cache/9e1ab0b6558a439a6f0cc6ba3b1bfa38.png" alt="d|b">, получаем систему:<p class=formula><img class=tex src="../tex2png/cache/9d785ea6dd075edc4a1849cf44affb22.png" alt=" \cases{ d\ |\ b, \cr d\ |\ (a\ {\rm mod}\ b) } "></p><p>Воспользуемся теперь следующим простым фактом: если для каких-то трёх чисел <img class=tex src="../tex2png/cache/3c8da67a892ae26bc75a1d3ff4f1df56.png" alt="p,q,r"> выполнено: <img class=tex src="../tex2png/cache/779d8098052f634620c4e5c7495e30bc.png" alt="p|q"> и <img class=tex src="../tex2png/cache/b8aec17c391081b9ef7b59994c5ba8b5.png" alt="p|r">, то выполняется и: <img class=tex src="../tex2png/cache/f49e6649595a756b48c91793e07edc4c.png" alt="p\ |\ {\rm gcd}(q,r)">. В нашей ситуации получаем:<p class=formula><img class=tex src="../tex2png/cache/9318355a27d52014ebd91c204579fb3c.png" alt=" d\ |\ {\rm gcd}(b, a\ {\rm mod}\ b) "></p>Или, подставляя вместо <img class=tex src="../tex2png/cache/30956e25578e9cb8f03bd9d36433020c.png" alt="d"> его определение как <img class=tex src="../tex2png/cache/f22d14e4e26705a233b54003cc439603.png" alt="{\rm gcd}(a,b)">, получаем:<p class=formula><img class=tex src="../tex2png/cache/256b72e6f755e9181250d20bf15cc4b7.png" alt=" {\rm gcd}(a,b)\ |\ {\rm gcd}(b, a\ {\rm mod}\ b) "></p><p>Итак, мы провели половину доказательства: показали, что левая часть делит правую. Вторая половина доказательства производится аналогично.<p><p><h2 style="padding-top:40px;">Время работы</h2><p>Время работы алгоритма оценивается <b>теоремой Ламе</b>, которая устанавливает удивительную связь алгоритма Евклида и последовательности Фибоначчи:<p>Если <img class=tex src="../tex2png/cache/976093d27f20e2020a10e5a967339488.png" alt="a > b \ge 1"> и <img class=tex src="../tex2png/cache/bf131aab22963dada95c720dddd28b35.png" alt="b < F_n"> для некоторого <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, то алгоритм Евклида выполнит не более <img class=tex src="../tex2png/cache/3c24e4e1066ea76ff7ba0fb29a761758.png" alt="n-2"> рекурсивных вызовов.<p>Более того, можно показать, что верхняя граница этой теоремы &mdash; оптимальная. При <img class=tex src="../tex2png/cache/2d40abd1e78d9d3d06820c935f772d10.png" alt="a = F_n, b = F_{n-1}"> будет выполнено именно <img class=tex src="../tex2png/cache/3c24e4e1066ea76ff7ba0fb29a761758.png" alt="n-2"> рекурсивных вызова. Иными словами, <b>последовательные числа Фибоначчи &mdash; наихудшие входные данные</b> для алгоритма Евклида.<p>Учитывая, что числа Фибоначчи растут экспоненциально (как константа в степени <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">), получаем, что алгоритм Евклида выполняется за <img class=tex src="../tex2png/cache/b58061885f6cd0ef3e91e498bac30e22.png" alt="O(\log \min(a,b))"> операций умножения.<p><h2 style="padding-top:40px;">НОК (наименьшее общее кратное)</h2><p>Вычисление наименьшего общего кратного (least common multiplier, lcm) сводится к вычислению <img class=tex src="../tex2png/cache/b247d903b4834caac61b28c1fad64958.png" alt="\rm gcd"> следующим простым утверждением:<p><p class=formula><img class=tex src="../tex2png/cache/1407548584803d912291dc28ee8f40ec.png" alt=" {\rm lcm}(a,b) = \frac{ a \cdot b }{ {\rm gcd}(a,[...]"></p><p>Таким образом, вычисление НОК также можно сделать с помощью алгоритма Евклида, с той же асимптотикой:<p><pre class="notranslate cpp"><span class="kw4">int</span> lcm <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">return</span> a <span class="sy2">/</span> gcd <span class="br0">&#40;</span>a, b<span class="br0">&#41;</span> <span class="sy2">*</span> b<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>(здесь выгодно сначала поделить на <img class=tex src="../tex2png/cache/b247d903b4834caac61b28c1fad64958.png" alt="\rm gcd">, а только потом домножать на <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">, поскольку это поможет избежать переполнений в некоторых случаях)<p><p><h2 style="padding-top:40px;">Литература</h2><p><ul><li><a href="http://www.e-maxx-ru.1gb.ru/bookz/files/cormen.djvu">Томас Кормен, Чарльз Лейзерсон, Рональд Ривест, Клиффорд Штайн. <b>Алгоритмы: Построение и анализ</b> [2005]</a></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>