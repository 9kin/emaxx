<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Алгоритм поиска мостов в графе за O (N + M)</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 19:28<br>редактировано: 23 Aug 2011 11:23</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="bridge_searching.html#" id="contents-hide">[скрыть]</a><a href="bridge_searching.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Поиск мостов</h1><p>Пусть дан неориентированный граф. Мостом называется такое ребро, удаление которого делает граф несвязным (или, точнее, увеличивает число компонент связности). Требуется найти все мосты в заданном графе.<p>Неформально эта задача ставится следующим образом: требуется найти на заданной карте дорог все "важные" дороги, т.е. такие дороги, что удаление любой из них приведёт к исчезновению пути между какой-то парой городов.<p>Ниже мы опишем алгоритм, основанный на <a href="dfs.html">поиске в глубину</a>, и работающий за время <img class=tex src="../tex2png/cache/d20d4ea468976eeb83adea753c1fd674.png" alt="O(n+m)">, где <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> &mdash; количество вершин, <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> &mdash; рёбер в графе.<p>Заметим, что на сайте также описан <a href="bridge_searching_online.html">онлайновый алгоритм поиска мостов</a> &mdash; в отличие от описанного здесь алгоритма, онлайновый алгоритм умеет поддерживать все мосты графа в изменяющемся графе (имеются в виду добавления новых рёбер).<p><p><h2 style="padding-top:40px;">Алгоритм</h2><p>Запустим <a href="dfs.html">обход в глубину</a> из произвольной вершины графа; обозначим её через <img class=tex src="../tex2png/cache/40e0e810bf54145c555375778ebb3918.png" alt="\rm root">. Заметим следующий <b>факт</b> (который несложно доказать):<p><ul><li>Пусть мы находимся в обходе в глубину, просматривая сейчас все рёбра из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Тогда, если текущее ребро <img class=tex src="../tex2png/cache/2f71535f4ca1feaf0a836a12914b1d88.png" alt="(v,to)"> таково, что из вершины <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to"> и из любого её потомка в дереве обхода в глубину нет обратного ребра в вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> или какого-либо её предка, то это ребро является мостом. В противном случае оно мостом не является. (В самом деле, мы этим условием проверяем, нет ли другого пути из <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> в <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to">, кроме как спуск по ребру <img class=tex src="../tex2png/cache/2f71535f4ca1feaf0a836a12914b1d88.png" alt="(v,to)"> дерева обхода в глубину.)</ul><p>Теперь осталось научиться проверять этот факт для каждой вершины эффективно. Для этого воспользуемся "временами входа в вершину", вычисляемыми <a href="dfs.html">алгоритмом поиска в глубину</a>.<p>Итак, пусть <img class=tex src="../tex2png/cache/2d830e71aff0814b8aa3d42124ec9dfb.png" alt="tin[v]"> &mdash; это время захода поиска в глубину в вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Теперь введём массив <img class=tex src="../tex2png/cache/c747353f9543d5d792489fcee7ff737d.png" alt="fup[v]">, который и позволит нам отвечать на вышеописанные запросы. Время <img class=tex src="../tex2png/cache/c747353f9543d5d792489fcee7ff737d.png" alt="fup[v]"> равно минимуму из времени захода в саму вершину <img class=tex src="../tex2png/cache/2d830e71aff0814b8aa3d42124ec9dfb.png" alt="tin[v]">, времён захода в каждую вершину <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">, являющуюся концом некоторого обратного ребра <img class=tex src="../tex2png/cache/280a9f96777575fe759d7ab0102ae1ed.png" alt="(v,p)">, а также из всех значений <img class=tex src="../tex2png/cache/a34ea9edd56d195a7dbdc722d58b8ca0.png" alt="fup[to]"> для каждой вершины <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to">, являющейся непосредственным сыном <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> в дереве поиска:<p><p class=formula><img class=tex src="../tex2png/cache/ec0a7c417df6f6cbc5ef762cd909127f.png" alt=" fup[v] = \min \cases{
tin[v], & \cr
tin[p], & {[...]"></p><p>(здесь "back edge" &mdash; обратное ребро, "tree edge" &mdash; ребро дерева)<p>Тогда, из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> или её потомка есть обратное ребро в её предка тогда и только тогда, когда найдётся такой сын <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to">, что <img class=tex src="../tex2png/cache/ffb96daaf2563fb46514458ca95e1e8f.png" alt="fup[to] \le tin[v]">. (Если <img class=tex src="../tex2png/cache/e09b4f1e0381f60523894681b2f62187.png" alt="fup[to] = tin[v]">, то это означает, что найдётся обратное ребро, приходящее точно в <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">; если же <img class=tex src="../tex2png/cache/4668070cee8195bb489b9cd83880c777.png" alt="fup[to] < tin[v]">, то это означает наличие обратного ребра в какого-либо предка вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">.)<p>Таким образом, если для текущего ребра <img class=tex src="../tex2png/cache/2f71535f4ca1feaf0a836a12914b1d88.png" alt="(v,to)"> (принадлежащего дереву поиска) выполняется <img class=tex src="../tex2png/cache/24650b41aaa4ee5d2bcd17ff02c76c90.png" alt="fup[to] > tin[v]">, то это ребро является мостом; в противном случае оно мостом не является.<p><p><h2 style="padding-top:40px;">Реализация</h2><p>Если говорить о самой реализации, то здесь нам нужно уметь различать три случая: когда мы идём по ребру дерева поиска в глубину, когда идём по обратному ребру, и когда пытаемся пойти по ребру дерева в обратную сторону. Это, соответственно, случаи:<p><ul><li><img class=tex src="../tex2png/cache/03b3b76b6aaa98e192434fcfb43b8fd2.png" alt="used[to]=false"> &mdash; критерий ребра дерева поиска;<li><img class=tex src="../tex2png/cache/0e2788b7fd3a152e7a01b7f51ce2f226.png" alt="used[to]=true\ \&\&\ to \ne parent"> &mdash; критерий обратного ребра;<li><img class=tex src="../tex2png/cache/b44e606054db96833dd49f901df1089d.png" alt="to=parent"> &mdash; критерий прохода по ребру дерева поиска в обратную сторону.</ul><p>Таким образом, для реализации этих критериев нам надо передавать в функцию поиска в глубину вершину-предка текущей вершины.<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> MAXN <span class="sy1">=</span> ...<span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> g<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">bool</span> used<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">int</span> timer, tin<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, fup<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> dfs <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> p <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	used<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
	tin<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> fup<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> timer<span class="sy2">++</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> to <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>to <span class="sy1">==</span> p<span class="br0">&#41;</span>  <span class="kw1">continue</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>used<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span>
			fup<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> min <span class="br0">&#40;</span>fup<span class="br0">&#91;</span>v<span class="br0">&#93;</span>, tin<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">else</span> <span class="br0">&#123;</span>
			dfs <span class="br0">&#40;</span>to, v<span class="br0">&#41;</span><span class="sy4">;</span>
			fup<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> min <span class="br0">&#40;</span>fup<span class="br0">&#91;</span>v<span class="br0">&#93;</span>, fup<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>fup<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">&gt;</span> tin<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span>
				IS_BRIDGE<span class="br0">&#40;</span>v,to<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> find_bridges<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	timer <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		used<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>
			dfs <span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Здесь основная функция для вызова &mdash; это <img class=tex src="../tex2png/cache/ead4c1b2836fe2d28bf8610923158409.png" alt="{\rm find\_bridges}"> &mdash; она производит необходимую инициализацию и запуск обхода в глубину для каждой компоненты связности графа.<p>При этом <img class=tex src="../tex2png/cache/952a3f7f5be25d2bc9e7965f67f4e41d.png" alt="{\rm IS\_BRIDGE}(a,b)"> &mdash; это некая функция, которая будет реагировать на то, что ребро <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> является мостом, например, выводить это ребро на экран.<p>Константе <img class=tex src="../tex2png/cache/67a995668e106ba277ea2aceb6b51ea1.png" alt="{\rm MAXN}"> в самом начале кода следует задать значение, равное максимально возможному числу вершин во входном графе.<p>Стоит заметить, что эта реализация некорректно работает при наличии в графе <b>кратных рёбер</b>: она фактически не обращает внимания, кратное ли ребро или оно единственно. Разумеется, кратные рёбра не должны входить в ответ, поэтому при вызове <img class=tex src="../tex2png/cache/7cf7cfb3d4ba6315f8d4bcf78fa94def.png" alt="\rm IS\_BRIDGE"> можно проверять дополнительно, не кратное ли ребро мы хотим добавить в ответ. Другой способ &mdash; более аккуратная работа с предками, т.е. передавать в <img class=tex src="../tex2png/cache/8b622758482855a6c472dce8332c38fd.png" alt="\rm dfs"> не вершину-предка, а номер ребра, по которому мы вошли в вершину (для этого надо будет дополнительно хранить номера всех рёбер).<p><p><h2 style="padding-top:40px;">Задачи в online judges</h2><p>Список задач, в которых требуется искать мосты:<p><ul><p><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=737">UVA #796 <b>"Critical Links"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><p><li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=551">UVA #610 <b>"Street Directions"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>