<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Модификация метода Проталкивания предпотока</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 22:53<br>редактировано: 14 Oct 2011 0:31</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="preflow_push_faster.html#" id="contents-hide">[скрыть]</a><a href="preflow_push_faster.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Модификация метода Проталкивания предпотока для нахождения максимального потока за O (N<sup>3</sup>)</h1>

<p>Предполагается, что вы уже прочитали <a href="preflow_push.html">Метод Проталкивания предпотока нахождения максимального потока за O (N<sup>4</sup>)</a>.</p>
<h2>Описание</h2>
<p>Модификация чрезвычайно проста: на каждой итерации среди всех переполненных вершин мы выбираем только те вершины, которые имеют <b>набольшую высоту</b>, и применяем проталкивание/поднятие только к этим вершинам. Более того, для выбора вершин с наибольшей высотой нам не понадобятся никакие структуры данных, достаточно просто хранить список вершин с наибольшей высотой и просто пересчитывать его, если все вершины из этого списка были обработаны (тогда в список добавятся вершины с уже меньшей высотой), а при появлении новой переполненной вершины с большей высотой, чем в списке, очищать список и добавлять вершину в список.</p>
<p>Несмотря на простоту, эта модификация позволяет снизить асимптотику на целый порядок. Если быть точным, асимптотика получившего алгоритма равна <b>O (N M + N<sup>2</sup> sqrt (M))</b>, что в худшем случае составляет <b>O (N<sup>3</sup>)</b>.</p>
<p>Эта модификация была предложена Черияном (Cheriyan) и Махешвари (Maheshvari) в 1989 г.</p>
<h2>Реализация</h2>
<p>Здесь приведена готовая реализация этого алгоритма.</p>
<p>Отличие от обычного алгоритма проталкивания - только в наличии массива maxh, в котором будут храниться номера переполненных вершин с максимальной высотой. Размер массива указан в переменной sz. Если на какой-то итерации оказывается, что этот массив пустой (sz==0), то мы заполняем его (просто проходя по всем вершинам); если после этого массив по-прежнему пустой, то переполненных вершин нет, и алгоритм останавливается. Иначе мы проходим по вершинам в этом списке, применяя к ним проталкивание или поднятие. После выполнения операции проталкивания текущая вершина может перестать быть переполненной, в этом случае удаляем её из списка maxh. Если после какой-то операции поднятия высота текущей вершины становится больше высоты вершин в списке maxh, то мы очищаем список (sz=0), и сразу переходим к следующей итерации алгоритма проталкивания (на которой будет построен новый список maxh).</p>
<pre>const int INF = 1000*1000*1000;

int main() {

	int n;
	vector &lt; vector&lt;int> > c (n, vector&lt;int> (n));
	int s, t;
	... чтение n, c, s, t ...

	vector&lt;int> e (n);
	vector&lt;int> h (n);
	h[s] = n-1;
	vector &lt; vector&lt;int> > f (n, vector&lt;int> (n));

	for (int i=0; i&lt;n; ++i) {
		f[s][i] = c[s][i];
		f[i][s] = -f[s][i];
		e[i] = c[s][i];
	}

	vector&lt;int> maxh (n);
	int sz = 0;
	for (;;) {
		if (!sz)
			for (int i=0; i&lt;n; ++i)
				if (i != s && i != t && e[i] > 0) {
					if (sz && h[i] > h[maxh[0]])
						sz = 0;
					if (!sz || h[i] == h[maxh[0]])
						maxh[sz++] = i;
				}
		if (!sz)  break;
		while (sz) {
			int i = maxh[sz-1];
			bool pushed = false;
			for (int j=0; j&lt;n && e[i]; ++j)
				if (c[i][j]-f[i][j] > 0 && h[i] == h[j]+1) {
					pushed = true;
					int addf = min (c[i][j]-f[i][j], e[i]);
					f[i][j] += addf,  f[j][i] -= addf;
					e[i] -= addf,  e[j] += addf;
					if (e[i] == 0)  --sz;
				}
			if (!pushed) {
				h[i] = INF;
				for (int j=0; j&lt;n; ++j)
					if (c[i][j]-f[i][j] > 0 && h[j]+1 &lt; h[i])
						h[i] = h[j]+1;
				if (h[i] > h[maxh[0]]) {
					sz = 0;
					break;
				}
			}
		}
	}

	... вывод потока f ...

}</pre><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>