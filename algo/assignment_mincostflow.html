<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Задача о назначениях. Решение с помощью min-cost-flow</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 22:58<br>редактировано: 8 Sep 2011 17:05</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="assignment_mincostflow.html#" id="contents-hide">[скрыть]</a><a href="assignment_mincostflow.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Задача о назначениях. Решение с помощью min-cost-flow</h1>

<p>Задача имеет две эквивалентные постановки:</p>
<ul>
<li>Дана квадратная матрица A[1..N,1..N]. Нужно выбрать в ней N элементов так, чтобы в каждой строке и столбце был выбран ровно один элемент, а сумма значений этих элементов была наименьшей.</li>
<li>Имеется N заказов и N станков. Про каждый заказ известна стоимость его изготовления на каждом станке. На каждом станке можно выполнять только один заказ. Требуется распределить все заказы по станкам так, чтобы минимизировать суммарную стоимость.</li>
</ul>
<p>Здесь мы рассмотрим решение задачи на основе алгоритма <a href="min_cost_flow.html">нахождения потока минимальной стоимости (min-cost-flow)</a>, решив задачу о назначениях за <b>O (N<sup>5</sup>)</b>.</p>
<h2>Описание</h2>
<p><b>Построим</b> двудольную сеть: имеется исток S, сток T, в первой доле находятся N вершин (соответствующие строкам матрицы или заказам), во второй - тоже N вершин (соответствующие столбцам матрицы или станкам). Между каждой вершиной i первой доли и каждой вершиной j второй доли проведём ребро с пропускной способностью 1 и стоимостью A<sub>ij</sub>. От истока S проведём рёбра ко всем вершинам i первой доли с пропускной способностью 1 и стоимостью 0. От каждой вершины второй доли j к стоку T проведём ребро с пропускной способностью 1 и стоимостью 0.</p>
<p>Найдём в полученной сети максимальный поток минимальной стоимости. Очевидно, величина потока будет равна N. Далее, очевидно, что для каждой вершины i из первой доли найдётся ровно одна вершина j из второй доли, такая, что поток F<sub>ij</sub> = 1. Наконец, очевидно, это взаимно однозначное соответствие между вершинами первой доли и вершинами второй доли является решением задачи (поскольку найденный поток имеет минимальную стоимость, то сумма стоимостей выбранных рёбер будет наименьшей из возможных, что и является критерием оптимальности).</p>
<p>Асимптотика этого решения задачи о назначениях зависит от того, каким алгоритмом производится поиск максимального потока минимальной стоимости. Асимптотика составит <b>O (N<sup>3</sup>)</b> при использовании алгоритма Дейкстры или O (N<sup>4</sup>) при использовании алгоритма Форда-Беллмана.</p>
<h2>Реализация</h2>
<p>Приведённая здесь реализация длинноватая, возможно, её можно значительно сократить.</p>
<pre>typedef vector&lt;int> vint;
typedef vector&lt;vint> vvint;

const int INF = 1000*1000*1000;


int main()
{
	int n;
	vvint a (n, vint (n));
	... чтение a ...

	int m = n * 2 + 2;
	vvint f (m, vint (m));
	int s = m-2, t = m-1;
	int cost = 0;
	for (;;)
	{
		vector&lt;int> dist (m, INF);
		vector&lt;int> p (m);
		vector&lt;int> type (m, 2);
		deque&lt;int> q;
		dist[s] = 0;
		p[s] = -1;
		type[s] = 1;
		q.push_back (s);
		for (; !q.empty(); )
		{
			int v = q.front(); q.pop_front();
			type[v] = 0;
			if (v == s)
			{
				for (int i=0; i&lt;n; ++i)
					if (f[s][i] == 0)
					{
						dist[i] = 0;
						p[i] = s;
						type[i] = 1;
						q.push_back (i);
					}
			}
			else
			{
				if (v &lt; n)
				{
					for (int j=n; j&lt;n+n; ++j)
						if (f[v][j] &lt; 1 && dist[j] > dist[v] + a[v][j-n])
						{
							dist[j] = dist[v] + a[v][j-n];
							p[j] = v;
							if (type[j] == 0)
								q.push_front (j);
							else if (type[j] == 2)
								q.push_back (j);
							type[j] = 1;
						}
				}
				else
				{
					for (int j=0; j&lt;n; ++j)
						if (f[v][j] &lt; 0 && dist[j] > dist[v] - a[j][v-n])
						{
							dist[j] = dist[v] - a[j][v-n];
							p[j] = v;
							if (type[j] == 0)
								q.push_front (j);
							else if (type[j] == 2)
								q.push_back (j);
							type[j] = 1;
						}
				}
			}
		}

		int curcost = INF;
		for (int i=n; i&lt;n+n; ++i)
			if (f[i][t] == 0 && dist[i] &lt; curcost)
			{
				curcost = dist[i];
				p[t] = i;
			}
		if (curcost == INF) break;
		cost += curcost;
		for (int cur=t; cur!=-1; cur=p[cur])
		{
			int prev = p[cur];
			if (prev!=-1)
				f[cur][prev] = - (f[prev][cur] = 1);
		}

	}

	printf ("%d\n", cost);
	for (int i=0; i&lt;n; ++i)
		for (int j=0; j&lt;n; ++j)
			if (f[i][j+n] == 1)
				printf ("%d ", j+1);

}</pre><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>