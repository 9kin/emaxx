<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Алгоритм Ахо-Корасик</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 14 Sep 2008 14:08<br>редактировано: 24 Aug 2011 18:21</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="aho_corasick.html#" id="contents-hide">[скрыть]</a><a href="aho_corasick.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Алгоритм Ахо-Корасик </h1><p>Пусть дан набор строк в алфавите размера <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> суммарной длины <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m">. Алгоритм Ахо-Корасик строит для этого набора строк структуру данных "бор", а затем по этому бору строит автомат, всё за <img class=tex src="../tex2png/cache/08faf3b47d5f052931b9f4e825287711.png" alt="O (m)"> времени и <img class=tex src="../tex2png/cache/079d422585b16b0b712b9deddca625b7.png" alt="O (m k)"> памяти. Полученный автомат уже может использоваться в различных задачах, простейшая из которых &mdash; это нахождение всех вхождений каждой строки из данного набора в некоторый текст за линейное время.<p>Данный алгоритм был предложен канадским учёным Альфредом Ахо (Alfred Vaino Aho) и учёным Маргарет Корасик (Margaret John Corasick) в 1975 г.<p><p><h2 style="padding-top:40px;"> Бор. Построение бора </h2><p>Формально, <b>бор</b> &mdash; это дерево с корнем в некоторой вершине <img class=tex src="../tex2png/cache/5c71d29569d71c2fc7c47bf89e43e5b9.png" alt="\rm Root">, причём каждое ребро дерево подписано некоторой буквой. Если мы рассмотрим список рёбер, выходящих из данной вершины (кроме ребра, ведущего в предка), то все рёбра должны иметь разные метки.<p>Рассмотрим в боре любой путь из корня; выпишем подряд метки рёбер этого пути. В результате мы получим некоторую строку, которая соответствует этому пути. Если же мы рассмотрим любую вершину бора, то ей поставим в соответствие строку, соответствующую пути из корня до этой вершины.<p>Каждая вершина бора также имеет флаг <img class=tex src="../tex2png/cache/9c71249e334d7e5cfc62cb9630bc7bc6.png" alt="\rm leaf">, который равен <img class=tex src="../tex2png/cache/d04c5eb60a53293d4878d3c73c349aa6.png" alt="\rm true">, если в этой вершине оканчивается какая-либо строка из данного набора.<p>Соответственно, <b>построить бор</b> по данному набору строк &mdash; значит построить такой бор, что каждой <img class=tex src="../tex2png/cache/9c71249e334d7e5cfc62cb9630bc7bc6.png" alt="\rm leaf">-вершине будет соответствовать какая-либо строка из набора, и, наоборот, каждой строке из набора будет соответствовать какая-то <img class=tex src="../tex2png/cache/9c71249e334d7e5cfc62cb9630bc7bc6.png" alt="\rm leaf">-вершина.<p>Опишем теперь, <b>как построить бор</b> по заданному набору строк за линейное время относительно их суммарной длины.<p>Введём структуру, соответствующую вершинам бора:<p><pre class="notranslate cpp"><span class="kw4">struct</span> vertex <span class="br0">&#123;</span>
	<span class="kw4">int</span> next<span class="br0">&#91;</span>K<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw4">bool</span> leaf<span class="sy4">;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
&nbsp;
vertex t<span class="br0">&#91;</span>NMAX<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">int</span> sz<span class="sy4">;</span></pre><p>Т.е. мы будем хранить бор в виде массива <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> (количество элементов в массиве - это sz) структур <img class=tex src="../tex2png/cache/cb80e56a4d8bb9762e1793905fb3fb46.png" alt="\rm vertex">. Структура <img class=tex src="../tex2png/cache/cb80e56a4d8bb9762e1793905fb3fb46.png" alt="\rm vertex"> содержит флаг <img class=tex src="../tex2png/cache/9c71249e334d7e5cfc62cb9630bc7bc6.png" alt="\rm leaf">, и рёбра в виде массива <img class=tex src="../tex2png/cache/9cc87e417463ec69c071970ede439246.png" alt="\rm next[]">, где <img class=tex src="../tex2png/cache/3adba0dd8cc3229a23e565f88b5f3e6f.png" alt="\rm next[i]"> &mdash; указатель на вершину, в которую ведёт ребро по символу <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, или <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1">, если такого ребра нет.<p>Вначале бор состоит только из одной вершины &mdash; корня (договоримся, что корень всегда имеет в массиве <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> индекс <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0">). Поэтому <b>инициализация</b> бора такова:<p><pre class="notranslate cpp"><span class="kw3">memset</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">next</span>, <span class="nu0">255</span>, <span class="kw3">sizeof</span> t<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#41;</span><span class="sy4">;</span>
sz <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span></pre><p>Теперь реализуем функцию, которая будет <b>добавлять в бор</b> заданную строку <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">. Реализация крайне проста: мы встаём в корень бора, смотрим, есть ли из корня переход по букве <img class=tex src="../tex2png/cache/0fd46c7915afe8ed329c334622675f05.png" alt="s[0]">: если переход есть, то просто переходим по нему в другую вершину, иначе создаём новую вершину и добавляем переход в эту вершину по букве <img class=tex src="../tex2png/cache/0fd46c7915afe8ed329c334622675f05.png" alt="s[0]">. Затем мы, стоя в какой-то вершине, повторяем процесс для буквы <img class=tex src="../tex2png/cache/3948b4e38f8029d0b77846a4986edcab.png" alt="s[1]">, и т.д. После окончания процесса помечаем последнюю посещённую вершину флагом <img class=tex src="../tex2png/cache/a0119a342917ca9eb92c0a9cf0cef25d.png" alt="\rm leaf = true">.<p><pre class="notranslate cpp"><span class="kw4">void</span> add_string <span class="br0">&#40;</span><span class="kw4">const</span> string <span class="sy3">&amp;</span> s<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> v <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>s.<span class="me1">length</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">char</span> c <span class="sy1">=</span> s<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy2">-</span><span class="st0">'a'</span><span class="sy4">;</span> <span class="co1">// в зависимости от алфавита</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw3">memset</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span>sz<span class="br0">&#93;</span>.<span class="me1">next</span>, <span class="nu0">255</span>, <span class="kw3">sizeof</span> t<span class="br0">&#91;</span>sz<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#41;</span><span class="sy4">;</span>
			t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span> <span class="sy1">=</span> sz<span class="sy2">++</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
		v <span class="sy1">=</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">leaf</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Линейное время работы, а также линейное количество вершин в боре очевидны. Поскольку на каждую вершину приходится <img class=tex src="../tex2png/cache/f778ac33c63975fd06a1729fbcd08625.png" alt="O (k)"> памяти, то использование памяти есть <img class=tex src="../tex2png/cache/a51f60cb3a9fe30aec7b8bc1c71a5296.png" alt="O (n k)">.<p>Потребление памяти можно уменьшить до линейного (<img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)">), но за счёт увеличения асимптотики работы до <img class=tex src="../tex2png/cache/a8770007d7bdb23d5616ac746b0f45ad.png" alt="O (n \log k)">. Для этого достаточно хранить переходы <img class=tex src="../tex2png/cache/06b3d31d44619b055fe808361c9a810c.png" alt="\rm next"> не массивом, а отображением <img class=tex src="../tex2png/cache/f45056babb14bf73aed9f4c8db10613a.png" alt="\rm map<char,int>">.<p><p><h2 style="padding-top:40px;"> Построение автомата </h2><p>Пусть мы построили бор для заданного набора строк. Посмотрим на него теперь немного с другой стороны. Если мы рассмотрим любую вершину, то строка, которая соответствует ей, является префиксом одной или нескольких строк из набора; т.е. каждую вершину бора можно понимать как позицию в одной или нескольких строках из набора.<p>Фактически, вершины бора можно понимать как состояния <b>конечного детерминированного автомата</b>. Находясь в каком-либо состоянии, мы под воздействием какой-то входной буквы переходим в другое состояние &mdash; т.е. в другую позицию в наборе строк. Например, если в боре находится только строка <img class=tex src="../tex2png/cache/95d59d6ab9fb4f33f453c2c12fd0c4d1.png" alt=""abc""> и мы стоим в состоянии <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2"> (которому соответствует строка <img class=tex src="../tex2png/cache/a06b0f168662271f817ca9b6ddfbc80f.png" alt=""ab"">), то под воздействием буквы <img class=tex src="../tex2png/cache/9c5240493c2c12195b21d1b77f43a5bc.png" alt=""c""> мы перейдём в состояние <img class=tex src="../tex2png/cache/0e96f2a3dff7da2f31d78c5306207a14.png" alt="3">.<p>Т.е. мы можем понимать рёбра бора как переходы в автомате по соответствующей букве. Однако одними только рёбрами бора нельзя ограничиваться. Если мы пытаемся выполнить переход по какой-либо букве, а соответствующего ребра в боре нет, то мы тем не менее должны перейти в какое-то состояние.<p>Более строго, пусть мы находимся в состоянии <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">, которому соответствует некоторая строка <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">, и хотим выполнить переход по символу <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">. Если в боре из вершины <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> есть переход по букве <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">, то мы просто переходим по этому ребру и попадаем в вершину, которой соответствует строка <img class=tex src="../tex2png/cache/608a9ad2f32c3c9149027f5e58fafeb1.png" alt="tc">. Если же такого ребра нет, то мы должны найти состояние, соответствующее наидлиннейшему собственному суффиксу строки <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> (наидлиннейшему из имеющихся в боре), и попытаться выполнить переход по букве <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> из него.<p>Например, пусть бор построен по строкам <img class=tex src="../tex2png/cache/a06b0f168662271f817ca9b6ddfbc80f.png" alt=""ab""> и <img class=tex src="../tex2png/cache/200713e3ec2616417a514204ea67964a.png" alt=""bc"">, и мы под воздействием строки <img class=tex src="../tex2png/cache/a06b0f168662271f817ca9b6ddfbc80f.png" alt=""ab""> перешли в некоторое состояние, являющееся листом. Тогда под воздействием буквы <img class=tex src="../tex2png/cache/9c5240493c2c12195b21d1b77f43a5bc.png" alt=""c""> мы вынуждены перейти в состояние, соответствующее строке <img class=tex src="../tex2png/cache/8574c3e494378babb6ec1a094a18bf3d.png" alt=""b"">, и только оттуда выполнить переход по букве <img class=tex src="../tex2png/cache/9c5240493c2c12195b21d1b77f43a5bc.png" alt=""c"">.<p><b>Суффиксная ссылка</b> для каждой вершины <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> &mdash; это вершина, в которой оканчивается наидлиннейший собственный суффикс строки, соответствующей вершине <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">. Единственный особый случай &mdash; корень бора; для удобства суффиксную ссылку из него проведём в себя же. Теперь мы можем переформулировать утверждение по поводу переходов в автомате так: пока из текущей вершины бора нет перехода по соответствующей букве (или пока мы не придём в корень бора), мы должны переходить по суффиксной ссылке.<p>Таким образом, мы свели задачу построения автомата к задаче нахождения суффиксных ссылок для всех вершин бора. Однако строить эти суффиксные ссылки мы будем, как ни странно, наоборот, с помощью построенных в автомате переходов.<p>Заметим, что если мы хотим узнать суффиксную ссылку для некоторой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, то мы можем перейти в предка <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> текущей вершины (пусть <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> &mdash; буква, по которой из <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> есть переход в <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">), затем перейти по его суффиксной ссылке, а затем из неё выполнить переход в автомате по букве <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">.<p>Таким образом, задача нахождения перехода свелась к задаче нахождения суффиксной ссылки, а задача нахождения суффиксной ссылки &mdash; к задаче нахождения суффиксной ссылки и перехода, но уже для более близких к корню вершин. Мы получили рекурсивную зависимость, но не бесконечную, и, более того, разрешить которую можно за линейное время.<p>Перейдём теперь к <b>реализации</b>. Заметим, что нам теперь понадобится для каждой вершины хранить её предка <img class=tex src="../tex2png/cache/01012a0b065f56db970f4a6b76534692.png" alt="\rm p">, а также символ <img class=tex src="../tex2png/cache/eb01e65c2c4b5b1654e27064912da160.png" alt="\rm pch">, по которому из предка есть переход в нашу вершину. Также в каждой вершине будем хранить <img class=tex src="../tex2png/cache/89ddaa2c6f5b4d0c7b5a9209be5aa584.png" alt="\rm int~link"> &mdash; суффиксная ссылка (или <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1">, если она ещё не вычислена), и массив <img class=tex src="../tex2png/cache/ffada11aaf6bdc44e70eda0477cf14b0.png" alt="\rm int~go[k]"> &mdash; переходы в автомате по каждому из символов (опять же, если элемент массива равен <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1">, то он ещё не вычислен). Приведём теперь полную реализацию всех необходимых функций:<p><pre class="notranslate cpp"><span class="kw4">struct</span> vertex <span class="br0">&#123;</span>
	<span class="kw4">int</span> next<span class="br0">&#91;</span>K<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw4">bool</span> leaf<span class="sy4">;</span>
	<span class="kw4">int</span> p<span class="sy4">;</span>
	<span class="kw4">char</span> pch<span class="sy4">;</span>
	<span class="kw4">int</span> link<span class="sy4">;</span>
	<span class="kw4">int</span> go<span class="br0">&#91;</span>K<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
&nbsp;
vertex t<span class="br0">&#91;</span>NMAX<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">int</span> sz<span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> init<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	t<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">p</span> <span class="sy1">=</span> t<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">link</span> <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw3">memset</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">next</span>, <span class="nu0">255</span>, <span class="kw3">sizeof</span> t<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw3">memset</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">go</span>, <span class="nu0">255</span>, <span class="kw3">sizeof</span> t<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">go</span><span class="br0">&#41;</span><span class="sy4">;</span>
	sz <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> add_string <span class="br0">&#40;</span><span class="kw4">const</span> string <span class="sy3">&amp;</span> s<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> v <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>s.<span class="me1">length</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">char</span> c <span class="sy1">=</span> s<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy2">-</span><span class="st0">'a'</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw3">memset</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span>sz<span class="br0">&#93;</span>.<span class="me1">next</span>, <span class="nu0">255</span>, <span class="kw3">sizeof</span> t<span class="br0">&#91;</span>sz<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="kw3">memset</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span>sz<span class="br0">&#93;</span>.<span class="me1">go</span>, <span class="nu0">255</span>, <span class="kw3">sizeof</span> t<span class="br0">&#91;</span>sz<span class="br0">&#93;</span>.<span class="me1">go</span><span class="br0">&#41;</span><span class="sy4">;</span>
			t<span class="br0">&#91;</span>sz<span class="br0">&#93;</span>.<span class="me1">link</span> <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
			t<span class="br0">&#91;</span>sz<span class="br0">&#93;</span>.<span class="me1">p</span> <span class="sy1">=</span> v<span class="sy4">;</span>
			t<span class="br0">&#91;</span>sz<span class="br0">&#93;</span>.<span class="me1">pch</span> <span class="sy1">=</span> c<span class="sy4">;</span>
			t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span> <span class="sy1">=</span> sz<span class="sy2">++</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
		v <span class="sy1">=</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">leaf</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> go <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">char</span> c<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> get_link <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">link</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>v <span class="sy1">==</span> <span class="nu0">0</span> <span class="sy3">||</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">p</span> <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
			t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">link</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">link</span> <span class="sy1">=</span> go <span class="br0">&#40;</span>get_link <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">p</span><span class="br0">&#41;</span>, t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">pch</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">return</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">link</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> go <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">char</span> c<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">go</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
			t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">go</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span> <span class="sy1">=</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">go</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy1">==</span><span class="nu0">0</span> <span class="sy4">?</span> <span class="nu0">0</span> <span class="sy4">:</span> go <span class="br0">&#40;</span>get_link <span class="br0">&#40;</span>v<span class="br0">&#41;</span>, c<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">return</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">go</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Нетрудно понять, что, за счёт запоминания найденных суффиксных ссылок и переходов, суммарное время нахождения всех суффиксных ссылок и переходов будет линейным.<p><p><h2 style="padding-top:40px;"> Применения </h2><p><h3 style="padding-top:15px;"> Поиск всех строк из заданного набора в тексте </h3><p>Дан набор строк, и дан текст. Требуется вывести все вхождения всех строк из набора в данный текст за время <img class=tex src="../tex2png/cache/a94777b137661720ebb99813b09767ba.png" alt="O ({\rm Len + Ans})">, где <img class=tex src="../tex2png/cache/2441c57c8f25d126f73785332a71bc35.png" alt="\rm Len"> &mdash; длина текста, <img class=tex src="../tex2png/cache/4b607591e9fdb6850a755ade5895ecd4.png" alt="\rm Ans"> &mdash; размер ответа.<p>Построим по данному набору строк бор. Будем теперь обрабатывать текст по одной букве, перемещаясь соответствующим образом по дереву, фактически &mdash; по состояниям автомата. Изначально мы находимся в корне дерева. Пусть мы на очередном шаге мы находимся в состоянии <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, и очередная буква текста <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">. Тогда следует переходить в состояние <img class=tex src="../tex2png/cache/8946e922ea5471498dae3a076721af10.png" alt="{\rm go} (v, c)">, тем самым либо увеличивая на <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"> длину текущей совпадающей подстроки, либо уменьшая её, проходя по суффиксной ссылке.<p>Как теперь узнать по текущему состоянию <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, имеется ли совпадение с какими-то строками из набора? Во-первых, понятно, что если мы стоим в помеченной вершине (<img class=tex src="../tex2png/cache/200677db73a46657a24f3b7990aca31f.png" alt="\rm leaf=true">), то имеется совпадение с тем образцом, который в боре оканчивается в вершине <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Однако это далеко не единственный возможный случай достижения совпадения: если мы, двигаясь по суффиксным ссылкам, мы можем достигнуть одной или нескольких помеченных вершин, то совпадение также будет, но уже для образцов, оканчивающихся в этих состояниях. Простой пример такой ситуации &mdash; когда набор строк &mdash; это <img class=tex src="../tex2png/cache/f4cbaea2c87250622e97f2b894377a3c.png" alt="\{ "dabce", "abc", "bc" \}">, а текст &mdash; это <img class=tex src="../tex2png/cache/437b6e1c8386f039d5616ffbb063473b.png" alt=""dabc"">.<p>Таким образом, если в каждой помеченной вершине хранить номер образца, оканчивающегося в ней (или список номеров, если допускаются повторяющиеся образцы), то мы можем для текущего состояния за <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"> найти номера всех образцов, для которых достигнуто совпадение, просто пройдя по суффиксным ссылкам от текущей вершины до корня. Однако это недостаточно эффективное решение, поскольку в сумме асимптотика получится <img class=tex src="../tex2png/cache/7976cab74c65d37e9c66e0150ed10413.png" alt="O (n \cdot {\rm Len})">. Однако можно заметить, что движение по суффиксным ссылкам можно соптимизировать, предварительно посчитав для каждой вершины ближайшую к ней помеченную вершину, достижимую по суффиксным ссылкам (это называется "функцией выхода"). Эту величину можно считать ленивой динамикой за линейное время. Тогда для текущей вершины мы сможем за <img class=tex src="../tex2png/cache/d0ea0c0a39869a72fadf80b704c58fbf.png" alt="O (1)"> находить следующую в суффиксном пути помеченную вершину, т.е. следующее совпадение. Тем самым, на каждое совпадение будет тратиться <img class=tex src="../tex2png/cache/d0ea0c0a39869a72fadf80b704c58fbf.png" alt="O (1)"> действий, и в сумме получится асимптотика <img class=tex src="../tex2png/cache/a94777b137661720ebb99813b09767ba.png" alt="O ({\rm Len + Ans})">.<p>В более простом случае, когда надо найти не сами вхождения, а только их количество, можно вместо функции выхода посчитать ленивой динамикой количество помеченных вершин, достижимых из текущей вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> по суффиксным ссылкам. Эта величина может быть посчитана за <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"> в сумме, и тогда для текущего состояния <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> мы сможем за <img class=tex src="../tex2png/cache/d0ea0c0a39869a72fadf80b704c58fbf.png" alt="O (1)"> найти количество вхождений всех образцов в текст, оканчивающихся в текущей позиции. Тем самым, задача нахождения суммарного количества вхождений может быть решена нами за <img class=tex src="../tex2png/cache/ad9425359a88e44201d24ca976b250d9.png" alt="O ({\rm Len})">.<p><p><h3 style="padding-top:15px;"> Нахождение лексикографически наименьшей строки данной длины, не содержащей ни один из данных образцов </h3><p>Дан набор образцов, и дана длина <img class=tex src="../tex2png/cache/88e54f90480ef3aeba329562335471f9.png" alt="L">. Требуется найти строку длины <img class=tex src="../tex2png/cache/88e54f90480ef3aeba329562335471f9.png" alt="L">, не содержащую ни один из образцов, и из всех таких строк вывести лексикографически наименьшую.<p>Построим по данному набору строк бор. Вспомним теперь, что те вершины, из которых по суффиксным ссылкам можно достичь помеченных вершин (а такие вершины можно найти за <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)">, например, ленивой динамикой), можно воспринимать как вхождение какой-либо строки из набора в заданный текст. Поскольку в данной задаче нам необходимо избегать вхождений, то это можно понимать как то, что в такие вершины нам заходить нельзя. С другой стороны, во все остальные вершины мы заходить можем. Таким образом, мы удаляем из автомата все "плохие" вершины, а в оставшемся графе автомата требуется найти лексикографически наименьший путь длины <img class=tex src="../tex2png/cache/88e54f90480ef3aeba329562335471f9.png" alt="L">. Эту задачу уже можно решить за <img class=tex src="../tex2png/cache/7fbb2fdf324cdd80287be46eac11bf37.png" alt="O (L)">, например, <a href="dfs.html">поиском в глубину</a>.<p><p><h3 style="padding-top:15px;"> Нахождение кратчайшей строки, содержащей вхождения одновременно всех образцов </h3><p>Снова воспользуемся той же идеей. Для каждой вершины будем хранить маску, обозначающую образцы, для которых произошло вхождение в данной вершине. Тогда задачу можно переформулировать так: изначально находясь в состоянии <img class=tex src="../tex2png/cache/0dd24a1b8c2636b9c83adad603617655.png" alt="(v={\rm Root},~{\rm Msk}=0)">, требуется дойти до состояния <img class=tex src="../tex2png/cache/cd54cce37a46c513b5e25a3d2545bd0b.png" alt="(v,~{\rm Msk}=2^n-1)">, где <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> &mdash; количество образцов. Переходы из состояния в состояние будут представлять собой добавление одной буквы к тексту, т.е. переход по ребру автомата в другую вершину с соответствующим изменением маски. Запустив <a href="bfs.html">обход в ширину</a> на таком графе, мы найдём путь до состояния <img class=tex src="../tex2png/cache/cd54cce37a46c513b5e25a3d2545bd0b.png" alt="(v,~{\rm Msk}=2^n-1)"> наименьшей длины, что нам как раз и требовалось.<p><p><h3 style="padding-top:15px;"> Нахождение лексикографически наименьшей строки длины <img class=tex src="../tex2png/cache/7db1a8ed2a313421c7c0cf6da4eddb3e.png" alt="L">, содержащей данные образцы в сумме <img class=tex src="../tex2png/cache/336a051837a2ed662422914225a362d0.png" alt="k"> раз </h3><p>Как и в предыдущих задачах, посчитаем для каждой вершины количество вхождений, которое соответствует ей (т.е. количество помеченных вершин, достижимых из неё по суффиксным ссылкам). Переформулируем задачу таким образом: текущее состояние определяется тройкой чисел <img class=tex src="../tex2png/cache/9b278a5211dc5a6d5d4dcb6949ac9f19.png" alt="(v,~{\rm Len,~Cnt})">, и требуется из состояния <img class=tex src="../tex2png/cache/d76549adef7d4286bbc9c179d8bd6b8c.png" alt="({\rm Root},~0,~0)"> прийти в состояние <img class=tex src="../tex2png/cache/707f38832b65301dbac83dbbf04a13c7.png" alt="(v,~L,~k)">, где <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> &mdash; любая вершина. Переходы между состояниями &mdash; это просто переходы по рёбрам автомата из текущей вершины. Таким образом, достаточно просто найти <a href="dfs.html">обходом в глубину</a> путь между этими двумя состояниями (если обход в глубину будет просматривать буквы в их естественном порядке, то найденный путь автоматически будет лексикографически наименьшим).<p><p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Задачи, которые можно решить, используя бор или алгоритм Ахо-Корасик:<p><ul><p><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2637">UVA #11590 <b>"Prefix Lookup"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><p><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2112">UVA #11171 <b>"SMS"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p><li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1620">UVA #10679 <b>"I Love Strings!!!"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>