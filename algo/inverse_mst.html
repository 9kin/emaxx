<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Обратная задача MST (inverse-MST - обратная задача минимального остова)</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 23:11<br>редактировано: 13 Jun 2008 1:31</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="inverse_mst.html#" id="contents-hide">[скрыть]</a><a href="inverse_mst.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Обратная задача MST (inverse-MST - обратная задача минимального остова) за O (N M<sup>2</sup>)</h1>

<p>Дан взвешенный неориентированный граф G с N вершинами и M рёбрами (без петель и кратных рёбер). Известно, что граф связный. Также указан некоторый остов T этого графа (т.е. выбрано N-1 ребро, которые образуют дерево с N вершинами). Требуется изменить веса рёбер таким образом, чтобы указанный остов T являлся минимальным остовом этого графа (точнее говоря, одним из минимальных остовов), причём сделать это так, чтобы суммарное изменение всех весов было наименьшим.</p>
<h2>Решение</h2>
<p><b>Сведём</b> задачу inverse-MST к задаче min-cost-flow, точнее, <b>к задаче, двойственной min-cost-flow</b> (в смысле двойственности задач линейного программирования); затем решим последнюю задачу.</p>
<p>Итак, пусть дан граф G с N вершинами, M рёбрами. Вес каждого ребра обозначим через C<sub>i</sub>. Предположим, не теряя общности, что рёбра с номерами с 1 по N-1 являются рёбрами T.</p>
<h3>1. Необходимое и достаточное условие MST</h3>
<p>Пусть дан некоторый остов S (не обязательно минимальный).</p>
<p>Введём сначала одно обозначение. Рассмотрим некоторое ребро j, не принадлежащее S. Очевидно, в графе S имеется единственный путь, соединяющий концы этого ребра, т.е. единственный путь, соединяющий концы ребра j и состоящий только из рёбер, принадлежащих S. <b>Обозначим через P[j]</b> множество рёбер, образующих этот путь для j-го ребра.</p>
<p>Для того, чтобы некоторый остов S являлся минимальным, <b>необходимо и достаточно</b>, чтобы:</p>
<pre>C<sub>i</sub> &lt;= C<sub>j</sub> для всех j &notin; S и каждого i &isin; P[j]</pre>
<p>Можно заметить, что, поскольку <b>в нашей задаче</b> остову T принадлежат рёбра 1..N-1, то мы можем записать это условие таким образом:</p>
<pre>C<sub>i</sub> &lt;= C<sub>j</sub> для всех j = N..M и каждого i &isin; P[j]
(причём все i лежат в диапазоне 1..N-1)</pre>
<h3>2. Граф путей</h3>
<p>Понятие графа путей непосредственно связано с предыдущей теоремой.</p>
<p>Пусть дан некоторый остов S (не обязательно минимальный).</p>
<p>Тогда <b>графом путей H</b> для графа G будет следующий граф:</p>
<ul>
<li>Он содержит M вершин, каждая вершина в H взаимно однозначно соответствует некоторому ребру в G.</li>
<li>Граф H двудольный. В первой его доле находятся вершины i, которые соответствуют рёбрам в G, принадлежащим остову S. Соответственно, во второй доле находятся вершины j, которые соответствуют рёбрам, не принадлежащим S.</li>
<li>Ребро проводится из вершины i в вершину j тогда и только тогда, когда i принадлежит P[j].<br>Иными словами, для каждой вершины j из второй доли в неё входят рёбра из всех вершин первой доли, соответствующих множеству рёбер P[j].</li>
</ul>
<p>В случае <b>нашей задачи</b> мы можем немного упростить описание графа путей:</p>
<pre>ребро (i,j) существует в H, если i &isin; P[j],  j = N..M, i = 1..N-1</pre>
<h3>3. Математическая формулировка задачи</h3>
<p>Чисто формально <b>задача inverse-MST</b> записывается таким образом:</p>
<pre>найти массив A[1..M] такой, что
C<sub>i</sub> + A<sub>i</sub> &lt;= C<sub>j</sub> + A<sub>j</sub> для всех j = N..M и каждого i &isin; P[j] (i в 1..N-1),
и минимизировать сумму |A<sub>1</sub>| + |A<sub>2</sub>| + ... + |A<sub>m</sub>|</pre>
<p>здесь под искомым массивом A мы подразумеваем те значения, которые нужно добавить к весам рёбер (т.е., решив задачу inverse-MST, мы заменяем вес C<sub>i</sub> каждого ребра i на величину C<sub>i</sub> + A<sub>i</sub>).</p>
<p>Очевидно, что нет смысла увеличивать вес рёбер, принадлежащих T, т.е.</p>
<pre>A<sub>i</sub> &lt;= 0,  i = 1..N-1</pre>
<p>и нет смысла укорачивать рёбра, не принадлежащие T:</p>
<pre>A<sub>i</sub> >= 0,  i = N..M</pre>
<p>(поскольку в противном случае мы только ухудшим ответ)</p>
<p>Тогда мы можем немного <b>упростить</b> постановку задачи, убрав из суммы модули:</p>
<pre>найти массив A[1..M] такой, что
C<sub>i</sub> + A<sub>i</sub> &lt;= C<sub>j</sub> + A<sub>j</sub> для всех j = N..M и каждого i &isin; P[j] (i в 1..N-1),
A<sub>i</sub> &lt;= 0,  i = 1..N-1,
A<sub>i</sub> >= 0,  i = N..M,
и минимизировать сумму A<sub>n</sub> + ... + A<sub>m</sub> - (A<sub>1</sub> + ... + A<sub>n-1</sub>)</pre>
<p>Наконец, просто изменим "минимизацию" на "максимизацию", а в самой сумме изменим все знаки на противоположные:</p>
<pre>найти массив A[1..M] такой, что
C<sub>i</sub> + A<sub>i</sub> &lt;= C<sub>j</sub> + A<sub>j</sub> для всех j = N..M и каждого i &isin; P[j] (i в 1..N-1),
A<sub>i</sub> &lt;= 0,  i = 1..N-1,
A<sub>i</sub> >= 0,  i = N..M,
и максимизировать сумму A<sub>1</sub> + ... + A<sub>n-1</sub> - (A<sub>n</sub> + ... + A<sub>m</sub>)</pre>
<h3>4. Сведение задачи inverse-MST к задаче, двойственной задаче о назначениях</h3>
<p>Формулировка задачи inverse-MST, которую мы только что дали, является формулировкой задачи <b>линейного программирования</b> с неизвестными A<sub>1</sub>..A<sub>m</sub>.</p>
<p>Применим классический приём - рассмотрим <b>двойственную</b> ей задачу.</p>
<p>По определению, чтобы получить двойственную задачу, нужно каждому неравенству сопоставить двойственную переменную X<sub>ij</sub>, поменять ролями целевую функцию (которую нужно было минимизировать) и коэффициенты в правых частях неравенств, поменять знаки "&lt=" на ">=" и наоборот, поменять максимизацию на минимизацию.</p>
<p>Итак, <b>двойственная к inverse-MST</b> задача:</p>
<pre>найти все X<sub>ij</sub> для каждого (i,j) &isin; H, такие что:
все X<sub>ij</sub> >= 0,
для каждого i=1..N-1 &sum; X<sub>ij</sub> по всем j: (i,j) &isin; H &lt= 1,
для каждого j=N..M &sum; X<sub>ij</sub> по всем i: (i,j) &isin; H &lt= 1,
и минимизировать &sum; X<sub>ij</sub> (C<sub>j</sub> - C<sub>i</sub>) для всех (i,j) &isin; H</pre>
<p>Последняя задача является <b>задачей о назначениях</b>: нам нужно в графе путей H выбрать несколько рёбер так, чтобы ни одно ребро не пересекалось с другим в вершине, а сумма весов рёбер (вес ребра (i,j) определим как C<sub>j</sub> - C<sub>i</sub>) должна быть наименьшей.</p>
<p>Таким образом, <b>двойственная задача inverse-MST эквивалентна задаче о назначениях</b>. Если мы научимся решать двойственную задачу о назначениях, то мы автоматически решим задачу inverse-MST.</p>
<h3>5. Решение двойственной задачи о назначениях</h3>
<p>Сначала уделим немного внимания тому частному случаю задачи о назначениях, который мы получили. Во-первых, это несбалансированная задача о назначениях, поскольку в одной доле находится N-1 вершин, а в другой - M вершин, т.е. в общем случае число вершин во второй доле больше на целый порядок. Для решения такой двойственной задачи о назначениях есть специализированный алгоритм, который решит её за O (N<sup>3</sup>), но здесь этот алгоритм рассматриваться не будет. Во-вторых, такую задачу о назначениях можно назвать задачей о назначениях с взвешенными вершинами: веса рёбер положим равными 0, вес каждой вершины из первой доли положим равным -C<sub>i</sub>, из второй доли - равным C<sub>j</sub>, и решение полученной задачи будет тем же самым.</p>
<p>Мы будем решать задачу двойственную задачу о назначениях с помощью <b>модифицированного алгоритма min-cost-flow</b>, который будет находить поток минимальной стоимости и одновременно решение двойственной задачи.</p>
<p><b>Свести</b> задачу о назначениях к задаче min-cost-flow очень легко, но для полноты картины мы опишем этот процесс.</p>
<p>Добавим в граф исток s и сток t. Из s к каждой вершине первой доли проведём ребро с пропускной способностью = 1 и стоимостью = 0. Из каждой вершины второй доли проведём ребро к t с пропускной способностью = 1 и стоимостью = 0. Пропускные способности всех рёбер между первой и второй долями также положим равными 1.</p>
<p>Наконец, чтобы модифицированный алгоритм min-cost-flow (описанный ниже) работал, нужно <b>добавить ребро из s в t</b> с пропускной способностью = N+1 и стоимостью = 0.</p>
<h3>6. Модифицированный алгоритм min-cost-flow для решения задачи о назначениях</h3>
<p>Здесь мы рассмотрим <b>алгоритм последовательных кратчайших путей с потенциалами</b>, который напоминает обычный алгоритм min-cost-flow, но использует также понятие <b>потенциалов</b>, которые к концу работы алгоритма будут содержать <b>решение двойственной задачи</b>.</p>
<p>Введём обозначения. Для каждого ребра (i,j) обозначим через U<sub>ij</sub> его пропускную способность, через C<sub>ij</sub> - его стоимость, через F<sub>ij</sub> - поток вдоль этого ребра.</p>
<p>Также введём понятие потенциалов. Каждая вершина обладает своим потенциалом PI<sub>i</sub>. Остаточная стоимость ребра CPI<sub>ij</sub> определяется как:</p>
<pre>CPI<sub>ij</sub> = C<sub>ij</sub> - PI<sub>i</sub> + PI<sub>j</sub></pre>
<p>В любой момент работы алгоритма <b>потенциалы таковы</b>, что выполняются условия:</p>
<pre>если F<sub>ij</sub> = 0, то CPI<sub>ij</sub> >= 0
если F<sub>ij</sub> = U<sub>ij</sub>, то CPI<sub>ij</sub> &lt;= 0
иначе CPI<sub>ij</sub> = 0</pre>
<p>Алгоритм начинает с нулевого потока, и нам нужно найти некоторые начальные значения потенциалов, которые бы удовлетворяли указанным условиям. Нетрудно проверить, что такой способ является одним из возможных решений:</p>
<pre>PI<sub>j</sub> = 0   для j = N..M
PI<sub>i</sub> = min C<sub>ij</sub>, где (i,j) &isin; H
PI<sub>s</sub> = min PI<sub>i</sub>, где i = 1..N-1
PI<sub>t</sub> = 0</pre>
<p>Собственно сам алгоритм min-cost-flow состоит из нескольких итераций. <b>На каждой итерации</b> мы находим кратчайший путь из s в t в остаточной сети, причём в качестве весов рёбер используем остаточные стоимости CPI. Затем мы увеличиваем поток вдоль найденного пути на единицу, и обновляем потенциалы следующим образом:</p>
<pre>PI<sub>i</sub> -= D<sub>i</sub></pre>
<p>где D<sub>i</sub> - найденное кратчайшее расстояние от s до i (повторимся, в остаточной сети с весами рёбер CPI).</p>
<p>Рано или поздно мы найдём тот путь из s в t, который состоит из единственного ребра (s,t). Тогда после этой итерации нам следует <b>завершить</b> работу алгоритма: действительно, если мы не остановим алгоритм, то дальше уже будут находиться пути с неотрицательной стоимостью, и добавлять их в ответ не надо.</p>
<p>К концу работы алгоритма мы получим решение задачи о назначениях (в виде потока F<sub>ij</sub>) и решение двойственной задачи о назначениях (в массиве PI<sub>i</sub>).</p>
<p>(с PI<sub>i</sub> надо будет провести небольшую модификацию: от всех значений PI<sub>i</sub> отнять PI<sub>s</sub>, поскольку его значения имеют смысл только при PI<sub>s</sub> = 0)</p>
<h3>6. Итог</h3>
<p>Итак, мы решили двойственную задачу о назначениях, а, следовательно, и задачу inverse-MST.</p>
<p>Оценим <b>асимптотику</b> получившегося алгоритма.</p>
<p>Сначала мы должны будем построить граф путей. Для этого просто для каждого ребра j &notin; T обходом в ширину по остову T найдём путь P[j]. Тогда граф путей мы построим за O (M) * O (N) = O (N M).</p>
<p>Затем мы найдём начальные значения потенциалов за O (N) * O (M) = O (N M).</p>
<p>Затем мы будем выполнять итерации min-cost-flow, всего итераций будет не более N (поскольку из истока выходит N рёбер, каждое с пропускной способностью = 1), на каждой итерации мы ищем в графе путей кратчайшие пути от истока до всех остальных вершин. Поскольку вершин в графе путей равно M+2, а число рёбер - O (N M), то, если реализовать поиск кратчайших путей простейшим вариантом алгоритма Дейкстры, каждая итерация min-cost-flow будет выполнять за O (M<sup>2</sup>), а весь алгоритм min-cost-flow выполнится за O (N M<sup>2</sup>).</p>
<p>Итоговая асимптотика алгоритма равна <b>O (N M<sup>2</sup>)</b>.</p>
<h2>Реализация</h2>
<p>Реализуем весь вышеописанный алгоритм. Единственное изменение - вместо <a href="dijkstra.html">алгоритма Дейкстры</a> применяется <a href="levit_algorithm.html">алгоритм Левита</a>, который на многих тестах должен работать несколько быстрее.</p>
<pre>const int INF = 1000*1000*1000;

struct rib {
	int v, c, id;
};

struct rib2 {
	int a, b, c;
};

int main() {

	int n, m;
	cin >> n >> m;
	vector &lt; vector&lt;rib> > g (n); // граф в формате списков смежности
	vector&lt;rib2> ribs (m); // все рёбра в одном списке
	... чтение графа ...

	int nn = m+2,  s = nn-2,  t = nn-1;
	vector &lt; vector&lt;int> > f (nn, vector&lt;int> (nn));
	vector &lt; vector&lt;int> > u (nn, vector&lt;int> (nn));
	vector &lt; vector&lt;int> > c (nn, vector&lt;int> (nn));
	for (int i=n-1; i&lt;m; ++i) {
		vector&lt;int> q (n);
		int h=0, t=0;
		rib2 & cur = ribs[i];
		q[t++] = cur.a;
		vector&lt;int> rib_id (n, -1);
		rib_id[cur.a] = -2;
		while (h &lt; t) {
			int v = q[h++];
			for (size_t j=0; j&lt;g[v].size(); ++j)
				if (g[v][j].id >= n-1)
					break;
				else if (rib_id [ g[v][j].v ] == -1) {
					rib_id [ g[v][j].v ] = g[v][j].id;
					q[t++] = g[v][j].v;
				}
		}
		for (int v=cur.b, pv; v!=cur.a; v=pv) {
			int r = rib_id[v];
			pv = v != ribs[r].a ? ribs[r].a : ribs[r].b;
			u[r][i] = n;
			c[r][i] = ribs[i].c - ribs[r].c;
			c[i][r] = -c[r][i];
		}
	}
	u[s][t] = n+1;
	for (int i=0; i&lt;n-1; ++i)
		u[s][i] = 1;
	for (int i=n-1; i&lt;m; ++i)
		u[i][t] = 1;

	vector&lt;int> pi (nn);
	pi[s] = INF;
	for (int i=0; i&lt;n-1; ++i) {
		pi[i] = INF;
		for (int j=n-1; j&lt;m; ++j)
			if (u[i][j])
				pi[i] = min (pi[i], ribs[j].c-ribs[i].c);
		pi[s] = min (pi[s], pi[i]);
	}

	for (;;) {
		vector&lt;int> id (nn);
		deque&lt;int> q;
		q.push_back (s);
		vector&lt;int> d (nn, INF);
		d[s] = 0;
		vector&lt;int> p (nn, -1);
		while (!q.empty()) {
			int v = q.front();  q.pop_front();
			id[v] = 2;
			for (int i=0; i&lt;nn; ++i)
				if (f[v][i] &lt; u[v][i]) {
					int new_d = d[v] + c[v][i] - pi[v] + pi[i];
					if (new_d &lt; d[i]) {
						d[i] = new_d;
						if (id[i] == 0)
							q.push_back (i);
						else if (id[i] == 2)
							q.push_front (i);
						id[i] = 1;
						p[i] = v;
					}
				}
		}
		for (int i=0; i&lt;nn; ++i)
			pi[i] -= d[i];
		for (int v=t; v!=s; v=p[v]) {
			int pv = p[v];
			++f[pv][v],  --f[v][pv];
		}
		if (p[t] == s)  break;
	}

	for (int i=0; i&lt;m; ++i)
		pi[i] -= pi[s];
	for (int i=0; i&lt;n-1; ++i)
		if (f[s][i])
			ribs[i].c += pi[i];
	for (int i=n-1; i&lt;m; ++i)
		if (f[i][t])
			ribs[i].c += pi[i];

	... вывод графа ...
	
}</pre><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>