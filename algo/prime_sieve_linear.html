<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Решето Эратосфена с линейным временем работы</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 6 Sep 2011 1:03<br>редактировано: 23 Mar 2012 3:58</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="prime_sieve_linear.html#" id="contents-hide">[скрыть]</a><a href="prime_sieve_linear.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Решето Эратосфена с линейным временем работы </h1><p>Дано число <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Требуется найти <b>все простые</b> в отрезке <img class=tex src="../tex2png/cache/040235aca9e8238f832b1cbad383b0b9.png" alt="[2; n]">.<p>Классический способ решения этой задачи &mdash; <b><a href="eratosthenes_sieve.html">решето Эратосфена</b></a>. Этот алгоритм очень прост, но работает за время <img class=tex src="../tex2png/cache/cd1c612f470525c506db4c632096a9d0.png" alt="O (n \log \log n)">.<p>Хотя в настоящий момент известно достаточно много алгоритмов, работающих за сублинейное время (т.е. за <img class=tex src="../tex2png/cache/dcc8a85f03b708835d2e7de5e47d663a.png" alt="o(n)">), описываемый ниже алгоритм интересен своей <b>простотой</b> &mdash; он практически не сложнее классического решета Эратосфена.<p>Кроме того, приводимый здесь алгоритм в качестве "побочного эффекта" фактически вычисляет <b>факторизацию всех чисел</b> в отрезке <img class=tex src="../tex2png/cache/040235aca9e8238f832b1cbad383b0b9.png" alt="[2; n]">, что может быть полезно во многих практических применениях.<p>Недостатком приводимого алгоритма является то, что он использует <b>больше памяти</b>, чем классическое решето Эратосфена: требуется заводить массив из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> чисел, в то время как классическому решету Эратосфена достаточно лишь <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> бит памяти (что получается в <img class=tex src="../tex2png/cache/4479cf8459f4479cde703fcbe446c66b.png" alt="32"> раза меньше).<p>Таким образом, описываемый алгоритм имеет смысл применять только до чисел порядка <img class=tex src="../tex2png/cache/04848901dc467ee6abcd96021d989c3b.png" alt="10^7">, не более.<p>Авторство алгоритма, по всей видимости, принадлежит Грайсу и Мисра (Gries, Misra, 1978 г. &mdash; см. список литературы в конце). (И, собственно говоря, называть данный алгоритм "решетом Эратосфена" некорректно: слишком отличаются эти два алгоритма.)<p><p><h2 style="padding-top:40px;"> Описание алгоритма </h2><p>Наша цель &mdash; посчитать для каждого числа <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> от в отрезке <img class=tex src="../tex2png/cache/040235aca9e8238f832b1cbad383b0b9.png" alt="[2; n]"> его <b>минимальный простой делитель</b> <img class=tex src="../tex2png/cache/409cd02cefebe87c4028081db04f10f3.png" alt="lp[i]">.<p>Кроме того, нам потребуется хранить список всех найденных простых чисел &mdash; назовём его массивом <img class=tex src="../tex2png/cache/80198b579662b5437cef07a545a13114.png" alt="pr[]">.<p>Изначально все величины <img class=tex src="../tex2png/cache/409cd02cefebe87c4028081db04f10f3.png" alt="lp[i]"> заполним нулями, что означает, что мы пока предполагаем все числа простыми. В ходе работы алгоритма этот массив будет постепенно заполняться.<p>Будем теперь перебирать текущее число <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> от <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2"> до <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. У нас может быть два случая:<p><ul><p><li><img class=tex src="../tex2png/cache/9baf2cb8e19a5e765263352a575660cf.png" alt="lp[i] = 0"> &mdash; это означает, что число <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> &mdash; простое, т.к. для него так и не обнаружилось других делителей.<p>Следовательно, надо присвоить <img class=tex src="../tex2png/cache/50609dd73bb71e38f32b26175828fd8b.png" alt="lp[i] = i"> и добавить <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> в конец списка <img class=tex src="../tex2png/cache/80198b579662b5437cef07a545a13114.png" alt="pr[]">.<p><li><img class=tex src="../tex2png/cache/af2d0283a9045144bdcfe7f48af0c771.png" alt="lp[i] \ne 0"> &mdash; это означает, что текущее число <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> &mdash; составное, и его минимальным простым делителем является <img class=tex src="../tex2png/cache/409cd02cefebe87c4028081db04f10f3.png" alt="lp[i]">.<p></ul><p>В обоих случаях дальше начинается процесс <b>расстановки значений</b> в массиве <img class=tex src="../tex2png/cache/d7b01a36f92b005e06a01145a37f03ff.png" alt="lp[]">: мы будем брать числа, <b>кратные</b> <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, и обновлять у них значение <img class=tex src="../tex2png/cache/d7b01a36f92b005e06a01145a37f03ff.png" alt="lp[]">. Однако наша цель &mdash; научиться делать это таким образом, чтобы в итоге у каждого числа значение <img class=tex src="../tex2png/cache/d7b01a36f92b005e06a01145a37f03ff.png" alt="lp[]"> было бы установлено не более одного раза.<p>Утверждается, что для этого можно поступить таким образом. Рассмотрим числа вида:<p><p class=formula><img class=tex src="../tex2png/cache/a0dd97c27f25ba407bba6c6cc6563935.png" alt=" x_j = i \cdot p_j, "></p><p>где последовательность <img class=tex src="../tex2png/cache/0137555ce0c5b954ad6dd8eb08c171b4.png" alt="p_j"> &mdash; это все простые, не превосходящие <img class=tex src="../tex2png/cache/409cd02cefebe87c4028081db04f10f3.png" alt="lp[i]"> (как раз для этого нам понадобилось хранить список всех простых чисел).<p>У всех чисел такого вида проставим новое значение <img class=tex src="../tex2png/cache/bc3448a177c393727f39f8f8b092f5ef.png" alt="lp[x_j]"> &mdash; очевидно, оно будет равно <img class=tex src="../tex2png/cache/0137555ce0c5b954ad6dd8eb08c171b4.png" alt="p_j">.<p>Почему такой алгоритм корректен, и почему он работает за линейное время &mdash; см. ниже, пока же приведём его реализацию.<p><p><h2 style="padding-top:40px;"> Реализация </h2><p>Решето выполняется до указанного в константе числа <img class=tex src="../tex2png/cache/e443c86ec0d26264771c7414985f9d24.png" alt="N">.<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> N <span class="sy1">=</span> <span class="nu0">10000000</span><span class="sy4">;</span>
<span class="kw4">int</span> lp<span class="br0">&#91;</span>N<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> pr<span class="sy4">;</span>
&nbsp;
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> i<span class="sy1">&lt;=</span>N<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>lp<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		lp<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
		pr.<span class="me1">push_back</span> <span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>pr.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy3">&amp;&amp;</span> pr<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="sy1">&lt;=</span>lp<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy3">&amp;&amp;</span> i<span class="sy2">*</span>pr<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="sy1">&lt;=</span>N<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
		lp<span class="br0">&#91;</span>i <span class="sy2">*</span> pr<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> pr<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Эту реализацию можно немного ускорить, избавившись от вектора <img class=tex src="../tex2png/cache/621ebf5aacd14e1857bc23948913168a.png" alt="pr"> (заменив его на обычный массив со счётчиком), а также избавившись от дублирующегося умножения во вложенном цикле <img class=tex src="../tex2png/cache/e4bd34533fcaa5c6bb8560a9ced4c800.png" alt="for"> (для чего результат произведения надо просто запомнить в какой-либо переменной).<p><p><h2 style="padding-top:40px;"> Доказательство корректности </h2><p>Докажем <b>корректность</b> алгоритма, т.е. что он корректно расставляет все значения <img class=tex src="../tex2png/cache/d7b01a36f92b005e06a01145a37f03ff.png" alt="lp[]">, причём каждое из них будет установлено ровно один раз. Отсюда будет следовать, что алгоритм работает за линейное время &mdash; поскольку все остальные действия алгоритма, очевидно, работают за <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)">.<p>Для этого заметим, что у любого числа <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> <b>единственно представление</b> такого вида:<p><p class=formula><img class=tex src="../tex2png/cache/4d6bdbea65dc02c13aaf201d24786750.png" alt=" i = lp[i] \cdot x, "></p><p>где <img class=tex src="../tex2png/cache/409cd02cefebe87c4028081db04f10f3.png" alt="lp[i]"> &mdash; (как и раньше) минимальный простой делитель числа <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, а число <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> не имеет делителей, меньших <img class=tex src="../tex2png/cache/409cd02cefebe87c4028081db04f10f3.png" alt="lp[i]">, т.е.:<p><p class=formula><img class=tex src="../tex2png/cache/41e351955c7bf8620add4f3ab26a0829.png" alt=" lp[i] \le lp[x]. "></p><p>Теперь сравним это с тем, что делает наш алгоритм &mdash; он фактически для каждого <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> перебирает все простые, на которые его можно домножить, т.е. простые до <img class=tex src="../tex2png/cache/bc1f261f1d5ec2b016473110863122a3.png" alt="lp[x]"> включительно, чтобы получить числа в указанном выше представлении.<p>Следовательно, алгоритм действительно пройдёт по каждому составному числу ровно один раз, поставив у него правильное значение <img class=tex src="../tex2png/cache/d7b01a36f92b005e06a01145a37f03ff.png" alt="lp[]">.<p>Это означает корректность алгоритма и то, что он работает за линейное время.<p><p><h2 style="padding-top:40px;"> Время работы и требуемая память </h2><p>Хотя асимптотика <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"> лучше асимптотики <img class=tex src="../tex2png/cache/cd1c612f470525c506db4c632096a9d0.png" alt="O (n \log \log n)"> классического решета Эратосфена, разница между ними невелика. На практике это означает лишь двукратную разницу в скорости, а оптимизированные варианты решета Эратосфена и вовсе не проигрывают приведённому здесь алгоритму.<p>Учитывая затраты памяти, которые требует этот алгоритм &mdash; массив чисел <img class=tex src="../tex2png/cache/d7b01a36f92b005e06a01145a37f03ff.png" alt="lp[]"> длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> и массив всех простых <img class=tex src="../tex2png/cache/80198b579662b5437cef07a545a13114.png" alt="pr[]"> длины примерно <img class=tex src="../tex2png/cache/d7d747f5db2a65faab4c3fff0739bbb2.png" alt="n / \ln n"> &mdash; этот алгоритм кажется уступающим классическому решету по всем статьям.<p>Однако спасает его то, что массив <img class=tex src="../tex2png/cache/d7b01a36f92b005e06a01145a37f03ff.png" alt="lp[]">, вычисляемый этим алгоритмом, позволяет искать факторизацию любого числа в отрезке <img class=tex src="../tex2png/cache/040235aca9e8238f832b1cbad383b0b9.png" alt="[2; n]"> за время порядка размера этой факторизации. Более того, ценой ещё одного дополнительного массива можно сделать, чтобы в этой факторизации не требовались операции деления.<p>Знание факторизации всех чисел &mdash; очень полезная информация для некоторых задач, и этот алгоритм является одним из немногих, которые позволяют искать её за линейное время.<p><p><h2 style="padding-top:40px;"> Литература </h2><p><ul><p><li>David Gries, Jayadev Misra. <b>A Linear Sieve Algorithm for Finding Prime Numbers</b> [1978]<p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>