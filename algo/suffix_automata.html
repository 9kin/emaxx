<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Суффиксный автомат. Построение и применения</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Aug 2008 19:50<br>редактировано: 2 May 2012 22:52</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="suffix_automata.html#" id="contents-hide">[скрыть]</a><a href="suffix_automata.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Суффиксный автомат </h1><p><b>Суффиксный автомат</b> (или <b>ориентированный ациклический граф слов</b>) &mdash; это мощная структура данных, которая позволяет решать множество строковых задач.<p>Например, с помощью суффиксного автомата можно искать все вхождения одной строки в другую, или подсчитывать количество различных подстрок данной строки &mdash; обе задачи он позволяет решать за линейное время.<p>На интуитивном уровне, суффиксный автомат можно понимать как сжатую информацию обо <b>всех подстроках</b> данной строки. Впечатляющим фактом является то, что суффиксный автомат содержит всю информацию в настолько сжатом виде, что для строки длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> он требует лишь <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> памяти. Более того, он может быть построен также за время <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> (если мы считаем размер алфавита <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> константой; в противном случае &mdash; за время <img class=tex src="../tex2png/cache/a8770007d7bdb23d5616ac746b0f45ad.png" alt="O (n \log k)">).<p><b>Исторически</b>, впервые линейность размера суффиксного автомата была открыта в 1983 г. Blumer и др., а в 1985 &mdash; 1986 гг. были представлены первые алгоритмы его построения за линейное время (Crochemore, Blumer и др.). Более подробно &mdash; см. список литературы в конце статьи.<p>На английском языке суффиксный автомат называется "suffix automaton" (во множественном числе &mdash; "suffix automata"), а ориентированный ациклический граф слов &mdash; "directed acyclic word graph" (или просто "DAWG").<p><p><h2 style="padding-top:40px;"> Определение суффиксного автомата </h2><p>Определение. <b>Суффиксным автоматом</b> для данной строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> называется такой минимальный детерминированный конечный автомат, который принимает все суффиксы строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">.<p>Расшифруем это определение.<p><ul><p><li>Суффиксный автомат представляет собой ориентированный ациклический граф, в котором вершины называются <b>состояниями</b>, а дуги графа &mdash; это <b>переходы</b> между этими состояниями.<p><li>Одно из состояний <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0"> называется <b>начальным состоянием</b>, и оно должно быть истоком графа (т.е. из него достижимы все остальные состояния).<p><li>Каждый <b>переход</b> в автомате &mdash; это дуга, помеченная некоторым символом. Все переходы, исходящие из какого-либо состояния, обязаны иметь <b>разные</b> метки. (С другой стороны, из состояния может не быть переходов по каким-либо символам.)<p><li>Одно или несколько состояний помечены как <b>терминальные состояния</b>. Если мы пройдём из начального состояния <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0"> по любому пути до какого-либо терминального состояния, и выпишем при этом метки всех пройденных дуг, то получится строка, которая обязана быть одним из суффиксов строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">.<p><li>Суффиксный автомат содержит минимальное число вершин среди всех автоматов, удовлетворяющих описанным выше условиям. (Минимальность числа переходов не требуется, т.к. при условии минимальности числа состояний в автомате не может быть "лишних" путей &mdash; иначе это нарушило бы предыдущее свойство.)<p></ul><p><p><h3 style="padding-top:15px;"> Простейшие свойства суффиксного автомата </h3><p>Простейшим, и вместе с тем важнейшим свойством суффиксного автомата является то, что он содержит в себе информацию обо всех подстроках строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">. А именно, <b>любой путь</b> из начального состояния <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0">, если мы выпишем метки дуг вдоль этого пути, образует обязательно <b>подстроку</b> строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">. И наоборот, любой подстроке строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> соответствует некоторый путь, начинающийся в начальном состоянии <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0">.<p>В целях упрощения объяснений, мы будем говорить, что подстроке <b>соответствует</b> тот путь из начального состояния, метки вдоль которого образуют эту подстроку. И наоборот, мы будем говорить, что любому пути <b>соответствует</b> та строка, которую образуют метки его дуг.<p>В каждое состояние суффиксного автомата ведёт один или несколько путей из начального состояния. Будем говорить, что состоянию <b>соответствует</b> набор строк, соответствующих всем этим путям.<p><p><h3 style="padding-top:15px;"> Примеры построенных суффиксных автоматов </h3><p>Приведём примеры суффиксных автоматов, построенных для нескольких простых строк.<p>Начальное состояние мы будем обозначать здесь через <img class=tex src="../tex2png/cache/deba03455c8f130c994fac660b6218b0.png" alt="t0">, а терминальные состояния &mdash; отмечать звёздочкой.<p>Для строки <img class=tex src="../tex2png/cache/dc40ef30bf4332d9fbdd7bb4dd964305.png" alt="s = """>:<p><img src="suffix_automaton_sample_1.gif"><p>Для строки <img class=tex src="../tex2png/cache/a91eebe47082eff4c8746445d343ea98.png" alt="s = "a"">:<p><img src="suffix_automaton_sample_2.gif"><p>Для строки <img class=tex src="../tex2png/cache/c8cc126a13b74a66b7bb4e39fb75d454.png" alt="s = "aa"">:<p><img src="suffix_automaton_sample_3.gif"><p>Для строки <img class=tex src="../tex2png/cache/b017f456bd81a42ca57bfab9ed977431.png" alt="s = "ab"">:<p><img src="suffix_automaton_sample_4.gif"><p>Для строки <img class=tex src="../tex2png/cache/c133fbb78fa4e7a0c6dc2b9b80e57e5c.png" alt="s = "aba"">:<p><img src="suffix_automaton_sample_5.gif"><p>Для строки <img class=tex src="../tex2png/cache/1f072ef2dd568fdc650ea55e569899a9.png" alt="s = "abb"">:<p><img src="suffix_automaton_sample_6.gif"><p>Для строки <img class=tex src="../tex2png/cache/480f8527ee2f33c6c2ce35c55e9bcde4.png" alt="s = "abbb"">:<p><img src="suffix_automaton_sample_7.gif"><p><p><p><h2 style="padding-top:40px;"> Алгоритм построения суффиксного автомата за линейное время </h2><p>Перед тем, как перейти непосредственно к описанию алгоритма построения, надо ввести несколько новых понятий и доказать простые, но очень важные для понимания суффиксного автомата леммы.<p><p><h3 style="padding-top:15px;"> Позиции окончаний <img class=tex src="../tex2png/cache/1bb3867d2eda44de9d241a3d4523a81b.png" alt="endpos">, их свойства и связь с суффиксным автоматом </h3><p>Рассмотрим любую непустую подстроку <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">. Тогда назовём <b>множеством окончаний</b> <img class=tex src="../tex2png/cache/67cae9738046d02354255fa8e315b3bf.png" alt="endpos(t)"> множество всех позиций в строке <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, в которых оканчиваются вхождения строки <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">.<p>Мы будем называть две подстроки <img class=tex src="../tex2png/cache/b0d9d011e6176215767b2d0346521c34.png" alt="t_1"> и <img class=tex src="../tex2png/cache/98a9d3b95fa8df513c642a04aa8e1209.png" alt="t_2"> <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">-эквивалентными, если их множества окончаний совпадают: <img class=tex src="../tex2png/cache/19565c2002d04f920816378d769fea01.png" alt="endpos(t_1) = endpos(t_2)">. Таким образом, все непустые подстроки строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> можно разбить на несколько <b>классов эквивалентности</b> соответственно их множествам <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">.<p>Оказывается, что в суффиксном автомате <b><img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">-эквивалентным подстрокам соответствует одно и то же состояние</b>. Иными словами, число состояний в суффиксном автомате равно количеству классов <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">-эквивалентности среди всех подстрок, плюс одно начальное состояние. Каждому состоянию суффиксного автомата соответствуют одна или несколько подстрок, имеющих одно и то же значение <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">.<p><b>Это утверждение мы примем как аксиому</b>, и опишем алгоритм построения суффиксного автомата, исходя из этого предположения &mdash; как мы затем увидим, все требуемые свойства суффиксного автомата, кроме минимальности, будут выполнены. (А минимальность следует из теоремы Nerode &mdash; см. список литературы.)<p>Приведём также несколько простых, но важных утверждений касательно значений <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">.<p><b>Лемма 1</b>. Две непустые подстроки <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> и <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> (<img class=tex src="../tex2png/cache/f2ff0267d42164bcbbc25a44a3b62ea2.png" alt="length(u) \le length(w)">) являются <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">-эквивалентными тогда и только тогда, когда строка <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> встречается в строке <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> только в виде суффикса строки <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">.<p>Доказательство практически очевидно. В одну сторону: если <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> и <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> имеют одинаковые позиции окончаний вхождения, то <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> является суффиксом <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">, и она присутствует в <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> только в виде суффикса <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">. В обратную сторону: если <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> является суффиксом <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> и входит только как этот суффикс, то их значения <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos"> равны по определению.<p><b>Лемма 2</b>. Рассмотрим две непустые подстроки <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> и <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> (<img class=tex src="../tex2png/cache/f2ff0267d42164bcbbc25a44a3b62ea2.png" alt="length(u) \le length(w)">). Тогда их множества <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos"> либо не пересекаются, либо <img class=tex src="../tex2png/cache/7f95bf6162c961f178a137f187407309.png" alt="endpos(w)"> целиком содержится в <img class=tex src="../tex2png/cache/7bc542a6ed08300b6b5a4a6db9dadf78.png" alt="endpos(u)">, причём это зависит от того, является <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> суффиксом <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> или нет:<p><p class=formula><img class=tex src="../tex2png/cache/c0f35ffe0f916f60d2040dd82005b519.png" alt=" \begin{cases}
endpos(w) \subset endpos(u) & \tex[...]"></p><p>Доказательство. Предположим, что множества <img class=tex src="../tex2png/cache/7bc542a6ed08300b6b5a4a6db9dadf78.png" alt="endpos(u)"> и <img class=tex src="../tex2png/cache/7f95bf6162c961f178a137f187407309.png" alt="endpos(w)"> имеют хотя бы один общий элемент. Тогда это означает, что строки <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> и <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> оканчиваются в одном и том же месте, т.е. <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> &mdash; суффикс <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">. Но тогда каждое вхождение строки <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> содержит на своём конце вхождение строки <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">, что и означает, что его множество <img class=tex src="../tex2png/cache/7f95bf6162c961f178a137f187407309.png" alt="endpos(w)"> целиком вкладывается в множество <img class=tex src="../tex2png/cache/7bc542a6ed08300b6b5a4a6db9dadf78.png" alt="endpos(u)">.<p><b>Лемма 3</b>. Рассмотрим некоторый класс <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">-эквивалентности. Отсортируем все подстроки, входящие в этот класс, по невозрастанию длины. Тогда в получившейся последовательности каждая подстрока будет на единицу короче предыдущей, и при этом являться суффиксом предыдущей. Иными словами, <b>подстроки, входящие в один класс эквивалентности, на самом деле являются суффиксами друг друга, и принимают всевозможные различные длины в некотором отрезке <img class=tex src="../tex2png/cache/65077e2625065a90bb34fa37c62d186b.png" alt="[x;y]"></b>.<p>Доказательство.<p>Зафиксируем некоторый класс <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">-эквивалентности. Если он содержит только одну строку, то корректность леммы очевидна. Пусть теперь количество строк больше одной.<p>Согласно лемме 1, две различные <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">-эквивалентные строки всегда таковы, что одна является собственным суффиксом другой. Следовательно, в одном классе <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">-эквивалентности не может быть строк одинаковой длины.<p>Обозначим через <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> длиннейшую, а через <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> &mdash; кратчайшую строку в данном классе эквивалентности. Согласно лемме 1, строка <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> является собственным суффиксом строки <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">. Рассмотрим теперь любой суффикс строки <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> с длиной в отрезке <img class=tex src="../tex2png/cache/4e2e6bef1e5cf9810dee5f2f4daa9f98.png" alt="[length(u); length(w)]">, и покажем, что он содержится в этом же классе эквивалентности. В самом деле, этот суффикс может входить в <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> только в виде суффикса строки <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> (поскольку более короткий суффикс <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> входит только в виде суффикса строки <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">). Следовательно, согласно лемме 1, этот суффикс <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">-эквивалентен строке <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">, что и требовалось доказать.<p><p><h3 style="padding-top:15px;"> Суффиксные ссылки </h3><p>Рассмотрим некоторое состояние автомата <img class=tex src="../tex2png/cache/bc18b26b5424f893bde9d22b95060954.png" alt="v \ne t_0">. Как мы теперь знаем, состоянию <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> соответствует некоторый класс строк с одинаковыми значениями <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">, причём если мы обозначим через <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> длиннейшую из этих строк, то все остальные будут суффиксами <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">.<p>Также мы знаем, что первые несколько суффиксов строки <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> (если мы рассматриваем суффиксы в порядке убывания их длины) содержатся в том же самом классе эквивалентности, а все остальные суффиксы (как минимум, пустой суффикс) &mdash; в каких-то других классах. Обозначим через <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> первый такой суффикс &mdash; в него мы и проведём суффиксную ссылку.<p>Иными словами, <b>суффиксная ссылка</b> <img class=tex src="../tex2png/cache/e55234ce51b309347717d3becccd5f3f.png" alt="link(v)"> ведёт в такое состояние, которому соответствует <b>наидлиннейший суффикс</b> строки <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">, находящийся в другом классе <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">-эквивалентности.<p>Здесь мы считаем, что начальному состоянию <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0"> соответствует отдельный класс эквивалентности (содержащий только пустую строку), и полагаем <img class=tex src="../tex2png/cache/1a5e450c7a4753382524e4aba8407f03.png" alt="endpos(t_0) = [-1 \ldots length(s)-1]">.<p><b>Лемма 4</b>. Суффиксные ссылки образуют <b>дерево</b>, корнем которого является начальное состояние <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0">.<p>Доказательство. Рассмотрим произвольное состояние <img class=tex src="../tex2png/cache/bc18b26b5424f893bde9d22b95060954.png" alt="v \ne t_0">. Суффиксная ссылка <img class=tex src="../tex2png/cache/e55234ce51b309347717d3becccd5f3f.png" alt="link(v)"> ведёт из него в состояние, которому соответствуют строки строго меньшей длины (это следует из определения суффиксной ссылки и из леммы 3). Следовательно, двигаясь по суффиксным ссылкам, мы рано или поздно придём из состояния <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> в начальное состояние <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0">, которому соответствует пустая строка.<p><b>Лемма 5</b>. Если мы построим из всех имеющихся множеств <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos"> <b>дерево</b> (по принципу "множество-родитель содержит как подмножества всех своих детей"), то оно будет совпадать по структуре с деревом суффиксных ссылок.<p>Доказательство.<p>То, что из множеств <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos"> можно построить дерево, следует из леммы 2 (о том, что любые два множества <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos"> либо не пересекаются, либо одно содержится в другом).<p>Рассмотрим теперь произвольное состояние <img class=tex src="../tex2png/cache/bc18b26b5424f893bde9d22b95060954.png" alt="v \ne t_0"> и его суффиксную ссылку <img class=tex src="../tex2png/cache/e55234ce51b309347717d3becccd5f3f.png" alt="link(v)">. Из определения суффиксной ссылки и из леммы 2 следует:<p><p class=formula><img class=tex src="../tex2png/cache/3ba170b6afaead2e0ad69b415d93651a.png" alt=" endpos(v) \subset endpos(link(v)), "></p><p>что вкупе с предыдущей леммой и доказывает наше утверждение: дерево суффиксных ссылок по сути своей есть дерево вкладывающихся множеств <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">.<p><b>Приведём пример</b> дерева суффиксных ссылок в суффиксном автомате, построенном для строки <img class=tex src="../tex2png/cache/cbaa5fa02110919417bfa7f4f4ef3756.png" alt=""abcbc"">:<p><img src="suffix_automaton_link.gif"><p><p><h3 style="padding-top:15px;"> Промежуточный итог </h3><p>Перед тем, как приступить к самому алгоритму, систематизируем накопленные выше знания, и введём пару вспомогательных обозначений.<p><ul><p><li>Множество подстрок строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> можно разбить на классы эквивалентности согласно их множествам окончания <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">.<p><li>Суффиксный автомат состоит из начального состояния <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0">, а также по одному состоянию на каждый класс <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">-эквивалентности.<p><li>Каждому состоянию <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> соответствует одна или несколько строк. Обозначим через <img class=tex src="../tex2png/cache/325ea4a4246ac97011c6c6594c474985.png" alt="longest(v)"> длиннейшую из таких строк, через <img class=tex src="../tex2png/cache/610147038f7617ee65d3ed91289b9bf7.png" alt="len(v)"> её длину. Обозначим через <img class=tex src="../tex2png/cache/aa55a15c1d6227cc538b3779663e955a.png" alt="shortest(v)"> кратчайшую из таких строк, а её длину через <img class=tex src="../tex2png/cache/ade861e267787ba65e6e4ef32793e2e6.png" alt="minlen(v)">.<p>Тогда все строки, соответствующие этому состоянию, являются различными суффиксами строки <img class=tex src="../tex2png/cache/325ea4a4246ac97011c6c6594c474985.png" alt="longest(v)"> и имеют всевозможные длины в отрезке <img class=tex src="../tex2png/cache/863053e30bff3812efab6f2ad79043b5.png" alt="[minlen(v); len(v)]">.<p><li>Для каждого состояния <img class=tex src="../tex2png/cache/bc18b26b5424f893bde9d22b95060954.png" alt="v \ne t_0"> определена суффиксная ссылка, ведущая в такое состояние, которое соответствует суффиксу строки <img class=tex src="../tex2png/cache/325ea4a4246ac97011c6c6594c474985.png" alt="longest(v)"> длины <img class=tex src="../tex2png/cache/ac5e6e678a1677c72f4f1a897f95aaad.png" alt="minlen(v)-1">. Суффиксные ссылки образуют дерево с корнем в <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0">, причём это дерево, по сути, является деревом отношений включения между множествами <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">.<p><li>Таким образом, <img class=tex src="../tex2png/cache/ade861e267787ba65e6e4ef32793e2e6.png" alt="minlen(v)"> для <img class=tex src="../tex2png/cache/bc18b26b5424f893bde9d22b95060954.png" alt="v \ne t_0"> выражается с помощью суффиксной ссылки <img class=tex src="../tex2png/cache/e55234ce51b309347717d3becccd5f3f.png" alt="link(v)"> как:<p><p class=formula><img class=tex src="../tex2png/cache/143899d957ced7320cdbae1f13b5b577.png" alt=" minlen(v) = len(link(v)) + 1. "></p><p><li>Если мы стартуем из произвольного состояния <img class=tex src="../tex2png/cache/507d08c2f34a52702e9d6c371008f674.png" alt="v_0"> и будем идти по суффиксным ссылкам, то рано или поздно дойдём до начального состояния <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0">. При этом у нас получится последовательность непересекающихся отрезков <img class=tex src="../tex2png/cache/0795387d83bc4a8094a312afe981ee78.png" alt="[minlen(v_i); len(v_i)]">, которые в объединении дадут один сплошной отрезок.<p></ul><p><p><h3 style="padding-top:15px;"> Алгоритм построения суффиксного автомата за линейное время </h3><p>Приступим к описанию самого алгоритма. Алгоритм будет <b>онлайновым</b>, т.е. будет добавлять по одному символу строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, перестраивая соответствующим образом текущий автомат.<p>Чтобы достичь линейного потребления памяти, в каждом состоянии мы будем хранить только значение <img class=tex src="../tex2png/cache/50a069f00cb79de2927015fc1ef559aa.png" alt="len">, <img class=tex src="../tex2png/cache/0c9d72169ccd8e141f8f5a2d46f89615.png" alt="link"> и список переходов из этого состояния. Метки терминальных состояний мы поддерживать не будем (мы покажем, как расставить эти метки после построения суффиксного автомата, если имеется необходимость в них).<p><b>Изначально</b> автомат состоит из единственного состояния <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0">, которое мы условимся считать нулевым состоянием (остальные состояния будут получать номера <img class=tex src="../tex2png/cache/9536800d65b8019de76dba7718445458.png" alt="1, 2, \ldots">). Присвоим этому состоянию <img class=tex src="../tex2png/cache/131016f8bb81ca1280a4c4a7d2065fb3.png" alt="len = 0">, а значению <img class=tex src="../tex2png/cache/0c9d72169ccd8e141f8f5a2d46f89615.png" alt="link"> присвоим для удобства <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1"> (означающее ссылку на фиктивное, несуществующее состояние).<p>Соответственно, вся задача теперь сводится к тому, чтобы реализовать обработку <b>добавления одного символа</b> <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> в конец текущей строки. Опишем этот процесс:<p><ul><p><li>Пусть <img class=tex src="../tex2png/cache/94a3c84209772daac4440090b2936e9d.png" alt="last"> &mdash; это состояние, соответствующее всей текущей строке до добавления символа <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">. (Изначально <img class=tex src="../tex2png/cache/83f7af3f4b817c0ba6cc8e745367e7a9.png" alt="last = 0">, а после добавления каждого символа мы будем менять значение <img class=tex src="../tex2png/cache/94a3c84209772daac4440090b2936e9d.png" alt="last">.)<p><li>Создадим новое состояние <img class=tex src="../tex2png/cache/6663959c5800fe82135dd0d815744325.png" alt="cur">, проставив ему <img class=tex src="../tex2png/cache/8387c450be42ca09f450d40135d6ecb5.png" alt="len(cur) = len(last) + 1">. Значение <img class=tex src="../tex2png/cache/738eaa38ffe66e625d75c14083d4a337.png" alt="link(cur)"> пока считаем неопределённым.<p><li>Сделаем такой цикл: изначально мы стоим в состоянии <img class=tex src="../tex2png/cache/94a3c84209772daac4440090b2936e9d.png" alt="last">; если из него нет перехода по букве <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">, то добавляем этот переход по букве <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> в состояние <img class=tex src="../tex2png/cache/6663959c5800fe82135dd0d815744325.png" alt="cur">, и затем переходим по суффиксной ссылке, снова проверяя &mdash; если нет перехода, то добавляем. Если в какой-то момент случится, что такой переход уже есть, то останавливаемся &mdash; и обозначим через <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> номер состояния, на котором это произошло.<p><li>Если ни разу не случилось, что переход по букве <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> уже имелся, и мы так и дошли до фиктивного состояния <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1"> (в которое мы попали по суффиксной ссылке из начального состояния <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0">), то мы можем просто присвоить <img class=tex src="../tex2png/cache/1056ef7ba94755c3766e85c7bd7d2106.png" alt="link(cur) = 0"> и выйти.<p><li>Допустим теперь, что мы остановились на некотором состоянии <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">, из которого уже был переход по букве <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">. Обозначим через <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> то состояние, куда ведёт этот имеющийся переход.<p><li>Теперь у нас два случая в зависимости от того, <img class=tex src="../tex2png/cache/e714c1b7e07b7259d89a5d506587906d.png" alt="len(p) + 1 = len(q)"> или нет.<p><li>Если <img class=tex src="../tex2png/cache/e714c1b7e07b7259d89a5d506587906d.png" alt="len(p) + 1 = len(q)">, то мы можем просто присвоить <img class=tex src="../tex2png/cache/6f2974d1c1c300b47833443abfdae91d.png" alt="link(cur) = q"> и выйти.<p><li>В противном случае, всё несколько сложнее. Необходимо произвести <b>"клонирование"</b> состояния <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q">: создать новое состояние <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone">, скопировав в него все данные из вершины <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> (суффиксную ссылку, переходы), за исключением значения <img class=tex src="../tex2png/cache/50a069f00cb79de2927015fc1ef559aa.png" alt="len">: надо присвоить <img class=tex src="../tex2png/cache/ced7bf4a243c9dbfbebba275b39ae6f9.png" alt="len(clone) = len(p) + 1">.<p>После клонирования мы проводим суффиксную ссылку из <img class=tex src="../tex2png/cache/6663959c5800fe82135dd0d815744325.png" alt="cur"> в это состояние <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone">, также перенаправляем суффиксную ссылку из <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> в <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone">.<p>Наконец, последнее, что мы должны сделать &mdash; это пройтись от состояния <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> по суффиксным ссылкам, и для каждого очередного состояния проверять: если имелся переход по букве <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> в состояние <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q">, то перенаправлять его в состояние <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone"> (а если нет, то останавливаться).<p><li>В любом случае, чем бы ни закончилось выполнение этой процедуры, мы в конце обновляем значение <img class=tex src="../tex2png/cache/94a3c84209772daac4440090b2936e9d.png" alt="last">, присваивая ему <img class=tex src="../tex2png/cache/6663959c5800fe82135dd0d815744325.png" alt="cur">.<p></ul><p>Если нам также нужно знать, какие вершины являются <b>терминальными</b>, а какие &mdash; нет, то мы можем найти все терминальные вершины после построения суффиксного автомата для всей строки. Для этого рассмотрим состояние, соответствующее всей строке (оно, очевидно, у нас сохранено в переменной <img class=tex src="../tex2png/cache/94a3c84209772daac4440090b2936e9d.png" alt="last">), и будем идти по его суффиксным ссылкам, пока не дойдём до начального состояния, и помечать каждое пройденное состояние как терминальное. Легко понять, что тем самым мы пометим состояния, соответствующие всем суффиксам строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, что нам и требовалось.<p>В следующем разделе мы подробно рассмотрим каждый шаг алгоритма и покажем его <b>корректность</b>.<p>Здесь же лишь отметим, что из алгоритма видно, что добавление одного символа приводит к добавлению одного или двух состояний в автомат. Таким образом, <b>линейность числа состояний</b> очевидна.<p>Линейность числа переходов, да и вообще линейное время работы алгоритма менее понятны, и они будут доказаны ниже, после доказательства корректности алгоритма.<p><p><h3 style="padding-top:15px;"> Доказательство корректности алгоритма </h3><p><ul><p><li>Назовём переход <img class=tex src="../tex2png/cache/c1ea56d7a30bcbf566a0788abd2a9881.png" alt="(p,q)"> <b>сплошным</b>, если <img class=tex src="../tex2png/cache/e714c1b7e07b7259d89a5d506587906d.png" alt="len(p) + 1 = len(q)">. В противном случае, т.е. когда <img class=tex src="../tex2png/cache/68039ce69dc6a1bae5979b2e397a0d65.png" alt="len(p) + 1 < len(q)">, переход будем называть <b>несплошным</b>.<p>Как можно увидеть из описания алгоритма, сплошные и несплошные переходы приводят к разным ветвям алгоритма. Сплошные переходы называются так потому, что, появившись впервые, они больше никогда не будут меняться. В противоположность им, несплошные переходы могут измениться при добавлении новых букв к строке (измениться может конец дуги-перехода).<p><li>Во избежание неоднозначностей, под строкой <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> мы будем подразумевать строку, для которой был построен суффиксный автомат до добавления текущего символа <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">.<p><li>Алгоритм начинается с того, что мы создаём новое состояние <img class=tex src="../tex2png/cache/6663959c5800fe82135dd0d815744325.png" alt="cur">, которому будет соответствовать вся строка <img class=tex src="../tex2png/cache/5a5e0cb9c046911cc4e8ae1e0ab5e2a6.png" alt="s + c">. Понятно, почему мы обязаны создать новое состояние &mdash; т.к. вместе с добавлением нового символа возникает новый класс эквивалентности &mdash; это класс строк, оканчивающихся на добавляемом символе <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">.<p><li>После создания нового состояния алгоритм проходится по суффиксным ссылкам, начиная с состояния, соответствующего всей строке <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, и пытается добавить переход по символу <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> в состояние <img class=tex src="../tex2png/cache/6663959c5800fe82135dd0d815744325.png" alt="cur">. Тем самым, мы приписываем к каждому суффиксу строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> символ <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">. Но добавлять новые переходы мы можем только в том случае, если они не будут конфликтовать с уже имеющимися, поэтому, как только мы встретим уже имеющийся переход по символу <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">, мы сразу же обязаны остановиться.<p><li>Самый простой случай &mdash; если мы так и дошли до фиктивного состояния <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1">, добавив везде по новому переходу вдоль символа <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">. Это означает, что символ <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> в строке <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> ранее не встречался. Мы успешно добавили все переходы, осталось только проставить суффиксную ссылку у состояния <img class=tex src="../tex2png/cache/6663959c5800fe82135dd0d815744325.png" alt="cur"> &mdash; она, очевидно, должна быть равна <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0">, поскольку состоянию <img class=tex src="../tex2png/cache/6663959c5800fe82135dd0d815744325.png" alt="cur"> в данном случае соответствуют все суффиксы строки <img class=tex src="../tex2png/cache/99900616b13d9af6a87038748b4ce066.png" alt="s+c">.<p><li>Второй случай &mdash; когда мы наткнулись на уже имеющийся переход <img class=tex src="../tex2png/cache/c1ea56d7a30bcbf566a0788abd2a9881.png" alt="(p,q)">. Это означает, что мы пытались добавить в автомат строку <img class=tex src="../tex2png/cache/b42f3d68822c86129843cf4c8cb55ba2.png" alt="x+c"> (где <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> &mdash; некоторый суффикс строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, имеющий длину <img class=tex src="../tex2png/cache/de15bc2b9d0ee32790c3e7ee6287ee6d.png" alt="len(p)">), а эта строка <b>уже была ранее добавлена</b> в автомат (т.е. строка <img class=tex src="../tex2png/cache/b42f3d68822c86129843cf4c8cb55ba2.png" alt="x+c"> уже входит как подстрока в строку <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">). Поскольку мы предполагаем, что автомат для строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> построен корректно, то новых переходов мы больше добавлять не должны.<p>Однако возникает сложность с тем, куда вести суффиксную ссылку из состояния <img class=tex src="../tex2png/cache/6663959c5800fe82135dd0d815744325.png" alt="cur">. Нам требуется провести суффиксную ссылку в такое состояние, в котором длиннейшей строкой будет являться как раз эта самая <img class=tex src="../tex2png/cache/b42f3d68822c86129843cf4c8cb55ba2.png" alt="x+c">, т.е. <img class=tex src="../tex2png/cache/50a069f00cb79de2927015fc1ef559aa.png" alt="len"> для этого состояния должен быть равен <img class=tex src="../tex2png/cache/d0d6a2781919fdeffbae9907d742f63f.png" alt="len(p) + 1">. Однако такого состояния могло и не существовать: в таком случае нам надо произвести <b>"расщепление"</b> состояния.<p><li>Итак, по одному из возможных сценариев, переход <img class=tex src="../tex2png/cache/c1ea56d7a30bcbf566a0788abd2a9881.png" alt="(p,q)"> оказался сплошным, т.е. <img class=tex src="../tex2png/cache/7915dffced35c826b4a879f9e2b64e5b.png" alt="len(q) = len(p) + 1">. В этом случае всё просто, никакого расщепления производить не надо, и мы просто проводим суффиксную ссылку из состояния <img class=tex src="../tex2png/cache/6663959c5800fe82135dd0d815744325.png" alt="cur"> в состояние <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q">.<p><li>Другой, более сложный вариант &mdash; когда переход несплошной, т.е. <img class=tex src="../tex2png/cache/984db5020a714b3e9513bb35d64ef6bd.png" alt="len(q) > len(p) + 1">. Это означает, что состоянию <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> соответствует не только нужная нам подстрока <img class=tex src="../tex2png/cache/22a0745763af9978ca747539bfbda66f.png" alt="w+c"> длины <img class=tex src="../tex2png/cache/d0d6a2781919fdeffbae9907d742f63f.png" alt="len(p) + 1">, но также и подстроки большей длины. Нам ничего не остаётся, кроме как произвести <b>"расщепление"</b> состояния <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q">: разбить отрезок строк, соответствующих ей, на два подотрезка, так что первый будет заканчиваться как раз длиной <img class=tex src="../tex2png/cache/d0d6a2781919fdeffbae9907d742f63f.png" alt="len(p) + 1">.<p>Как производить это расщепление? Мы <b>"клонируем"</b> состояние <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q">, делая его копию <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone"> с параметром <img class=tex src="../tex2png/cache/ced7bf4a243c9dbfbebba275b39ae6f9.png" alt="len(clone) = len(p) + 1">. Мы копируем в <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone"> из <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> все переходы, поскольку мы не хотим никоим образом менять пути, проходившие через <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q">. Суффиксную ссылку из <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone"> мы ведём туда, куда вела старая суффиксная ссылка из <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q">, а ссылку из <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> направляем в <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone">.<p>После клонирования мы проводим суффиксную ссылку из <img class=tex src="../tex2png/cache/6663959c5800fe82135dd0d815744325.png" alt="cur"> в <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone"> &mdash; то, ради чего мы и производили клонирование.<p>Остался последний шаг &mdash; перенаправить некоторые входящие в <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> переходы, перенаправив их на <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone">. Какие именно входящие переходы надо перенаправить? Достаточно перенаправить только переходы, соответствующие всем суффиксам строки <img class=tex src="../tex2png/cache/22a0745763af9978ca747539bfbda66f.png" alt="w+c">, т.е. нам надо продолжить двигаться по суффиксным ссылкам, начиная с вершины <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">, и до тех пор, пока мы не дойдём до фиктивного состояния <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1"> или не дойдём до состояния, переход из которого ведёт в состояние, отличное от <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q">.<p></ul><p><p><h3 style="padding-top:15px;"> Доказательство линейного числа операций </h3><p>Во-первых, сразу оговоримся, что мы считаем размер алфавита <b>константой</b>. Если это не так, то говорить о линейном времени работы не получится: список переходов из одной вершины надо хранить в виде сбалансированного дерева, позволяющего быстро производить операции поиска по ключу и добавления ключа. Следовательно, если мы обозначим через <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> размер алфавита, то асимптотика алгоритма составит <img class=tex src="../tex2png/cache/a8770007d7bdb23d5616ac746b0f45ad.png" alt="O (n \log k)"> при <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"> памяти. Впрочем, если алфавит достаточно мал, то можно, пожертвовав памятью, избежать сбалансированных списков, а хранить переходы в каждой вершине в виде массива длины <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> (для быстрого поиска по ключу) и динамического списка (для быстрого обхода всех имеющихся ключей). Тем самым мы достигнем <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> во времени работы алгоритма, но ценой <img class=tex src="../tex2png/cache/a51f60cb3a9fe30aec7b8bc1c71a5296.png" alt="O (n k)"> потребления памяти.<p>Итак, мы будем считать размер алфавита константным, т.е. каждая операция поиска перехода по символу, добавления перехода, поиск следующего перехода &mdash; все эти операции мы считаем работающими за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)">.<p>Если мы рассмотрим все части алгоритма, то он содержит три места, линейная асимптотика которых не очевидна:<p><ul><p><li>Первое место &mdash; это проход по суффиксным ссылкам от состояния <img class=tex src="../tex2png/cache/94a3c84209772daac4440090b2936e9d.png" alt="last"> с добавлением рёбер по символу <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">.<p><li>Второе место &mdash; копирование переходов при клонировании состояния <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> в новое состояние <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone">.<p><li>Третье место &mdash; перенаправление переходов, ведущих в <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q">, на <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone">.<p></ul><p>Воспользуемся известным фактом, что размер суффиксного автомата (как по числу состояний, так и по числу переходов) <b>линеен</b>. (Доказательством линейности по числу состояний является сам алгоритм, а доказательство линейности по числу переходов мы приведём ниже, после реализации алгоритма.).<p>Тогда очевидна линейная суммарная асимптотика <b>первого и второго места</b>: ведь каждая операция здесь добавляет в автомат один новый переход.<p>Осталось оценить суммарную асимптотику <b>в третьем месте</b> &mdash; в том, где мы перенаправляем переходы, ведущие в <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q">, на <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone">. Обозначим <img class=tex src="../tex2png/cache/aec159c58e0df2973578272d1c556573.png" alt="v = longest(p)">. Это суффикс строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, и с каждой итерацией его длина убывает &mdash; а, значит, и позиция <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> как суффикса строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> монотонно возрастает с каждой итерацией. При этом, если перед первой итерацией цикла соответствующая строка <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> была на глубине <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> (<img class=tex src="../tex2png/cache/81b23d88267e11d6f60421cb24c00760.png" alt="k \ge 2">) от <img class=tex src="../tex2png/cache/94a3c84209772daac4440090b2936e9d.png" alt="last"> (если считать глубиной число суффиксных ссылок, которые надо пройти), то после последней итерации строка <img class=tex src="../tex2png/cache/c428b12efd399bff9fcc3a5dbc21b5ac.png" alt="v+c"> станет <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2">-ой суффиксной ссылкой на пути от <img class=tex src="../tex2png/cache/6663959c5800fe82135dd0d815744325.png" alt="cur"> (которое станет новым значением <img class=tex src="../tex2png/cache/94a3c84209772daac4440090b2936e9d.png" alt="last">).<p>Таким образом, каждая итерация этого цикла приводит к тому, что позиция строки <img class=tex src="../tex2png/cache/b0bd9749f24310c84db3a01ecbc1ec74.png" alt="longest(link(link(last))"> как суффикса всей текущей строки будет монотонно увеличиваться. Следовательно, всего этот цикл не мог отработать более <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> итераций, <b>что и требовалось доказать</b>.<p>(Стоит заметить, что аналогичные аргументы можно использовать и для доказательства линейности работы первого места, вместо ссылки на доказательство линейности числа состояний.)<p><p><h2 style="padding-top:40px;"> Реализация алгоритма </h2><p>Вначале опишем структуру данных, которая будет хранить всю информацию о конкретном переходе (<img class=tex src="../tex2png/cache/50a069f00cb79de2927015fc1ef559aa.png" alt="len">, <img class=tex src="../tex2png/cache/0c9d72169ccd8e141f8f5a2d46f89615.png" alt="link">, список переходов). При необходимости сюда можно добавить флаг терминальности, а также другую требуемую информацию. Список переходов мы храним в виде стандартного контейнера <img class=tex src="../tex2png/cache/fb80bd95620553bcf60b1b369ca11fae.png" alt="map">, что позволяет достичь суммарно <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> памяти и <img class=tex src="../tex2png/cache/a8770007d7bdb23d5616ac746b0f45ad.png" alt="O (n \log k)"> времени на обработку всей строки.<p><pre class="notranslate cpp"><span class="kw4">struct</span> state <span class="br0">&#123;</span>
	<span class="kw4">int</span> len, link<span class="sy4">;</span>
	map<span class="sy1">&lt;</span><span class="kw4">char</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> next<span class="sy4">;</span>
<span class="br0">&#125;</span><span class="sy4">;</span></pre><p>Сам суффиксный автомат будем хранить в виде массива этих структур <img class=tex src="../tex2png/cache/04a0d522d895f2910061a2b91bd7a07e.png" alt="state">. Как доказывается в следующем разделе, если <img class=tex src="../tex2png/cache/5bf07cab047c3b14d8d778a5c31e1583.png" alt="MAXN"> &mdash; это максимально возможная в программе длина строки, то достаточно завести память под <img class=tex src="../tex2png/cache/ca03c137359dbccdaf90dd738f37d1b4.png" alt="2 \cdot MAXN - 1"> состояний. Также мы храним переменную <img class=tex src="../tex2png/cache/94a3c84209772daac4440090b2936e9d.png" alt="last"> &mdash; состояние, соответствующее всей строке на данный момент.<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> MAXLEN <span class="sy1">=</span> <span class="nu0">100000</span><span class="sy4">;</span>
state st<span class="br0">&#91;</span>MAXLEN<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">int</span> sz, last<span class="sy4">;</span></pre><p>Приведём функцию, инициализирующую суффиксный автомат (создающую автомат с единственным начальным состоянием):<p><pre class="notranslate cpp"><span class="kw4">void</span> sa_init<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	sz <span class="sy1">=</span> last <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	st<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">len</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	st<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">link</span> <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="sy2">++</span>sz<span class="sy4">;</span>
	<span class="coMULTI">/*
	// этот код нужен, только если автомат строится много раз для разных строк:
	for (int i=0; i&lt;MAXLEN*2; ++i)
		st[i].next.clear();
	*/</span>
<span class="br0">&#125;</span></pre><p>Наконец, приведём реализацию основной функции &mdash; которая добавляет очередной символ в конец текущей строки, перестраивая соответствующим образом автомат:<p><pre class="notranslate cpp"><span class="kw4">void</span> sa_extend <span class="br0">&#40;</span><span class="kw4">char</span> c<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> cur <span class="sy1">=</span> sz<span class="sy2">++</span><span class="sy4">;</span>
	st<span class="br0">&#91;</span>cur<span class="br0">&#93;</span>.<span class="me1">len</span> <span class="sy1">=</span> st<span class="br0">&#91;</span>last<span class="br0">&#93;</span>.<span class="me1">len</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw4">int</span> p<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span>p<span class="sy1">=</span>last<span class="sy4">;</span> p<span class="sy3">!</span><span class="sy1">=</span><span class="sy2">-</span><span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> <span class="sy3">!</span>st<span class="br0">&#91;</span>p<span class="br0">&#93;</span>.<span class="me1">next</span>.<span class="me1">count</span><span class="br0">&#40;</span>c<span class="br0">&#41;</span><span class="sy4">;</span> p<span class="sy1">=</span>st<span class="br0">&#91;</span>p<span class="br0">&#93;</span>.<span class="me1">link</span><span class="br0">&#41;</span>
		st<span class="br0">&#91;</span>p<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span> <span class="sy1">=</span> cur<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>p <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>
		st<span class="br0">&#91;</span>cur<span class="br0">&#93;</span>.<span class="me1">link</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> q <span class="sy1">=</span> st<span class="br0">&#91;</span>p<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>st<span class="br0">&#91;</span>p<span class="br0">&#93;</span>.<span class="me1">len</span> <span class="sy2">+</span> <span class="nu0">1</span> <span class="sy1">==</span> st<span class="br0">&#91;</span>q<span class="br0">&#93;</span>.<span class="me1">len</span><span class="br0">&#41;</span>
			st<span class="br0">&#91;</span>cur<span class="br0">&#93;</span>.<span class="me1">link</span> <span class="sy1">=</span> q<span class="sy4">;</span>
		<span class="kw1">else</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> clone <span class="sy1">=</span> sz<span class="sy2">++</span><span class="sy4">;</span>
			st<span class="br0">&#91;</span>clone<span class="br0">&#93;</span>.<span class="me1">len</span> <span class="sy1">=</span> st<span class="br0">&#91;</span>p<span class="br0">&#93;</span>.<span class="me1">len</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
			st<span class="br0">&#91;</span>clone<span class="br0">&#93;</span>.<span class="me1">next</span> <span class="sy1">=</span> st<span class="br0">&#91;</span>q<span class="br0">&#93;</span>.<span class="me1">next</span><span class="sy4">;</span>
			st<span class="br0">&#91;</span>clone<span class="br0">&#93;</span>.<span class="me1">link</span> <span class="sy1">=</span> st<span class="br0">&#91;</span>q<span class="br0">&#93;</span>.<span class="me1">link</span><span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;</span> p<span class="sy3">!</span><span class="sy1">=</span><span class="sy2">-</span><span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> st<span class="br0">&#91;</span>p<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span><span class="sy1">==</span>q<span class="sy4">;</span> p<span class="sy1">=</span>st<span class="br0">&#91;</span>p<span class="br0">&#93;</span>.<span class="me1">link</span><span class="br0">&#41;</span>
				st<span class="br0">&#91;</span>p<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#91;</span>c<span class="br0">&#93;</span> <span class="sy1">=</span> clone<span class="sy4">;</span>
			st<span class="br0">&#91;</span>q<span class="br0">&#93;</span>.<span class="me1">link</span> <span class="sy1">=</span> st<span class="br0">&#91;</span>cur<span class="br0">&#93;</span>.<span class="me1">link</span> <span class="sy1">=</span> clone<span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	last <span class="sy1">=</span> cur<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Как уже упоминалось выше, если пожертвовать памятью (до <img class=tex src="../tex2png/cache/a51f60cb3a9fe30aec7b8bc1c71a5296.png" alt="O (n k)">, где <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> &mdash; размер алфавита), то можно достичь времени построения автомата <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"> даже для любых <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> &mdash; но для этого придётся в каждом состоянии хранить массив размера <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> (для быстрого поиска перехода по нужной букве) и список всех переходов (для быстрого обхода или копирования всех переходов).<p><p><p><h2 style="padding-top:40px;"> Дополнительные свойства суффиксного автомата </h2><p><p><h3 style="padding-top:15px;"> Число состояний </h3><p>Число состояний в суффиксном автомате, построенном для строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, <b>не превышает <img class=tex src="../tex2png/cache/072e6ac03ecf104f2cadad60066d7d36.png" alt="2n-1"></b> (для <img class=tex src="../tex2png/cache/57e74afb511d3977121a467b910ccd30.png" alt="n \ge 3">).<p>Доказательством этого является описанный выше алгоритм (поскольку изначально автомат состоит из одного начального состояния, на первом и втором шагах добавляется ровно по одному состоянию, а на каждом из остальных <img class=tex src="../tex2png/cache/3c24e4e1066ea76ff7ba0fb29a761758.png" alt="n-2"> шагах могло добавляться по две вершины из-за расщепления состояния).<p>Однако эту оценку <b>легко показать и без знания алгоритма</b>. Вспомним о том, что число состояний равно количеству различных значений множеств <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">. Кроме того, эти множества <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos"> образуют дерево по принципу "вершина-родитель содержит в себе как подмножества всех детей". Рассмотрим это дерево, и немного преобразуем его: пока в нём есть внутренняя вершина с одним сыном, то это означает, что <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos"> этого сына не содержит как минимум одно число из <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos"> родителя; тогда создадим виртуальную вершину с <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">, равным этому числу, и привесим этого сына к родителю. В итоге мы получим дерево, в котором каждая внутренняя вершина имеет степень больше единицы, а число листьев не превосходит <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Следовательно, всего в таком дереве не более <img class=tex src="../tex2png/cache/072e6ac03ecf104f2cadad60066d7d36.png" alt="2n-1"> вершины.<p>Итак, мы показали эту оценку независимо, без знания алгоритма.<p>Интересно заметить, что эта оценка неулучшаема, т.е. существует <b>тест, на котором она достигается</b>. Этот тест выглядит таким образом:<p><p class=formula><img class=tex src="../tex2png/cache/eb6473ee663d158fe179c39315e2b634.png" alt=" " abbbb \ldots " "></p><p>При обработке этой строки на каждой итерации, начиная с третьей, будет происходить расщепление состояния, и, тем самым, будет достигаться оценка <img class=tex src="../tex2png/cache/072e6ac03ecf104f2cadad60066d7d36.png" alt="2n-1">.<p><p><h3 style="padding-top:15px;"> Число переходов </h3><p>Число переходов в суффиксном автомате, построенном для строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, <b>не превышает <img class=tex src="../tex2png/cache/e8a9fce13925bf216d1be097467a0fb6.png" alt="3n-4"></b> (для <img class=tex src="../tex2png/cache/57e74afb511d3977121a467b910ccd30.png" alt="n \ge 3">).<p><b>Докажем</b> это.<p>Оценим число сплошных переходов. Рассмотрим остовное дерево из длиннейших путей в автомате, начинающихся в состоянии <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0">. Этот остов будет состоять только из сплошных рёбер, а, значит, их количество на единицу меньше числа состояний, т.е. не превосходит <img class=tex src="../tex2png/cache/8544b63735ac13dc1cad3999e9840daf.png" alt="2n-2">.<p>Оценим теперь число несплошных переходов. Рассмотрим каждый несплошной переход; пусть текущий переход &mdash; это переход <img class=tex src="../tex2png/cache/c1ea56d7a30bcbf566a0788abd2a9881.png" alt="(p,q)"> по символу <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">. Поставим ему в соответствие строку <img class=tex src="../tex2png/cache/56ab3d43565c08226ce4b889726fcf8b.png" alt="u+c+w">, где строка <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> соответствует длиннейшему пути из начального состояния в <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">, а <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> &mdash; длиннейшему пути из <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> в какое-либо терминальное состояние. С одной стороны, все такие строки <img class=tex src="../tex2png/cache/56ab3d43565c08226ce4b889726fcf8b.png" alt="u+c+w"> для всех несплошных переходов будут различными (поскольку строки <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> и <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> образованы только сплошными переходами). С другой стороны, каждая из таких строк <img class=tex src="../tex2png/cache/56ab3d43565c08226ce4b889726fcf8b.png" alt="u+c+w">, по определению терминального состояния, будет суффиксом всей строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">. Поскольку непустых суффиксов у строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> всего <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> штук, и к тому же вся строка <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> среди этих строк <img class=tex src="../tex2png/cache/56ab3d43565c08226ce4b889726fcf8b.png" alt="u+c+w"> не могла содержаться (т.к. всей строке <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> соответствует путь из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> сплошных рёбер), то общее число несплошных переходов не превосходит <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">.<p>Складывая эти две оценки, мы получаем оценку <img class=tex src="../tex2png/cache/ec3dd1b19fe916087b6a32f4c2211317.png" alt="3n-3">. Однако, вспоминая, что максимальное число состояний достигается только на тесте вида <img class=tex src="../tex2png/cache/fb30b8a4b86e5273bcfee7384213f818.png" alt=""abbbb \ldots "">, и на нём оценка <img class=tex src="../tex2png/cache/ec3dd1b19fe916087b6a32f4c2211317.png" alt="3n-3"> явно не достигается, получаем окончательную оценку <img class=tex src="../tex2png/cache/e8a9fce13925bf216d1be097467a0fb6.png" alt="3n-4">, что и требовалось доказать.<p>Интересно отметить, что также существует <b>тест, на котором эта оценка достигается</b>:<p><p class=formula><img class=tex src="../tex2png/cache/ea66dd58ece8c6b0d4083c97478ba1e0.png" alt=" "abbb \ldots bbbc" "><p></p><p><h3 style="padding-top:15px;"> Связь с суффиксным деревом. Построение суффиксного дерева по суффиксному автомату и наоборот </h3><p>Докажем две теоремы, устанавливающие взаимную связь между суффиксным автоматом и <a href="ukkonen.html">суффиксным деревом</a>.<p>Сразу оговоримся, что мы считаем, что входная строка такова, что каждый суффикс имеет собственную вершину в суффиксном дереве (поскольку для произвольных строк это, вообще говоря, неверно: например, для строки <img class=tex src="../tex2png/cache/e6b9c0f3804d8fa1117e4f951b69772f.png" alt=""aaa \ldots"">). Обычно этого добиваются путём приписывания в конец строки какого-нибудь особого символа (обычно обозначаемого через знак доллара).<p>Для удобства введём обозначения: <img class=tex src="../tex2png/cache/7858ec9e26e7af6ef3833e9ea669b06e.png" alt="\overline{s}"> &mdash; это строка <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, записанная в обратном порядке, <img class=tex src="../tex2png/cache/74977bbc1979b3e8e5f7ebc9daf532dd.png" alt="DAWG(s)"> &mdash; это суффиксный автомат, построенный для строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, <img class=tex src="../tex2png/cache/2b07f5dc9a1e299dfcba24fc10b18083.png" alt="ST(s)"> &mdash; это <a href="ukkonen.html">суффиксное дерево</a> строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">.<p>Введём понятие <b>расширяющей ссылки</b>: зафиксируем вершину суффиксного дерева <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> и символ <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">; тогда расширяющая ссылка <img class=tex src="../tex2png/cache/c7e60f53946c9d3c8279b3b7172a72eb.png" alt="ext[c,v]"> ведёт в вершину дерева, соответствующую строке <img class=tex src="../tex2png/cache/098b42fdc0ac83f42e393117dae0c545.png" alt="c+v"> (если этот путь <img class=tex src="../tex2png/cache/098b42fdc0ac83f42e393117dae0c545.png" alt="c+v"> оканчивается посередине ребра, то проведём ссылку в нижний конец этого ребра); если такого пути <img class=tex src="../tex2png/cache/098b42fdc0ac83f42e393117dae0c545.png" alt="c+v"> вообще нет в дереве, то расширяющая ссылка не определена. В некотором смысле, расширяющие ссылки противоположны суффиксным ссылкам.<p><b>Теорема 1</b>. Дерево, образованное суффиксными ссылками в <img class=tex src="../tex2png/cache/74977bbc1979b3e8e5f7ebc9daf532dd.png" alt="DAWG(s)">, является суффиксным деревом <img class=tex src="../tex2png/cache/2c61d6d8127acd87250f6c16bccc447d.png" alt="ST(\overline{s})">.<p><b>Теорема 2</b>. <img class=tex src="../tex2png/cache/74977bbc1979b3e8e5f7ebc9daf532dd.png" alt="DAWG(s)"> &mdash; это граф расширяющих ссылок суффиксного дерева <img class=tex src="../tex2png/cache/2c61d6d8127acd87250f6c16bccc447d.png" alt="ST(\overline{s})">. Кроме того, сплошные рёбра в <img class=tex src="../tex2png/cache/74977bbc1979b3e8e5f7ebc9daf532dd.png" alt="DAWG(s)"> &mdash; это инвертированные суффиксные ссылки в <img class=tex src="../tex2png/cache/2c61d6d8127acd87250f6c16bccc447d.png" alt="ST(\overline{s})">.<p>Эти две теоремы позволяют по одной из структур (суффиксному дереву или суффиксному автомату) построить другую за время <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> &mdash; эти два простых алгоритма будут рассмотрены нами ниже в теоремах 3 и 4.<p>В целях наглядности, приведём суффиксный автомат с его деревом суффиксных ссылок и соответствующее суффиксное дерево для инвертированной строки. Для примера возьмём строку <img class=tex src="../tex2png/cache/33c5fcfb9c18f03a00af61495502a07e.png" alt="s = "abcbc"">.<p><img class=tex src="../tex2png/cache/104b5eba305df2b0a007cd67a6a65cbc.png" alt="DAWG("abcbc")"> и его дерево суффиксных ссылок (для наглядности мы подписываем каждое состояние его <img class=tex src="../tex2png/cache/b04722aedf4a9d740933897dc81d4329.png" alt="longest">-строкой):<p><img src="suffix_automaton_st_1.gif"><p><img class=tex src="../tex2png/cache/6cd59532fb4a6321bd8058c35ad603e3.png" alt="ST("cbcba")">:<p><img src="suffix_automaton_st_2.gif"><p><b>Лемма</b>. Следующие три утверждения эквивалентны для любых двух подстрок <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> и <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">:<p><ul><p><li><img class=tex src="../tex2png/cache/2c7be530f0e3f4a78137046ee2acf87d.png" alt="endpos(u) = endpos(w)"> в строке <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"><li><img class=tex src="../tex2png/cache/c1779ff0e8db76a742902c69c12f2c41.png" alt="firstpos(\overline{u}) = firstpos(\overline{w})"> в строке <img class=tex src="../tex2png/cache/7858ec9e26e7af6ef3833e9ea669b06e.png" alt="\overline{s}"><li><img class=tex src="../tex2png/cache/cd092f628acb2e5fd89348f0944c5d0b.png" alt="\overline{u}"> и <img class=tex src="../tex2png/cache/8425bdf2ddb31af2f2820d4e5cb4f16f.png" alt="\overline{w}"> лежат на одном и том же пути из корня в суффиксном дереве <img class=tex src="../tex2png/cache/2c61d6d8127acd87250f6c16bccc447d.png" alt="ST(\overline{s})">.<p></ul><p>Доказательство её довольно очевидно: если начала вхождений двух строк совпадают, то одна строка является префиксом другой, а, значит, одна строка лежит в суффиксном дереве на пути другой строки.<p><b>Доказательство теоремы 1</b>. <p>Состояния суффиксного автомата соответствуют вершинам суффиксного дерева.<p>Рассмотрим произвольную суффиксную ссылку <img class=tex src="../tex2png/cache/44070d63a425d194d0032fdc507e43d5.png" alt="y = link(x)">. Согласно определению суффиксной ссылки, <img class=tex src="../tex2png/cache/bad879343f53fac72806454cc8469633.png" alt="longest(y)"> является суффиксом <img class=tex src="../tex2png/cache/5436a8c295016ecb7fe0530be0114a11.png" alt="longest(x)">, причём среди всех таких <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> выбирается тот, у которого <img class=tex src="../tex2png/cache/2f9f55ece024987499d485b3b22d8398.png" alt="len(y)"> максимально.<p>В терминах инвертированной строки <img class=tex src="../tex2png/cache/7858ec9e26e7af6ef3833e9ea669b06e.png" alt="\overline{s}"> это означает, что суффиксная ссылка <img class=tex src="../tex2png/cache/52fac059b818e1c6c860e61f66e1f750.png" alt="link[x]"> ведёт в такой длиннейший префикс строки, соответствующей состоянию <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">, чтобы этому префиксу соответствовало отдельное состояние <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">. Иными словами, суффиксная ссылка <img class=tex src="../tex2png/cache/52fac059b818e1c6c860e61f66e1f750.png" alt="link[x]"> ведёт в предка вершины <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> в суффиксном дереве, что и требовалось доказать.<p><b>Доказательство теоремы 2</b>.<p>Состояния суффиксного автомата соответствуют вершинам суффиксного дерева.<p>Рассмотрим произвольный переход <img class=tex src="../tex2png/cache/006e78aca5b72f70fa3ede849a39bcfb.png" alt="(x,y,c)"> в суффиксном автомате <img class=tex src="../tex2png/cache/74977bbc1979b3e8e5f7ebc9daf532dd.png" alt="DAWG(s)">. Наличие этого перехода означает, что <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> &mdash; это такое состояние, класс эквивалентности которого содержит подстроку <img class=tex src="../tex2png/cache/1c99dcecba332e41971448a03f9f745f.png" alt="longest(x) + c">. В инвертированной строке <img class=tex src="../tex2png/cache/7858ec9e26e7af6ef3833e9ea669b06e.png" alt="\overline{s}"> это означает, что <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> это такое состояние, которому соответствует подстрока, <img class=tex src="../tex2png/cache/d53ca2bbfc14cb878d8af176a27b11d6.png" alt="firstpos"> от которой (в тексте <img class=tex src="../tex2png/cache/7858ec9e26e7af6ef3833e9ea669b06e.png" alt="\overline{s}">) совпадает с <img class=tex src="../tex2png/cache/d53ca2bbfc14cb878d8af176a27b11d6.png" alt="firstpos"> от подстроки <img class=tex src="../tex2png/cache/99b4a707f48cbe752fe25adbbb338e29.png" alt="c + \overline{longest(x)}">.<p>Это как раз и означает, что:<p><p class=formula><img class=tex src="../tex2png/cache/08ffc4619d4409fb3f2bb594b6b3df61.png" alt=" \overline{longest(y)} = ext[c, \overline{longest([...]"></p><p>Первая часть теоремы доказана, осталось доказать вторую часть: что все сплошные переходы в автомате соответствуют суффиксным ссылкам в дереве. Сплошной переход отличается от несплошного тем, что <img class=tex src="../tex2png/cache/f50276bef4025d9f14400a34cef5e43c.png" alt="length(y) = length(x) + 1">, т.е. после приписывания символа <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> мы попали в состояние со строкой, максимальной из класса эквивалентности этого состояния. Это означает, что при вычислении соответствующей расширяющей ссылки <img class=tex src="../tex2png/cache/160f9fb7f7d2dc87da99b6a7c68e3d2a.png" alt="ext[c, \overline{longest(x)}]"> мы сразу попали в вершину дерева, а не спускались вниз до ближайшей вершины дерева. Таким образом, приписав один символ в начало, мы попали в другую вершину дерева &mdash; значит, если это и есть инвертированная суффиксная ссылка в дереве.<p>Теорема полностью доказана.<p><b>Теорема 3</b>. Имея суффиксный автомат <img class=tex src="../tex2png/cache/74977bbc1979b3e8e5f7ebc9daf532dd.png" alt="DAWG(s)">, можно за время <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> построить суффиксное дерево <img class=tex src="../tex2png/cache/2c61d6d8127acd87250f6c16bccc447d.png" alt="ST(\overline{s})">.<p><b>Теорема 4</b>. Имея суффиксное дерево <img class=tex src="../tex2png/cache/2c61d6d8127acd87250f6c16bccc447d.png" alt="ST(\overline{s})">, можно за время <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> построить суффиксный автомат <img class=tex src="../tex2png/cache/74977bbc1979b3e8e5f7ebc9daf532dd.png" alt="DAWG(s)">.<p><b>Доказательство теоремы 3</b>.<p>Суффиксное дерево <img class=tex src="../tex2png/cache/2c61d6d8127acd87250f6c16bccc447d.png" alt="ST(\overline{s})"> будет содержать столько же вершин, сколько состояний в <img class=tex src="../tex2png/cache/74977bbc1979b3e8e5f7ebc9daf532dd.png" alt="DAWG(s)">, причём вершине дерева, получившейся из состояния <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> автомата, соответствует строка длины <img class=tex src="../tex2png/cache/610147038f7617ee65d3ed91289b9bf7.png" alt="len(v)">.<p>Согласно теореме 1, рёбра в дереве образуются как инвертированные суффиксные ссылки, и дуговые метки можно найти, исходя из разности <img class=tex src="../tex2png/cache/50a069f00cb79de2927015fc1ef559aa.png" alt="len"> состояний, и дополнительно зная для каждого состояния автомата один любой элемент его множества <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos"> (этот один элемент множества <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos"> можно поддерживать при построении автомата).<p>Суффиксные ссылки в дереве мы можем построить согласно теореме 2: для этого достаточно просмотреть все сплошные переходы в автомате, и для каждого такого перехода <img class=tex src="../tex2png/cache/bceeeeebd9fec9d8ed4cd44b0d1a5b83.png" alt="(x,y)"> добавить ссылку <img class=tex src="../tex2png/cache/ceb780deaa7325bc2612e85ffa3687da.png" alt="link(y) = x">.<p>Таким образом, за время <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> мы можем построить суффиксное дерево вместе с суффиксными ссылками в нём.<p>(Если мы считаем размер <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> алфавита не константой, то на всё перестроение потребуется время <img class=tex src="../tex2png/cache/a8770007d7bdb23d5616ac746b0f45ad.png" alt="O (n \log k)">.)<p><b>Доказательство теоремы 4</b>.<p>Суффиксный автомат <img class=tex src="../tex2png/cache/74977bbc1979b3e8e5f7ebc9daf532dd.png" alt="DAWG(s)"> будет содержать столько же состояний, сколько вершин в <img class=tex src="../tex2png/cache/2c61d6d8127acd87250f6c16bccc447d.png" alt="ST(\overline{s})">. У каждого состояния <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> его длиннейшая строка <img class=tex src="../tex2png/cache/325ea4a4246ac97011c6c6594c474985.png" alt="longest(v)"> будет соответствовать инвертированному пути из корня дерева до вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">.<p>Согласно теореме 2, чтобы построить все переходы в суффиксном автомате, нам надо найти все расширяющие ссылки <img class=tex src="../tex2png/cache/c7e60f53946c9d3c8279b3b7172a72eb.png" alt="ext[c,v]">.<p>Во-первых, заметим, что часть этих расширяющих ссылок получаются непосредственно из суффиксных ссылок в дереве. В самом деле, если для любой вершины <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> мы рассмотрим её суффиксную ссылку <img class=tex src="../tex2png/cache/44070d63a425d194d0032fdc507e43d5.png" alt="y = link(x)">, то это означает, что надо провести расширяющую ссылку из <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> в <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> по первому символу строки, соответствующей вершине <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">.<p>Однако так мы найдём не все расширяющие ссылки. Дополнительно надо пройтись по суффиксному дереву от листьев до корня, и для каждой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> просмотреть всех её сыновей, для каждого сына просмотреть все расширяющие ссылки <img class=tex src="../tex2png/cache/e624fa6e32c438da9c986dfa33a21c83.png" alt="ext[c,w]">, и скопировать эту ссылку в вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, если по этому символу <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> ссылка из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> ещё не была найдена:<p><p class=formula><img class=tex src="../tex2png/cache/574df991e607dffbbb4f6298f5b747a4.png" alt=" ext[c,v] = ext[c,w], ~~~~ \text{if $ext[c,w] = ni[...]"></p><p>Этот процесс отработает за время <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)">, если мы считаем размер алфавита константным.<p>Наконец, осталось построить суффиксные ссылки в автомате, однако, согласно теореме 1, эти суффиксные ссылки получаются просто как рёбра суффиксного дерева <img class=tex src="../tex2png/cache/2c61d6d8127acd87250f6c16bccc447d.png" alt="ST(\overline{s})">.<p>Таким образом, описанный алгоритм за время <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> строит суффиксный автомат по суффиксному дереву для инвертированной строки.<p>(Если же мы считаем, что размер <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> алфавита &mdash; также переменная величина, то асимптотика увеличится до <img class=tex src="../tex2png/cache/a8770007d7bdb23d5616ac746b0f45ad.png" alt="O (n \log k)">.)<p><p><p><h2 style="padding-top:40px;"> Применения при решении задач </h2><p>Ниже мы рассмотрим, какие задачи можно решать с помощью суффиксного автомата.<p>Мы для простоты будем считать размер алфавита <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> константой, что позволит нам считать асимптотику построения суффиксного автомата и прохода по нему константными.<p><p><h3 style="padding-top:15px;"> Проверка вхождения </h3><p><b>Условие</b>. Дан текст <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">, и поступают запросы в виде: дана строка <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">, требуется проверить, входит или нет строка <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> в текст <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T"> как подстрока.<p><b>Асимптотика</b>. Препроцессинг <img class=tex src="../tex2png/cache/da281b72b98b5db07a434928aaaf1ffa.png" alt="O (length (T))"> и <img class=tex src="../tex2png/cache/dc93375de0ee7e4f3dbb8a5dae281c7a.png" alt="O (length (P))"> на один запрос.<p><b>Решение</b>. Построим суффиксный автомат по тексту <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T"> за время <img class=tex src="../tex2png/cache/da281b72b98b5db07a434928aaaf1ffa.png" alt="O (length (T))">.<p>Как теперь отвечать на один запрос. Пусть текущее состояние &mdash; это переменная <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, изначально она равна начальному состоянию <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0">. Будем идти по символам строки <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">, соответствующим образом делая переход из текущего состояния <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> в новое состояние. Если в какой-то момент случилось, что перехода из текущего состояния по нужному символу не оказалось &mdash; то ответ на запрос "нет". Если же мы смогли обработать всю строку <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">, то ответ на запрос "да".<p>Понятно, что это будет работать за время <img class=tex src="../tex2png/cache/dc93375de0ee7e4f3dbb8a5dae281c7a.png" alt="O (length (P))">. Более того, алгоритм фактически ищет длину наидлиннейшего префикса <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">, встречающегося в тексте &mdash; и если входные образцы таковы, что эти длины маленькие, то и алгоритм будет работать значительно быстрее, не обрабатывая всю строку целиком.<p><p><h3 style="padding-top:15px;"> Количество различных подстрок </h3><p><b>Условие</b>. Дана строка <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">. Требуется узнать количество различных её подстрок.<p><b>Асимптотика</b>. <img class=tex src="../tex2png/cache/2d79b725d3bbfed29eaffc0d8760f2fc.png" alt="O (length (S))">.<p><b>Решение</b>. Построим суффиксный автомат по строке <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">.<p>В суффиксном автомате любой подстроке строки <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S"> соответствует какой-то путь в автомате. Поскольку повторяющихся строк в автомате быть не может, то ответ на задачу &mdash; это <b>количество различных путей</b> в автомате, начинающихся в начальной вершине <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0">.<p>Учитывая, что суффиксный автомат представляет собой ациклический граф, количество различных путей можно считать в нём с помощью динамического программирования.<p>А именно, пусть <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]"> &mdash; это количество различных путей, начинающихся с состояния <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> (включая путь длины ноль). Тогда верно:<p><p class=formula><img class=tex src="../tex2png/cache/ec4b990fe2968b1f695320f418a4c334.png" alt=" d[v] = 1 + \sum_{w ~ : \atop (v,w,c) \in DAWG} d[[...]"></p><p>т.е. <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]"> можно выразить как сумму ответов по всевозможным переходам из состояния <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">.<p>Ответом на задачу будет значение <img class=tex src="../tex2png/cache/628437cf9b3280029e1ce9f2ae124144.png" alt="d[t_0]-1"> (единица отнимается, чтобы не учитывать пустую подстроку).<p><p><h3 style="padding-top:15px;"> Суммарная длина различных подстрок </h3><p><b>Условие</b>. Дана строка <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">. Требуется узнать суммарную длину всех различных её подстрок.<p><b>Асимптотика</b>. <img class=tex src="../tex2png/cache/2d79b725d3bbfed29eaffc0d8760f2fc.png" alt="O (length (S))">.<p><b>Решение</b>. Решение задачи аналогично предыдущей, только теперь надо считать в динамике две величины: количество различных подстрок <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]"> и их суммарную длину <img class=tex src="../tex2png/cache/de4a7edb531b8c8e62048866ccd5e8c2.png" alt="ans[v]">.<p>Как считать <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]">, описано в предыдущей задаче, а величину <img class=tex src="../tex2png/cache/de4a7edb531b8c8e62048866ccd5e8c2.png" alt="ans[v]"> можно вычислить таким образом:<p><p class=formula><img class=tex src="../tex2png/cache/97814ccd659594358b94c902fadd48a9.png" alt=" ans[v] = \sum_{w ~ : \atop (v,w,c) \in DAWG} d[w][...]"></p><p>т.е. мы берём ответ для каждой вершины <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">, и прибавляем к нему <img class=tex src="../tex2png/cache/e34c0970f0ab27cd2e887d864ffdd404.png" alt="d[w]">, тем самым как бы приписывая в начало каждой из строк по одному символу.<p><p><h3 style="padding-top:15px;"> Лексикографически k-ая подстрока </h3><p><b>Условие</b>. Дана строка <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">. Поступают запросы &mdash; числа <img class=tex src="../tex2png/cache/c4da123415abcf1fc93e5efa10cfae0a.png" alt="K_i">, и требуется находить <img class=tex src="../tex2png/cache/c4da123415abcf1fc93e5efa10cfae0a.png" alt="K_i">-ую в порядке сортировки подстроку строки <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">.<p><b>Асимптотика</b>. <img class=tex src="../tex2png/cache/7246626d12bb2cc902592de8bc4b7773.png" alt="O (length (ans) \cdot Alphabet)"> на один запрос (где <img class=tex src="../tex2png/cache/1064fa2ef2472d77842eeb2d7696f9f5.png" alt="ans"> &mdash; это ответ на этот запрос, <img class=tex src="../tex2png/cache/7fc37adc87c4e88228d80c077f8cf5b1.png" alt="Alphabet"> &mdash; размер алфавита).<p><b>Решение</b>. Решение данной задачи базируется на той же идее, что и предыдущие две задачи. Лексикографически <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ая подстрока &mdash; это лексикографический <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ый путь в суффиксном автомате. Поэтому посчитав для каждого состояния количество путей из него, мы сможем легко искать <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ый путь, двигаясь от корня автомата.<p><p><h3 style="padding-top:15px;"> Наименьший циклический сдвиг </h3><p><b>Условие</b>. Дана строка <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">. Требуется найти лексикографически наименьший её циклический сдвиг.<p><b>Асимптотика</b>. <img class=tex src="../tex2png/cache/2d79b725d3bbfed29eaffc0d8760f2fc.png" alt="O (length (S))">.<p><b>Решение</b>. Построим суффиксный автомат для строки <img class=tex src="../tex2png/cache/b463ece0d979f928df58168d14932ffe.png" alt="S+S">. Тогда этот автомат будет содержать в себе как пути все циклические сдвиги строки <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">.<p>Следовательно, задача сведётся к тому, чтобы найти в автомате лексикографически минимальный путь длины <img class=tex src="../tex2png/cache/850bf4b5551c2d6fa1dd868989ccfce8.png" alt="length(S)">, что делается тривиальным образом: мы стартуем в начальном состоянии и каждый раз действуем жадно, переходя по переходу с минимальным символом.<p><p><h3 style="padding-top:15px;"> Количество вхождений </h3><p><b>Условие</b>. Дан текст <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">, и поступают запросы в виде: дана строка <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">, требуется узнать, сколько раз строка <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> входит в текст <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T"> как подстрока (вхождения могут перекрываться).<p><b>Асимптотика</b>. Препроцессинг <img class=tex src="../tex2png/cache/da281b72b98b5db07a434928aaaf1ffa.png" alt="O (length (T))"> и <img class=tex src="../tex2png/cache/dc93375de0ee7e4f3dbb8a5dae281c7a.png" alt="O (length (P))"> на один запрос.<p><b>Решение</b>. Построим суффиксный автомат по тексту <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">. <p>Дальше нам надо сделать такой препроцессинг: для каждого состояния <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> автомата посчитать число <img class=tex src="../tex2png/cache/b225b2c7fa46ea3f16638ead7c0c2277.png" alt="cnt[v]">, равное размеру множества <img class=tex src="../tex2png/cache/e41366a8e15c9b8a33ade6e514a142e3.png" alt="endpos(v)">. В самом деле, все строки, соответствующие одному и тому же состоянию, входят в <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T"> одинаковое число раз, равное количеству позиций в множестве <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos">.<p>Однако явно поддерживать множества <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos"> для всех состояний мы не можем, поэтому научимся считать только их размеры <img class=tex src="../tex2png/cache/9ef23f4e3d2645d9f049553d5dc6dd17.png" alt="cnt">.<p>Для этого поступим следующим образом. Для каждого состояния, если оно не было получено путём клонирования (и начальное состояние <img class=tex src="../tex2png/cache/1e7ba3d5157ee93842179a67c992110a.png" alt="t_0"> мы также не учитываем), изначально присвоим <img class=tex src="../tex2png/cache/f247d0ccda4335c3d898a14ec879d646.png" alt="cnt = 1">. Затем будем идти по всем состояниям в порядке убывания их длины <img class=tex src="../tex2png/cache/50a069f00cb79de2927015fc1ef559aa.png" alt="len"> и пробрасывать текущее значение <img class=tex src="../tex2png/cache/b225b2c7fa46ea3f16638ead7c0c2277.png" alt="cnt[v]"> по суффиксной ссылке:<p><p class=formula><img class=tex src="../tex2png/cache/003913b3445e24d8f25a23628cb3280f.png" alt=" cnt[link(v)] += cnt[v]. "></p><p>Утверждается, что в конце концов мы так посчитаем для каждого состояния правильные значения <img class=tex src="../tex2png/cache/9ef23f4e3d2645d9f049553d5dc6dd17.png" alt="cnt">.<p>Почему это верно? Всего состояний, полученных не путём клонирования, ровно <img class=tex src="../tex2png/cache/850bf4b5551c2d6fa1dd868989ccfce8.png" alt="length(S)">, и <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ое из них появилось, когда мы добавили первые <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> символов. Следовательно, каждому из этих состояний мы ставим в соответствие эту позицию, при обработке которой оно появилось. Поэтому изначально у каждого такого состояния <img class=tex src="../tex2png/cache/f247d0ccda4335c3d898a14ec879d646.png" alt="cnt = 1">, а у всех остальных состояний <img class=tex src="../tex2png/cache/54f61d313016367da41a2fda51225b2d.png" alt="cnt = 0">.<p>Затем мы выполняем для каждого <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> такую операцию: <img class=tex src="../tex2png/cache/98d3c743f6ac7b1eeffcb7195dc87457.png" alt="cnt[link(v)] += cnt[v]">. Смысл этого заключается в том, что если строка, соответствующая состоянию <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, встречалась <img class=tex src="../tex2png/cache/b225b2c7fa46ea3f16638ead7c0c2277.png" alt="cnt[v]"> раз, то все её суффиксы будут встречаться столько же.<p>Почему тем самым мы не учтём одну и ту же позицию несколько раз? Потому что из каждого состояния его значение "пробрасывается" только один раз, поэтому не могло так получиться, что из одного состояния его значение "пробросилось" до какого-то другого состояния дважды, двумя разными путями.<p>Таким образом, мы научились считать эти величины <img class=tex src="../tex2png/cache/9ef23f4e3d2645d9f049553d5dc6dd17.png" alt="cnt"> для всех состояний автомата.<p>После этого ответ на запрос тривиален &mdash; надо просто вернуть <img class=tex src="../tex2png/cache/ed13bc50ebc7783201c7a6f98046d3c6.png" alt="cnt[t]">, где <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> &mdash; состояние, соответствующее образцу <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">.<p><p><h3 style="padding-top:15px;"> Позиция первого вхождения </h3><p><b>Условие</b>. Дан текст <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">, и поступают запросы в виде: дана строка <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">, требуется узнать позицию начала первого вхождения строки <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">.<p><b>Асимптотика</b>. Препроцессинг <img class=tex src="../tex2png/cache/da281b72b98b5db07a434928aaaf1ffa.png" alt="O (length (T))"> и <img class=tex src="../tex2png/cache/dc93375de0ee7e4f3dbb8a5dae281c7a.png" alt="O (length (P))"> на один запрос.<p><b>Решение</b>. Построим суффиксный автомат по тексту <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">.<p>Для решения задачи нам также надо добавить в препроцессинг нахождение позиций <img class=tex src="../tex2png/cache/d53ca2bbfc14cb878d8af176a27b11d6.png" alt="firstpos"> для всех состояний автомата, т.е. для каждого состояния <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> мы хотим найти позицию <img class=tex src="../tex2png/cache/87e19d11d3176deebfa069f3077988c0.png" alt="firstpos[v]"> окончания первого вхождения. Иными словами, мы хотим найти заранее минимальный элемент каждого из множеств <img class=tex src="../tex2png/cache/e41366a8e15c9b8a33ade6e514a142e3.png" alt="endpos(v)"> (поскольку явно поддерживать все множества <img class=tex src="../tex2png/cache/07f3c3f43fe61663e7dc590160efdd65.png" alt="endpos"> мы не можем).<p><b>Поддерживать</b> эти позиции <img class=tex src="../tex2png/cache/d53ca2bbfc14cb878d8af176a27b11d6.png" alt="firstpos"> проще всего прямо по ходу построения автомата: когда мы создаём новое состояние <img class=tex src="../tex2png/cache/6663959c5800fe82135dd0d815744325.png" alt="cur"> при входе в функцию <img class=tex src="../tex2png/cache/ba52cd7e0a1bac49f682e663fe98d4b5.png" alt="sa\_extend()">, то выставляем ему:<p><p class=formula><img class=tex src="../tex2png/cache/7904ba835abbe6b6a38351d8e38d515b.png" alt=" firstpos(cur) = len(cur) - 1 "></p><p>(если мы работаем в <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0">-индексации).<p>При клонировании вершины <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> в <img class=tex src="../tex2png/cache/7cfdb07be62541cb4ad4893478f39697.png" alt="clone"> мы ставим:<p><p class=formula><img class=tex src="../tex2png/cache/205f9289b606ed1431f85a39cacb69f5.png" alt=" firstpos(clone) = firstpos(q), "></p><p>(поскольку другой вариант значения только один &mdash; это <img class=tex src="../tex2png/cache/feef26fc5419b9cb8972b7e702050973.png" alt="firstpos(cur)">, что явно больше).<p>Таким образом, ответ на запрос &mdash; это просто <img class=tex src="../tex2png/cache/401d17952eac4c0d2ef0fab0df6fbf61.png" alt="firstpos(t)-length(P)+1">, где <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> &mdash; состояние, соответствующее образцу <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">.<p><p><h3 style="padding-top:15px;"> Позиции всех вхождений </h3><p><b>Условие</b>. Дан текст <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">, и поступают запросы в виде: дана строка <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">, требуется вывести позиции всех её вхождений в строку <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T"> (вхождения могу перекрываться).<p><b>Асимптотика</b>. Препроцессинг <img class=tex src="../tex2png/cache/da281b72b98b5db07a434928aaaf1ffa.png" alt="O (length (T))">. Ответ на один запрос за <img class=tex src="../tex2png/cache/9a39cdb1c0dc75c7d86a3688fa387908.png" alt="O (length (P) + answer (P))">, где <img class=tex src="../tex2png/cache/9e1662d6b45735bc1026c7e737c5bd56.png" alt="answer(P)"> &mdash; это размер ответа, т.е. мы будем решать задачу за время порядка размера ввода и вывода.<p><b>Решение</b>. Построим суффиксный автомат по тексту <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">. Аналогично предыдущей задаче, посчитаем в процессе построения автомата для каждого состояния позицию <img class=tex src="../tex2png/cache/d53ca2bbfc14cb878d8af176a27b11d6.png" alt="firstpos"> окончания первого вхождения.<p>Пусть теперь поступил запрос &mdash; строка <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">. Найдём, какому состоянию <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> она соответствует.<p>Понятно, что <img class=tex src="../tex2png/cache/2b438bbe741a5c63efc3451376d7f816.png" alt="firstpos(t)"> точно должно входить в ответ. Какие ещё позиции надо найти? Мы учли состояние автомата, содержащее строку <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P">, однако не учли другие состояния, которым соответствуют такие строки, что <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> является их суффиксом.<p>Иными словами, нам требуется найти все состояния, из которых <b>достижимо по суффиксным ссылкам</b> состояние <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">.<p>Следовательно, для решения задачи нам потребуется сохранить для каждого состояния список суффиксных ссылок, ведущих в него. Ответ на запрос тогда будет заключаться в том, чтобы сделать <b>обход в глубину/в ширину</b> по этим инвертированным суффиксным ссылкам, начиная с состояния <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">.<p>Этот обход будет работать за время <img class=tex src="../tex2png/cache/7998142ab9a6cab279c9b6789abe5e65.png" alt="O (answer (P))">, поскольку мы не посетим одно и то же состояние дважды (потому что из каждого состояния суффиксная ссылка выходит только одна, поэтому не может быть двух путей, ведущих в одно и то же состояние).<p>Правда, надо учитывать, что у двух состояний их значения <img class=tex src="../tex2png/cache/d53ca2bbfc14cb878d8af176a27b11d6.png" alt="firstpos"> <b>могут совпадать</b>: если одно состояние было получено клонированием другого. Однако это не ухудшает асимптотику, поскольку у каждой не-клонированной вершины может быть максимум один клон.<p>Более того, можно легко избавиться от вывода повторяющихся позиций, если мы не будем добавлять в ответ <img class=tex src="../tex2png/cache/d53ca2bbfc14cb878d8af176a27b11d6.png" alt="firstpos"> от состояний-клонов. В самом деле, в любое состояние-клон ведёт суффиксная ссылка из того первоначального состояния, которое это состояние клонировало. Таким образом, если мы для каждого состояния запомним флаг <img class=tex src="../tex2png/cache/d4aa89c6d1a32823e53af54dc77ad688.png" alt="is\_clon">, и не будем добавлять в ответ <img class=tex src="../tex2png/cache/d53ca2bbfc14cb878d8af176a27b11d6.png" alt="firstpos"> от состояний, для которых <img class=tex src="../tex2png/cache/a09ce6b2013afe03f1f6fcd9202391e1.png" alt="is\_clon = true">, то мы тем самым получим все требуемые <img class=tex src="../tex2png/cache/829b73368ddd1e152dd7d1321ba2f6ff.png" alt="answer (P)"> позиций без повторов.<p>Приведём наброски реализации:<p><pre class="notranslate cpp"><span class="kw4">struct</span> state <span class="br0">&#123;</span>
	...
	<span class="kw4">bool</span> is_clon<span class="sy4">;</span>
	<span class="kw4">int</span> first_pos<span class="sy4">;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> inv_link<span class="sy4">;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
&nbsp;
&nbsp;
... после построения автомата ...
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> v<span class="sy1">&lt;</span>sz<span class="sy4">;</span> <span class="sy2">++</span>v<span class="br0">&#41;</span>
	st<span class="br0">&#91;</span>st<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">link</span><span class="br0">&#93;</span>.<span class="me1">inv_link</span>.<span class="me1">push_back</span> <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
...
&nbsp;
&nbsp;
<span class="co1">// ответ на запрос - вывод всех вхождений (возможно, с повторами)</span>
<span class="kw4">void</span> output_all_occurences <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> P_length<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span> st<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">is_clon</span><span class="br0">&#41;</span>
		<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> st<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">first_pos</span> <span class="sy2">-</span> P_length <span class="sy2">+</span> <span class="nu0">1</span> <span class="sy1">&lt;&lt;</span> endl<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>st<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">inv_link</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		output_all_occurences <span class="br0">&#40;</span>st<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">inv_link</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span>, P_length<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h3 style="padding-top:15px;"> Поиск кратчайшей строки, не входящей в данную </h3><p><b>Условие</b>. Дана строка <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">, и задан определённый алфавит. Требуется найти такую строку наименьшей длины, что она не встречается в <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S"> как подстрока.<p><b>Асимптотика</b>. Решение за <img class=tex src="../tex2png/cache/2d79b725d3bbfed29eaffc0d8760f2fc.png" alt="O (length (S))">.<p><b>Решение</b>. Решать будет динамическим программирование по автомату, построенному для строки <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">.<p>Пусть <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]"> &mdash; это ответ для вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, т.е. мы уже набрали часть подстроки, оказавшись в состоянии <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, и хотим найти наименьшее число символов, которое надо ещё добавить, чтобы выйти за пределы автомата, найдя несуществующий переход.<p>Считается <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]"> очень просто. Если из <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> нет перехода хотя бы по одному символу из алфавита, то <img class=tex src="../tex2png/cache/8cdc546f33bef7e94435bf3b239e13a4.png" alt="d[v] = 1">: мы можем приписать такой символ и выйти за пределы автомата, получив тем самым искомую строку.<p>В противном случае, одним символом обойтись не получится, поэтому надо взять минимум из ответов по всевозможным символам:<p><p class=formula><img class=tex src="../tex2png/cache/4df7c6c701d65d2a1ec73cc81887cb64.png" alt=" d[v] = 1 + \min_{w ~ : \atop (v,w,c) \in DAWG} d[[...]"></p><p>Ответ на задачу будет равен <img class=tex src="../tex2png/cache/257c5d8d5f467c689325abbc8659e2e8.png" alt="d[t_0]">, а саму строку можно восстановить, восстановив, каким образом в динамике получился этот минимум.<p><p><h3 style="padding-top:15px;"> Наидлиннейшая общая подстрока двух строк </h3><p><b>Условие</b>. Даны две строки <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S"> и <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">. Требуется найти их наидлиннейшую общую подстроку, т.е. такую строку <img class=tex src="../tex2png/cache/6c40947c41a939b41e0cfe6506c9e3c8.png" alt="X">, что она является подстрокой и <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">, и <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">.<p><b>Асимптотика</b>. Решение за <img class=tex src="../tex2png/cache/5fa8bc2b035e396301f72731893f1636.png" alt="O (length(S) + length(T))">.<p><b>Решение</b>. Построим суффиксный автомат по строке <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">.<p>Будем теперь идти по строке <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">, и для каждого префикса искать наидлиннейший суффикс этого префикса, встречающийся в <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">. Иными словами, мы для каждой позиции в строке <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T"> хотим найти наидлиннейшую общую подстроку <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S"> и <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">, заканчивающуюся именно в этой позиции.<p>Для этого будем поддерживать две переменные: <b>текущее состояние</b> <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> и <b>текущую длину</b> <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l">. Эти две переменные будут описывать текущую совпадающую часть: её длину и состояние, которое соответствует ей (без хранения длины нельзя обойтись, поскольку одному состоянию может соответствовать сразу несколько строк разной длины).<p>Изначально <img class=tex src="../tex2png/cache/3d352ccb2efdf1cefd1a5d58a9b9b4d7.png" alt="p=t_0">, <img class=tex src="../tex2png/cache/3a6470a4093c14285c95aa9d6092752d.png" alt="l=0">, т.е. совпадение пустое.<p>Пусть теперь мы рассматриваем символ <img class=tex src="../tex2png/cache/5ea9c71c996e6deb5974c0706a78c1b5.png" alt="T[i]"> и хотим пересчитать ответ для него.<p><ul><p><li>Если из состояния <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> в автомате есть переход по символу <img class=tex src="../tex2png/cache/5ea9c71c996e6deb5974c0706a78c1b5.png" alt="T[i]">, то мы просто совершаем этот переход и увеличиваем <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> на единицу.<p><li>Если же из состояния <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> нет требуемого перехода, то мы должны попытаться укоротить текущую совпадающую часть, для чего надо перейти по суффиксной ссылке:<p><p class=formula><img class=tex src="../tex2png/cache/76f5b5c4b592a5e82a7a6b8dc367bf36.png" alt=" v = link(v). "></p><p>При этом текущую длину надо укоротить, но оставить максимально возможной. Очевидно, для этого надо присвоить <img class=tex src="../tex2png/cache/853749ac3416fccb4adb0a9a67f44128.png" alt="l = len(v)">, поскольку после прохода по суффиксной ссылке нас удовлетворит подстрока любой длины, соответствующая этому состоянию:<p><p class=formula><img class=tex src="../tex2png/cache/bac8811d281b952a0ed41085769f0839.png" alt=" l = len(v). "></p><p>Если из нового состояния вновь не будет перехода по требуемому символу, то мы снова должны пройти по суффиксной ссылке и уменьшить <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l">, и так далее, пока не найдём переход (тогда перейдём к пункту 1) или мы не попадём в фиктивное состояние <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1"> (что означает, что символ <img class=tex src="../tex2png/cache/5ea9c71c996e6deb5974c0706a78c1b5.png" alt="T[i]"> вообще не встречается в <img class=tex src="../tex2png/cache/7af761eb0d1f3ce7b5a85ce3d8902662.png" alt="S">, поэтому присваиваем <img class=tex src="../tex2png/cache/e2778e047ee0a3671f1cd4abe7a28b99.png" alt="v=l=0"> и переходим к следующему <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">).<p></ul><p>Ответом на задачу будет максимум из значений <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> за всё время обхода.<p>Асимптотика такого прохода составляет <img class=tex src="../tex2png/cache/da281b72b98b5db07a434928aaaf1ffa.png" alt="O (length (T))">, поскольку за один ход мы можем либо увеличить на единицу <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l">, либо сделать несколько проходов по суффиксной ссылке, каждый из которых будет строго уменьшать значение <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l">. Следовательно, уменьшений не могло быть больше <img class=tex src="../tex2png/cache/b7f7a96c957d7e42439ddf2d94d83dea.png" alt="length (T)">, что и означает линейную асимптотику.<p>Реализация:<p><pre class="notranslate cpp">string lcs <span class="br0">&#40;</span>string s, string t<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	sa_init<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>s.<span class="me1">length</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		sa_extend <span class="br0">&#40;</span>s<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	<span class="kw4">int</span> v <span class="sy1">=</span> <span class="nu0">0</span>,  l <span class="sy1">=</span> <span class="nu0">0</span>,
		best <span class="sy1">=</span> <span class="nu0">0</span>,  bestpos <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>t.<span class="me1">length</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">while</span> <span class="br0">&#40;</span>v <span class="sy3">&amp;&amp;</span> <span class="sy3">!</span> st<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">next</span>.<span class="me1">count</span><span class="br0">&#40;</span>t<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			v <span class="sy1">=</span> st<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">link</span><span class="sy4">;</span>
			l <span class="sy1">=</span> st<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">length</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>st<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">next</span>.<span class="me1">count</span><span class="br0">&#40;</span>t<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			v <span class="sy1">=</span> st<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">next</span><span class="br0">&#91;</span>t<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="sy4">;</span>
			<span class="sy2">++</span>l<span class="sy4">;</span>
		<span class="br0">&#125;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">&gt;</span> best<span class="br0">&#41;</span>
			best <span class="sy1">=</span> l,  bestpos <span class="sy1">=</span> i<span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> t.<span class="me1">substr</span> <span class="br0">&#40;</span>bestpos<span class="sy2">-</span>best<span class="sy2">+</span><span class="nu0">1</span>, best<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h3 style="padding-top:15px;"> Наибольшая общая подстрока нескольких строк. </h3><p><b>Условие</b>. Даны <img class=tex src="../tex2png/cache/038649a055a585f6d85eab385e51429f.png" alt="K"> строк <img class=tex src="../tex2png/cache/7a58ee586c917a1b02226123e7191b83.png" alt="S_i">. Требуется найти их наидлиннейшую общую подстроку, т.е. такую строку <img class=tex src="../tex2png/cache/6c40947c41a939b41e0cfe6506c9e3c8.png" alt="X">, что она является подстрокой всех <img class=tex src="../tex2png/cache/7a58ee586c917a1b02226123e7191b83.png" alt="S_i">.<p><b>Асимптотика</b>. Решение за <img class=tex src="../tex2png/cache/af3a2c2e9ec546629141d76ca549c6c8.png" alt="O (\sum length(S_i) \cdot K)">.<p><b>Решение</b>. Склеим все строки <img class=tex src="../tex2png/cache/7a58ee586c917a1b02226123e7191b83.png" alt="S_i"> в одну строку <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T">, приписав после каждой строки <img class=tex src="../tex2png/cache/7a58ee586c917a1b02226123e7191b83.png" alt="S_i"> свой собственный символ-разделитель <img class=tex src="../tex2png/cache/0f460ae51630a0cfbb1c1342c058d069.png" alt="D_i"> (т.е. введя <img class=tex src="../tex2png/cache/038649a055a585f6d85eab385e51429f.png" alt="K"> дополнительных спец. символов <img class=tex src="../tex2png/cache/0f460ae51630a0cfbb1c1342c058d069.png" alt="D_i">):<p><p class=formula><img class=tex src="../tex2png/cache/9dc7df0d81606bd61a0d3c0a88d2fbd7.png" alt=" T = S_1 ~ D_1 ~ S_2 ~ D_2 ~ \ldots ~ S_k D_k. "></p><p>Построим для строки <img class=tex src="../tex2png/cache/0e738dc1c640233f2c460e261c522f78.png" alt="T"> суффиксный автомат.<p>Теперь нам требуется найти такую строку в автомате, которая содержится во всех строках <img class=tex src="../tex2png/cache/7a58ee586c917a1b02226123e7191b83.png" alt="S_i">, и в этом нам помогут добавленные спец. символы. Заметим, что если какая-либо подстрока входит в некоторую строку <img class=tex src="../tex2png/cache/7ff563f3dadb9f42292080790c54b324.png" alt="S_j">, то в суффиксном автомате из этой подстроки найдётся путь, содержащий символ <img class=tex src="../tex2png/cache/6d3bdc1bd4f06c8b74c133c9743bce36.png" alt="D_j">, и не содержащий остальных символов <img class=tex src="../tex2png/cache/17d59db6177f3ea8fb75807c8ee5b67c.png" alt="D_1, \ldots, D_{j-1}, D_{j+1}, \ldots, D_k">.<p>Таким образом, нам требуется посчитать достижимости: для каждого состояния автомата и каждого символа <img class=tex src="../tex2png/cache/0f460ae51630a0cfbb1c1342c058d069.png" alt="D_i"> есть ли путь, содержащий разделитель <img class=tex src="../tex2png/cache/0f460ae51630a0cfbb1c1342c058d069.png" alt="D_i">, и не содержащий других разделителей. Это легко сделать обходом в глубину/ширину или ленивой динамикой. После этого ответом на задачу будет строка <img class=tex src="../tex2png/cache/325ea4a4246ac97011c6c6594c474985.png" alt="longest(v)"> для состояния <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, из которого были найдены пути по всем символам.<p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Задачи, которые можно решить с помощью суффиксного автомата:<p><ul><p><li><a href="http://www.spoj.pl/problems/SUBLEX/">SPOJ #7258 SUBLEX <b>"Lexicographical Substring Search"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p></ul><p><p><p><p><p><p><h2 style="padding-top:40px;"> Литература </h2><p>Приведём сначала список первых работ, связанных с суффиксными автоматами:<p><ul><p><li>A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler, R. McConnell. <b>Linear Size Finite Automata for the Set of All Subwords of a Word. An Outline of Results</b> [1983]<p><li>A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler. <b>The Smallest Automaton Recognizing the Subwords of a Text</b> [1984]<p><li>Maxime Crochemore. <b>Optimal Factor Transducers</b> [1985]<p><li>Maxime Crochemore. <b>Transducers and Repetitions</b> [1986]<p><li>A. Nerode. <b>Linear automaton transformations</b> [1958]<p></ul><p>Помимо этого, в более современных источниках эта тема затрагивается во многих книгах по строковым алгоритмам:<p><ul><p><li>Maxime Crochemore, Wowjcieh Rytter. <b>Jewels of Stringology</b> [2002]<p><li>Bill Smyth. <b>Computing Patterns in Strings</b> [2003]<p><li>Билл Смит. <b>Методы и алгоритмы вычислений на строках</b> [2006]<p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>