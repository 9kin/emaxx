<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Дерево отрезков</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 11 Jun 2008 11:00<br>редактировано: 25 Oct 2011 21:31</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="segment_tree.html#" id="contents-hide">[скрыть]</a><a href="segment_tree.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Дерево отрезков</h1><p>Дерево отрезков &mdash; это структура данных, которая позволяет эффективно (т.е. за асимптотику <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">) реализовать операции следующего вида: нахождение суммы/минимума элементов массива в заданном отрезке (<img class=tex src="../tex2png/cache/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a[l \ldots r]">, где <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> и <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> поступают на вход алгоритма), при этом дополнительно возможно изменение элементов массива: как изменение значения одного элемента, так и изменение элементов на целом подотрезке массива (т.е. разрешается присвоить всем элементам <img class=tex src="../tex2png/cache/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a[l \ldots r]"> какое-либо значение, либо прибавить ко всем элементам массива какое-либо число).<p>Вообще, дерево отрезков &mdash; очень гибкая структура, и число задач, решаемых ей, теоретически неограниченно. Помимо приведённых выше видов операций с деревьями отрезков, также возможны и гораздо более сложные операции (см. раздел "Усложнённые версии дерева отрезков"). В частности, дерево отрезков легко обобщается на большие размерности: например, для решения задачи о поиске суммы/минимума в некотором подпрямоугольнике данной матрицы (правда, уже только за время <img class=tex src="../tex2png/cache/5f31d6f46e03579a1025f178e6d85150.png" alt="O (\log^2 n)">).<p>Важной особенностью деревьев отрезков является то, что они потребляют линейный объём памяти: стандартному дереву отрезков требуется порядка <img class=tex src="../tex2png/cache/3425c224e2cf3a567f27c33d26d4e256.png" alt="4n"> элементов памяти для работы над массивом размера <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">.<p><p><h2 style="padding-top:40px;">Описание дерева отрезков в базовом варианте</h2><p>Для начала рассмотрим простейший случай дерева отрезков &mdash; дерево отрезков для сумм. Если ставить задачу формально, то у нас есть массив <img class=tex src="../tex2png/cache/61e687505738756a5a0a875e68fef95c.png" alt="a[0..n-1]">, и наше дерево отрезков должно уметь находить сумму элементов с <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l">-го по <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">-ый (это запрос суммы), а также обрабатывать изменение значения одного указанного элемента массива, т.е. фактически реагировать на присвоение <img class=tex src="../tex2png/cache/20a786def4744c0a6d30e1718c6d970c.png" alt="a[i]=x"> (это запрос модификации). Ещё раз повторимся, дерево отрезков должно обрабатывать оба этих запроса за время <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">.<p><p><h3 style="padding-top:15px;">Структура дерева отрезков</h3><p>Итак, что же представляет из себя дерево отрезков?<p>Подсчитаем и запомним где-нибудь сумму элементов всего массива, т.е. отрезка <img class=tex src="../tex2png/cache/2f7c3ec9c849a4dcbfc3195989056b93.png" alt="a[0 \ldots n-1]">. Также посчитаем сумму на двух половинках этого массива: <img class=tex src="../tex2png/cache/956cf050b80daaa13a7143f3acb10f4e.png" alt="a[0 \ldots n/2]"> и <img class=tex src="../tex2png/cache/1edf1b374780b75661e2628028abec7d.png" alt="a[n/2+1 \ldots n-1]">. Каждую из этих двух половинок в свою очередь разобьём пополам, посчитаем и сохраним сумму на них, потом снова разобьём пополам, и так далее, пока текущий отрезок не достигнет длины <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1">. Иными словами, мы стартуем с отрезка <img class=tex src="../tex2png/cache/16dc8025ca4b7286177f4afcbe0543b5.png" alt="[0;n-1]"> и каждый раз делим текущий отрезок надвое (если он ещё не стал отрезком единичной длины), вызывая затем эту же процедуру от обеих половинок; для каждого такого отрезка мы храним сумму чисел на нём.<p>Можно говорить, что эти отрезки, на которых мы считали сумму, образуют дерево: корень этого дерева &mdash; отрезок <img class=tex src="../tex2png/cache/ecff96120a9209d01863bd81ef70ba4b.png" alt="[0 \ldots n-1]">, а каждая вершина имеет ровно двух сыновей (кроме вершин-листьев, у которых отрезок имеет длину <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1">). Отсюда и происходит название &mdash; "дерево отрезков" (хотя при реализации обычно никакого дерева явно не строится, но об этом ниже в разделе реализации).<p>Итак, мы описали структуру дерева отрезков. Сразу заметим, что оно имеет <b>линейный размер</b>, а именно, содержит менее <img class=tex src="../tex2png/cache/02f3339bd527ea60f4b8a5fcb94023f1.png" alt="2n"> вершин. Понять это можно следующим образом: первый уровень дерева отрезков содержит одну вершину (отрезок <img class=tex src="../tex2png/cache/ecff96120a9209d01863bd81ef70ba4b.png" alt="[0 \ldots n-1]">), второй уровень &mdash; в худшем случае две вершины, на третьем уровне в худшем случае будет четыре вершины, и так далее, пока число вершин не достигнет <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Таким образом, число вершин в худшем случае оценивается суммой <img class=tex src="../tex2png/cache/d35b3d070df776c04c090026321e7a7a.png" alt="n + n/2 + n/4 + n/8 + \ldots + 1 < 2n">.<p>Стоит отметить, что при <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, отличных от степеней двойки, не все уровни дерева отрезков будут полностью заполнены. Например, при <img class=tex src="../tex2png/cache/bcda88883794933f7b1fcfe9f0ddaa2d.png" alt="n=3"> левый сын корня есть отрезок <img class=tex src="../tex2png/cache/5303948ccba946cdef40e33f43cdda9e.png" alt="[0 \ldots 1]">, имеющий двух потомков, в то время как правый сын корня &mdash; отрезок <img class=tex src="../tex2png/cache/dba180d54564a30ed5dfccdcacf84606.png" alt="[2 \ldots 2]">, являющийся листом. Никаких особых сложностей при реализации это не составляет, но тем не менее это надо иметь в виду.<p><b>Высота</b> дерева отрезков есть величина <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> &mdash; например, потому что длина отрезка в корне дерева равна <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, а при переходе на один уровень вниз длина отрезков уменьшается примерно вдвое.<p><p><h3 style="padding-top:15px;">Построение</h3><p>Процесс построения дерева отрезков по заданному массиву <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> можно делать эффективно следующим образом, снизу вверх: сначала запишем значения элементов <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]"> в соответствующие листья дерева, затем на основе них посчитаем значения для вершин предыдущего уровня как сумму значений в двух листьях, затем аналогичным образом посчитаем значения для ещё одного уровня, и т.д. Удобно описывать эту операцию рекурсивно: мы запускаем процедуру построения от корня дерева отрезков, а сама процедура построения, если её вызвали не от листа, вызывает себя от каждого из двух сыновей и суммирует вычисленные значения, а если её вызвали от листа &mdash; то просто записывает в себя значение этого элемента массива.<p>Асимптотика построения дерева отрезков составит, таким образом, <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">.<p><p><h3 style="padding-top:15px;">Запрос суммы</h3><p>Рассмотрим теперь запрос суммы. На вход поступают два числа <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> и <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">, и мы должны за время <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> посчитать сумму чисел на отрезке <img class=tex src="../tex2png/cache/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a[l \ldots r]">.<p>Для этого мы будем спускаться по построенному дереву отрезков, используя для подсчёта ответа посчитанные ранее суммы на каждой вершине дерева. Изначально мы встаём в корень дерева отрезков. Посмотрим, в какие из двух его сыновей попадает отрезок запроса <img class=tex src="../tex2png/cache/653023af1da32cf3f51fe321fa0778da.png" alt="[l \ldots r]"> (напомним, что сыновья корня дерева отрезков &mdash; это отрезки <img class=tex src="../tex2png/cache/6e1128658239f9f68b765b0e3a3d1a6a.png" alt="[0 \ldots n/2]"> и <img class=tex src="../tex2png/cache/286bab85398b9a2f7b1db9777b827da8.png" alt="[n/2+1 \ldots n-1]">). Возможны два варианта: что отрезок <img class=tex src="../tex2png/cache/653023af1da32cf3f51fe321fa0778da.png" alt="[l \ldots r]"> попадает только в одного сына корня, и что, наоборот, отрезок пересекается с обоими сыновьями.<p>Первый случай прост: просто перейдём в того сына, в котором лежит наш отрезок-запрос, и применим описываемый здесь алгоритм к текущей вершине.<p>Во втором же случае нам не остаётся других вариантов, кроме как перейти сначала в левого сына и посчитать ответ на запрос в нём, а затем &mdash; перейти в правого сына, посчитать в нём ответ и прибавить к нашему ответу. Иными словами, если левый сын представлял отрезок <img class=tex src="../tex2png/cache/e23c36b14689e5d2b805681a2bc9d9fe.png" alt="[l_1 \ldots r_1]">, а правый &mdash; отрезок <img class=tex src="../tex2png/cache/192b10a94c69a38d31863be3b0aa178a.png" alt="[l_2 \ldots r_2]"> (заметим, что <img class=tex src="../tex2png/cache/f4ff8bd23d311e004e920ae4a02de42c.png" alt="l_2 = r_1 + 1">), то мы перейдём в левого сына с запросом <img class=tex src="../tex2png/cache/79631314998919abe7a50cc5546efdc7.png" alt="[l \ldots r_1]">, а в правого &mdash; с запросом <img class=tex src="../tex2png/cache/b6985a36468a0de79c5847d25c3aed69.png" alt="[l_2 \ldots r]">.<p>Итак, обработка запроса суммы представляет собой <b>рекурсивную функцию</b>, которая всякий раз вызывает себя либо от левого сына, либо от правого (не изменяя границы запроса в обоих случаях), либо от обоих сразу (при этом деля наш запрос на два соответствующих подзапроса). Однако рекурсивные вызовы будем делать не всегда: если текущий запрос совпал с границами отрезка в текущей вершине дерева отрезков, то в качестве ответа будем возвращать предвычисленное значение суммы на этом отрезке, записанное в дереве отрезков.<p>Иными словами, вычисление запроса представляет собой спуск по дереву отрезков, который распространяется по всем нужным ветвям дерева, и для быстрой работы использующий уже посчитанные суммы по каждому отрезку в дереве отрезков.<p>Почему же <b>асимптотика</b> этого алгоритма будет <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">? Для этого посмотрим на каждом уровне дерева отрезков, сколько максимум отрезков могла посетить наша рекурсивная функция при обработке какого-либо запроса. Утверждается, что таких отрезков не могло быть более четырёх; тогда, учитывая оценку <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> для высоты дерева, мы и получаем нужную асимптотику времени работы алгоритма.<p>Покажем, что эта оценка о четырёх отрезках верна. В самом деле, на нулевом уровне дерева запросом затрагивается единственная вершина &mdash; корень дерева. Дальше на первом уровне рекурсивный вызов в худшем случае разбивается на два рекурсивных вызова, но важно здесь то, что запросы в этих двух вызовах будут соседствовать, т.е. число <img class=tex src="../tex2png/cache/b8eb666582c568931fab689087c4420f.png" alt="l^{\prime\prime}"> запроса во втором рекурсивном вызове будет на единицу больше числа <img class=tex src="../tex2png/cache/78314c9c457a2b2226b69c669bca9805.png" alt="r^\prime"> запроса в первом рекурсивном вызове. Отсюда следует, что на следующем уровне каждый из этих двух вызовов мог породить ещё по два рекурсивных вызова, но в таком случае половина этих запросов отработает нерекурсивно, взяв нужное значение из вершины дерева отрезков. Таким образом, всякий раз у нас будет не более двух реально работающих ветвей рекурсии (можно сказать, что одна ветвь приближается к левой границе запроса, а вторая ветвь &mdash; к правой), а всего число затронутых отрезков не могло превысить высоты дерева отрезков, умноженной на четыре, т.е. оно есть число <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">.<p>В завершение можно привести и такое понимание работы запроса суммы: входной отрезок <img class=tex src="../tex2png/cache/653023af1da32cf3f51fe321fa0778da.png" alt="[l \ldots r]"> разбивается на несколько подотрезков, ответ на каждом из которых уже подсчитан и сохранён в дереве. Если делать это разбиение правильным образом, то благодаря структуре дерева отрезков число необходимых подотрезков всегда будет <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">, что и даёт эффективность работы дерева отрезков.<p><p><h3 style="padding-top:15px;">Запрос обновления</h3><p>Напомним, что запрос обновления получает на вход индекс <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и значение <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">, и перестраивает дерево отрезков таким образом, чтобы оно соответствовало новому значению <img class=tex src="../tex2png/cache/20a786def4744c0a6d30e1718c6d970c.png" alt="a[i]=x">. Этот запрос должен также выполняться за время <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">.<p>Это более простой запрос по сравнению с запросом подсчёта суммы. Дело в том, что элемент <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]"> участвует только в относительно небольшом числе вершин дерева отрезков: а именно, в <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> вершинах &mdash; по одной с каждого уровня.<p>Тогда понятно, что запрос обновления можно реализовать как рекурсивную функцию: ей передаётся текущая вершина дерева отрезков, и эта функция выполняет рекурсивный вызов от одного из двух своих сыновей (от того, который содержит позицию <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> в своём отрезке), а после этого &mdash; пересчитывает значение суммы в текущей вершине точно таким же образом, как мы это делали при построении дерева отрезков (т.е. как сумма значений по обоим сыновьям текущей вершины).<p><p><h3 style="padding-top:15px;">Реализация</h3><p>Основной реализационный момент &mdash; это то, как <b>хранить</b> дерево отрезков в памяти. В целях простоты мы не будем хранить дерево в явном виде, а воспользуемся таким трюком: скажем, что корень дерева имеет номер <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1">, его сыновья &mdash; номера <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2"> и <img class=tex src="../tex2png/cache/0e96f2a3dff7da2f31d78c5306207a14.png" alt="3">, их сыновья &mdash; номера с <img class=tex src="../tex2png/cache/540ccd7efd169a4313503b565bb0ce55.png" alt="4"> по <img class=tex src="../tex2png/cache/5c705587512261d7061e23ba54f595f3.png" alt="7">, и так далее. Легко понять корректность следующей формулы: если вершина имеет номер <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, то пусть её левый сын &mdash; это вершина с номером <img class=tex src="../tex2png/cache/59208d781cf256429eabcdaf6a812a0f.png" alt="2i">, а правый &mdash; с номером <img class=tex src="../tex2png/cache/5bfad4c5b8e0ccbdeacca62dc6e71531.png" alt="2i+1">.<p>Такой приём значительно упрощает программирование дерева отрезков, &mdash; теперь нам не нужно хранить в памяти структуру дерева отрезков, а только лишь завести какой-либо массив для сумм на каждом отрезке дерева отрезков.<p>Стоит только отметить, что размер этого массива при такой нумерации надо ставить не <img class=tex src="../tex2png/cache/02f3339bd527ea60f4b8a5fcb94023f1.png" alt="2n">, а <img class=tex src="../tex2png/cache/3425c224e2cf3a567f27c33d26d4e256.png" alt="4n">. Дело в том, что такая нумерация не идеально работает в случае, когда <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> не является степенью двойки &mdash; тогда появляются пропущенные номера, которым не соответствуют никакие вершины дерева (фактически, нумерация ведёт себя подобно тому, как если бы <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> округлили бы вверх до ближайшей степени двойки). Это не создаёт никаких сложностей при реализации, однако приводит к тому, что размер массива надо увеличивать до <img class=tex src="../tex2png/cache/3425c224e2cf3a567f27c33d26d4e256.png" alt="4n">.<p>Итак, дерево отрезков мы <b>храним</b> просто в виде массива <img class=tex src="../tex2png/cache/ef81dd9a1c266209451a0f924cf42f69.png" alt="t[]">, размера вчетверо больше размера <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> входных данных:<p><pre class="notranslate cpp"><span class="kw4">int</span> n, t<span class="br0">&#91;</span><span class="nu0">4</span><span class="sy2">*</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span></pre><p>Процедура <b>построения дерева отрезков</b> по заданному массиву <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]"> выглядит следующим образом: это рекурсивная функция, ей передаётся сам массив <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]">, номер <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> текущей вершины дерева, и границы <img class=tex src="../tex2png/cache/5ae6342347ce16806929411d1b038186.png" alt="tl"> и <img class=tex src="../tex2png/cache/228f216330bd322361137b12344e6ec5.png" alt="tr"> отрезка, соответствующего текущей вершине дерева. Из основной программы вызывать эту функцию следует с параметрами <img class=tex src="../tex2png/cache/3503963bbad8d7409534664fa753ebe5.png" alt="v=1">, <img class=tex src="../tex2png/cache/7c1d976ea14775e1e40a39f002657d59.png" alt="tl=0">, <img class=tex src="../tex2png/cache/c95d88cd10b654cc16ca3eeedb327f64.png" alt="tr=n-1">.<p><pre class="notranslate cpp"><span class="kw4">void</span> build <span class="br0">&#40;</span><span class="kw4">int</span> a<span class="br0">&#91;</span><span class="br0">&#93;</span>, <span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="br0">&#91;</span>tl<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build <span class="br0">&#40;</span>a, v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span><span class="br0">&#41;</span><span class="sy4">;</span>
		build <span class="br0">&#40;</span>a, v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr<span class="br0">&#41;</span><span class="sy4">;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy2">+</span> t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Далее, функция для <b>запроса суммы</b> представляет из себя также рекурсивную функцию, которой таким же образом передаётся информация о текущей вершине дерева (т.е. числа <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, <img class=tex src="../tex2png/cache/5ae6342347ce16806929411d1b038186.png" alt="tl">, <img class=tex src="../tex2png/cache/228f216330bd322361137b12344e6ec5.png" alt="tr">, которым в основной программе следует передавать значения <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1">, <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0">, <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> соответственно), а помимо этого &mdash; также границы <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> и <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> текущего запроса. В целях упрощения кода эта фукнция всегда делает по два рекурсивных вызова, даже если на самом деле нужен один &mdash; просто лишнему рекурсивному вызову передастся запрос, у которого <img class=tex src="../tex2png/cache/f923f209dbbbf1e2adcce5d2eb545ef1.png" alt="l > r">, что легко отсекается дополнительной проверкой в самом начале функции.<p><pre class="notranslate cpp"><span class="kw4">int</span> sum <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">&gt;</span> r<span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> r <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		<span class="kw1">return</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> sum <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, min<span class="br0">&#40;</span>r,<span class="kw4">tm</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
		<span class="sy2">+</span> sum <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, max<span class="br0">&#40;</span>l,<span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span>, r<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Наконец, <b>запрос модификации</b>. Ему точно так же передаётся информация о текущей вершине дерева отрезков, а дополнительно указывается индекс меняющегося элемента, а также его новое значение.<p><pre class="notranslate cpp"><span class="kw4">void</span> update <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos, <span class="kw4">int</span> new_val<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> new_val<span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">&#41;</span>
			update <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, pos, new_val<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			update <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos, new_val<span class="br0">&#41;</span><span class="sy4">;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy2">+</span> t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Стоит отметить, что функцию <img class=tex src="../tex2png/cache/77d78f9a8de6ca2b7cee5167b9d428b6.png" alt="\rm update"> легко сделать нерекурсивной, поскольку рекурсия в ней хвостовая, т.е. разветвлений никогда не происходит: один вызов может породить только один рекурсивный вызов. При нерекурсивной реализации скорость работы может вырасти в несколько раз.<p>Из других <b>оптимизаций</b> стоит упомянуть, что умножения и деления на два стоит заменить битовыми операциями &mdash; это также немного улучшает производительность дерева отрезков.<p><p><h2 style="padding-top:40px;">Усложнённые версии дерева отрезков</h2><p>Дерево отрезков &mdash; очень гибкая структура, и позволяет делать обобщения во многих различных направлениях. Попытаемся ниже классифицировать их.<p><p><h3 style="padding-top:15px;">Более сложные функции и запросы</h3><p>Улучшения дерева отрезков в этом направлении могут быть как довольно очевидными (как в случае минимума/максимума вместо суммы), так и весьма и весьма нетривиальными.<p><h4>Поиск минимума/максимума</h4><p>Немного изменим условие задачи, описанной выше: вместо запроса суммы будем производить теперь запрос минимума/максимума на отрезке.<p>Тогда дерево отрезков для такой задачи практически ничем не отличается от дерева отрезков, описанного выше. Просто надо изменить способ вычисления <img class=tex src="../tex2png/cache/984b49d9311673e2bd809524d195f995.png" alt="t[v]"> в функциях <img class=tex src="../tex2png/cache/de937760ef15f987c930d6f7eb8ef330.png" alt="\rm build"> и <img class=tex src="../tex2png/cache/77d78f9a8de6ca2b7cee5167b9d428b6.png" alt="\rm update">, а также вычисление возвращаемого ответа в функции <img class=tex src="../tex2png/cache/93bc2a33a44683e63c7f8118b9c2ced4.png" alt="\rm sum"> (заменить суммирование на минимум/максимум).<p><h4>Поиск минимума/максимума и количества раз, которое он встречается</h4><p>Задача аналогична предыдущей, только теперь помимо максимума требуется также возвращать количество его вхождений. Эта задача встаёт естественным образом, например, при решении с помощью дерева отрезков такой задачи: найти количество наидлиннейших возрастающих подпоследовательностей в заданном массиве.<p>Для решения этой задачи в каждой вершине дерева отрезков будем хранить пару чисел: кроме максимума количество его вхождений на соответствующем отрезке. Тогда при построении дерева мы должны просто по двум таким парам, полученным от сыновей текущей вершины, получать пару для текущей вершины.<p>Объединение двух таких пар в одну стоит выделить в отдельную функцию, поскольку эту операцию надо будет производить и в запросе модификации, и в запросе поиска максимума.<p><pre class="notranslate cpp">pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> t<span class="br0">&#91;</span><span class="nu0">4</span><span class="sy2">*</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> combine <span class="br0">&#40;</span>pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> a, pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>a.<span class="me1">first</span> <span class="sy1">&gt;</span> b.<span class="me1">first</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> a<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>b.<span class="me1">first</span> <span class="sy1">&gt;</span> a.<span class="me1">first</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> b<span class="sy4">;</span>
	<span class="kw1">return</span> make_pair <span class="br0">&#40;</span>a.<span class="me1">first</span>, a.<span class="me1">second</span> <span class="sy2">+</span> b.<span class="me1">second</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> build <span class="br0">&#40;</span><span class="kw4">int</span> a<span class="br0">&#91;</span><span class="br0">&#93;</span>, <span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> make_pair <span class="br0">&#40;</span>a<span class="br0">&#91;</span>tl<span class="br0">&#93;</span>, <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build <span class="br0">&#40;</span>a, v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span><span class="br0">&#41;</span><span class="sy4">;</span>
		build <span class="br0">&#40;</span>a, v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr<span class="br0">&#41;</span><span class="sy4">;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> combine <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span>, t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> get_max <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">&gt;</span> r<span class="br0">&#41;</span>
		<span class="kw1">return</span> make_pair <span class="br0">&#40;</span><span class="sy2">-</span>INF, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> r <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		<span class="kw1">return</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> combine <span class="br0">&#40;</span>
		get_max <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, min<span class="br0">&#40;</span>r,<span class="kw4">tm</span><span class="br0">&#41;</span><span class="br0">&#41;</span>,
		get_max <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, max<span class="br0">&#40;</span>l,<span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span>, r<span class="br0">&#41;</span>
	<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> update <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos, <span class="kw4">int</span> new_val<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> make_pair <span class="br0">&#40;</span>new_val, <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">&#41;</span>
			update <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, pos, new_val<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			update <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos, new_val<span class="br0">&#41;</span><span class="sy4">;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> combine <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span>, t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p><h4>Поиск наибольшего общего делителя / наименьшего общего кратного</h4><p>Т.е. мы хотим научиться искать НОД/НОК всех чисел в заданном отрезке массива.<p>Это довольно интересное обобщение дерева отрезков получается абсолютно таким же путём, как и деревья отрезков для суммы/минимума/максимума: достаточно просто хранить в каждой вершине дерева НОД/НОК всех чисел в соответствующем отрезке массива.<p><h4>Подсчёт количества нулей, поиск <img class=tex src="../tex2png/cache/336a051837a2ed662422914225a362d0.png" alt="k">-го нуля</h4><p>В этой задаче мы хотим научиться отвечать на запрос количества нулей в заданном отрезке массива, а также на запрос нахождения <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-го нулевого элемента.<p>Снова немного изменим данные, хранящиеся в дереве отрезков: будем хранить теперь в массиве <img class=tex src="../tex2png/cache/ef81dd9a1c266209451a0f924cf42f69.png" alt="t[]"> количество нулей, встречающихся в соответствующих отрезках массива. Понятно, как поддерживать и использовать эти данные в функциях <img class=tex src="../tex2png/cache/de937760ef15f987c930d6f7eb8ef330.png" alt="\rm build">, <img class=tex src="../tex2png/cache/93bc2a33a44683e63c7f8118b9c2ced4.png" alt="\rm sum">, <img class=tex src="../tex2png/cache/77d78f9a8de6ca2b7cee5167b9d428b6.png" alt="\rm update">, &mdash; тем самым мы решили задачу о количестве нулей в заданном отрезке массива.<p>Теперь научимся решать задачу о поиске позиции <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-го вхождения нуля в массиве. Для этого будем спускаться по дереву отрезков, начиная с корня, и переходя каждый раз в левого или правого сына в зависимости от того, в каком из отрезков находится искомый <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ый ноль. В самом деле, чтобы понять, в какого сына нам надо переходить, достаточно посмотреть на значение, записанное в левом сыне: если оно больше либо равно <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, то переходить надо в левого сына (потому что в его отрезке есть как минимум <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> нулей), а иначе &mdash; переходить в правого сына.<p>При реализации можно отсечь случай, когда <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-го нуля не существует, ещё при входе в функцию, вернув в качестве ответа, например, <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1">.<p><pre class="notranslate cpp"><span class="kw4">int</span> find_kth <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> k<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>k <span class="sy1">&gt;</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		<span class="kw1">return</span> tl<span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy1">&gt;=</span> k<span class="br0">&#41;</span>
		<span class="kw1">return</span> find_kth <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, k<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">else</span>
		<span class="kw1">return</span> find_kth <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, k <span class="sy2">-</span> t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><h4>Поиск префикса массива с заданной суммой</h4><p>Задача такая: требуется по данному значению <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> быстро найти такое <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, что сумма первых <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> элементов массива <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]"> больше либо равна <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> (считая, что массив <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]"> содержит только неотрицательные числа).<p>Эту задачу можно решать бинарным поиском, вычисляя каждый раз внутри него сумму на том или ином префиксе массива, но это приведёт к решению за время <img class=tex src="../tex2png/cache/5f31d6f46e03579a1025f178e6d85150.png" alt="O (\log^2 n)">.<p>Вместо этого можно воспользоваться той же самой идеей, что и в предыдущем пункте, и искать искомую позицию одним спуском по дереву: переходя каждый раз в левого или правого сына в зависимости от величины суммы в левом сыне. Тогда ответ на запрос поиска будет представлять собой один такой спуск по дереву, а, следовательно, будет выполняться за <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">.<p><h4>Поиск подотрезка с максимальной суммой</h4><p>По-прежнему на вход даётся массив <img class=tex src="../tex2png/cache/2f7c3ec9c849a4dcbfc3195989056b93.png" alt="a[0 \ldots n-1]">, и поступают запросы <img class=tex src="../tex2png/cache/5da5090de09ee020bba6974c7d377e42.png" alt="(l,r)">, которые означают: найти такой подотрезок <img class=tex src="../tex2png/cache/faa9743f8b52e0bf987f66f0f3748822.png" alt="a[l^\prime \ldots r^\prime]">, что <img class=tex src="../tex2png/cache/90c5d4529cb50b2ef4b5730893a2db01.png" alt="l \le l^\prime">, <img class=tex src="../tex2png/cache/7d217c79dc2e25e44c5719338e91b173.png" alt="r^\prime \le r">, и сумма этого отрезка <img class=tex src="../tex2png/cache/faa9743f8b52e0bf987f66f0f3748822.png" alt="a[l^\prime \ldots r^\prime]"> максимальна. Запросы модификации отдельных элементов массива допускаются. Элементы массива могут быть отрицательными (и, например, если все числа отрицательны, то оптимальным подотрезком будет пустой &mdash; на нём сумма равна нулю).<p>Это весьма нетривиальное обобщение дерева отрезков получается следующим образом. Будем хранить в каждой вершине дерева отрезков четыре величины: сумму на этом отрезке, максимальную сумму среди всех префиксов этого отрезка, максимальную сумму среди всех суффиксов, а также максимальную сумму подотрезка на нём. Иными словами, для каждого отрезка дерева отрезков ответ на нём уже предпосчитан, а также дополнительно ответ посчитан среди всех отрезков, упирающихся в левую границу отрезка, а также среди всех отрезков, упирающихся в правую границу.<p>Как же построить дерево отрезков с такими данными? Снова подойдём к этому с рекурсивной точки зрения: пусть для текущей вершины все четыре значения в левом сыне и в правом сыне уже подсчитаны, посчитаем их теперь для самой вершины. Заметим, что ответ в самой вершине равен:<p><ul><li>либо ответу в левом сыне, что означает, что лучший подотрезок в текущей вершине целиком помещается в отрезок левого сына,<li>либо ответу в правом сыне, что означает, что лучший подотрезок в текущей вершине целиком помещается в отрезок правого сына,<li>либо сумме максимального суффикса в левом сыне и максимального префикса в правом сыне, что означает, что лучший подотрезок лежит своим началом в левом сыне, а концом &mdash; в правом.</ul><p>Значит, ответ в текущей вершине равен максимуму из этих трёх величин. Пересчитывать же максимальную сумму на префиксах и суффиксах ещё проще. Приведём реализацию функции <img class=tex src="../tex2png/cache/8acda8e6df059bc22646e01009cd6546.png" alt="\rm combine">, которой будут передаваться две структуры <img class=tex src="../tex2png/cache/9830bd111d20d5d83caa873af1cecd6c.png" alt="\rm data">, содержащие в себе данные о левом и правом сыновьях, и которая возвращает данные в текущей вершине.<p><pre class="notranslate cpp"><span class="kw4">struct</span> data <span class="br0">&#123;</span>
	<span class="kw4">int</span> sum, pref, suff, ans<span class="sy4">;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
&nbsp;
data combine <span class="br0">&#40;</span>data l, data r<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	data res<span class="sy4">;</span>
	res.<span class="me1">sum</span> <span class="sy1">=</span> l.<span class="me1">sum</span> <span class="sy2">+</span> r.<span class="me1">sum</span><span class="sy4">;</span>
	res.<span class="me1">pref</span> <span class="sy1">=</span> max <span class="br0">&#40;</span>l.<span class="me1">pref</span>, l.<span class="me1">sum</span> <span class="sy2">+</span> r.<span class="me1">pref</span><span class="br0">&#41;</span><span class="sy4">;</span>
	res.<span class="me1">suff</span> <span class="sy1">=</span> max <span class="br0">&#40;</span>r.<span class="me1">suff</span>, r.<span class="me1">sum</span> <span class="sy2">+</span> l.<span class="me1">suff</span><span class="br0">&#41;</span><span class="sy4">;</span>
	res.<span class="me1">ans</span> <span class="sy1">=</span> max <span class="br0">&#40;</span>max <span class="br0">&#40;</span>l.<span class="me1">ans</span>, r.<span class="me1">ans</span><span class="br0">&#41;</span>, l.<span class="me1">suff</span> <span class="sy2">+</span> r.<span class="me1">pref</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">return</span> res<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Таким образом, мы научились строить дерево отрезков. Отсюда легко получить и реализацию запроса модификации: как и в самом простом дереве отрезков, мы выполняем пересчёт значений во всех изменившихся вершинах дерева отрезков, для чего используем всё ту же функцию <img class=tex src="../tex2png/cache/8acda8e6df059bc22646e01009cd6546.png" alt="\rm combine">. Для вычисления значений дерева в листьях также вспомогательную функцию <img class=tex src="../tex2png/cache/625800dc6e651d2b6823a01fe11ad93d.png" alt="\rm make\_data">, которая возвращает структуру <img class=tex src="../tex2png/cache/9830bd111d20d5d83caa873af1cecd6c.png" alt="\rm data">, вычисленную по одному числу <img class=tex src="../tex2png/cache/bb7de26cb5f36ac3575b89190db5c8c0.png" alt="\rm val">.<p><pre class="notranslate cpp">data make_data <span class="br0">&#40;</span><span class="kw4">int</span> val<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	data res<span class="sy4">;</span>
	res.<span class="me1">sum</span> <span class="sy1">=</span> val<span class="sy4">;</span>
	res.<span class="me1">pref</span> <span class="sy1">=</span> res.<span class="me1">suff</span> <span class="sy1">=</span> res.<span class="me1">ans</span> <span class="sy1">=</span> max <span class="br0">&#40;</span><span class="nu0">0</span>, val<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">return</span> res<span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> build <span class="br0">&#40;</span><span class="kw4">int</span> a<span class="br0">&#91;</span><span class="br0">&#93;</span>, <span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> make_data <span class="br0">&#40;</span>a<span class="br0">&#91;</span>tl<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build <span class="br0">&#40;</span>a, v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span><span class="br0">&#41;</span><span class="sy4">;</span>
		build <span class="br0">&#40;</span>a, v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr<span class="br0">&#41;</span><span class="sy4">;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> combine <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span>, t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> update <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos, <span class="kw4">int</span> new_val<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> make_data <span class="br0">&#40;</span>new_val<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">&#41;</span>
			update <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, pos, new_val<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			update <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos, new_val<span class="br0">&#41;</span><span class="sy4">;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> combine <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span>, t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Осталось разобраться с ответом на запрос. Для этого мы так же, как и раньше, спускаемся по дереву, разбивая тем самым отрезок запроса <img class=tex src="../tex2png/cache/653023af1da32cf3f51fe321fa0778da.png" alt="[l \ldots r]"> на несколько подотрезков, совпадающих с отрезками дерева отрезков, и объединяем ответы в них в единый ответ на всю задачу. Тогда понятно, что работа ничем не отличается от работы обычного дерева отрезков, только надо вместо простого суммирования/минимума/максимума значений использовать функцию <img class=tex src="../tex2png/cache/8acda8e6df059bc22646e01009cd6546.png" alt="\rm combine">. Приведённая ниже реализация немного отличается от реализации запроса <img class=tex src="../tex2png/cache/93bc2a33a44683e63c7f8118b9c2ced4.png" alt="\rm sum">: она не допускает случаев, когда левая граница <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> запроса превышает правую границу <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> (иначе возникнут неприятные случаи &mdash; какую структуру <img class=tex src="../tex2png/cache/9830bd111d20d5d83caa873af1cecd6c.png" alt="\rm data"> возврашать, когда отрезок запроса пустой?..).<p><pre class="notranslate cpp">data query <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> tr <span class="sy1">==</span> r<span class="br0">&#41;</span>
		<span class="kw1">return</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>r <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> query <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, r<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">&gt;</span> <span class="kw4">tm</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> query <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, l, r<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">return</span> combine <span class="br0">&#40;</span>
		query <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, <span class="kw4">tm</span><span class="br0">&#41;</span>,
		query <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, r<span class="br0">&#41;</span>
	<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h3 style="padding-top:15px;">Сохранение всего подмассива в каждой вершине дерева отрезков</h3><p>Это отдельный подраздел, стоящий особняком от остальных, поскольку в каждой вершине дерева отрезков мы будем хранить не какую-то сжатую информацию об этом подотрезке (сумму, минимум, максимум и т.п.), а <b>все</b> элементы массива, лежащие в этом подотрезке. Таким образом, корень дерева отрезков будет хранить все элементы массива, левый сын корня &mdash; первую половину массива, правый сын корня &mdash; вторую половину, и так далее.<p>Самый простой вариант применения этой техники &mdash; когда в каждой вершине дерева отрезков хранится отсортированный список всех чисел, встречающихся в соответствующем отрезке. В более сложных вариантах хранятся не списки, а какие-либо структуры данных, построенные над этими списками (<img class=tex src="../tex2png/cache/69ee37dcc56b08d150f58c59e467f874.png" alt="\rm set">, <img class=tex src="../tex2png/cache/2914117bd9c3f88c889641b5ed7e2461.png" alt="\rm map"> и т.д.). Но все эти методы объединяет то, что в каждой вершине дерева отрезков хранится некая структура данных, имеющая в памяти размер порядка длины соответствующего отрезка.<p>Первый естественный вопрос, встающий при рассмотрении деревьев отрезков этого класса &mdash; это <b>объём потребляемой памяти</b>. Утверждается, что если в каждой вершине дерева отрезков хранится список всех встречающихся на этом отрезке чисел, либо любая другая структура данных размера того же порядка, то в сумме всё дерево отрезков будет занимать <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)"> ячеек памяти. Почему это так? Потому что каждое число <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]"> попадает в <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> отрезков дерева отрезков (хотя бы потому, что высота дерева отрезков есть <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">).<p>Итак, несмотря на кажущуюся расточительность такого дерева отрезков, он потребляет памяти не сильно больше обычного дерева отрезков.<p>Ниже описано несколько типичных применений такой структуры данных. Стоит сразу отметить явную аналогию деревьев отрезков этого типа с <b>двумерными структурами данных</b> (собственно, в каком-то смысле это и есть двумерная структура данных, но с довольно ограниченными возможностями).<p><h4>Поиск наименьшего числа, больше либо равного заданного, в указанном отрезке. Запросов модификации нет</h4><p>Требуется отвечать на запросы следующего вида: <img class=tex src="../tex2png/cache/2299c7cb2af1f2f4088808efbc21bf69.png" alt="(l,r,x)">, что означает найти минимальное число в отрезке <img class=tex src="../tex2png/cache/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a[l \ldots r]">, которое больше либо равно <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">.<p><b>Построим</b> дерево отрезков, в котором в каждой вершине будем хранить отсортированный список всех чисел, встречающихся на соответствующем отрезке. Например, корень будет содержать массив <img class=tex src="../tex2png/cache/0f0e294f3fa9d716ea988ff8370f698d.png" alt="a[]"> в отсортированном виде. Как построить такое дерево отрезков максимально эффективно? Для этого подойдём к задаче, как обычно, с точки зрения рекурсии: пусть для левого и правого сыновей текущей вершины эти списки уже построены, и нам требуется построить этот список для текущей вершины. При такой постановке вопроса становится почти очевидно, что это можно сделать за линейное время: нам просто надо объединить два отсортированных списка в один, что делается одним проходом по ним с двумя указателями. Пользователям C++ ещё проще, потому что этот алгоритм слияния уже включён в стандартную библиотеку STL:<p><pre class="notranslate cpp">vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> t<span class="br0">&#91;</span><span class="nu0">4</span><span class="sy2">*</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> build <span class="br0">&#40;</span><span class="kw4">int</span> a<span class="br0">&#91;</span><span class="br0">&#93;</span>, <span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="br0">&#40;</span><span class="nu0">1</span>, a<span class="br0">&#91;</span>tl<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build <span class="br0">&#40;</span>a, v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span><span class="br0">&#41;</span><span class="sy4">;</span>
		build <span class="br0">&#40;</span>a, v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr<span class="br0">&#41;</span><span class="sy4">;</span>
		merge <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span>.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span>.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span>,
			back_inserter <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Мы уже знаем, что построенное таким образом дерево отрезков будет занимать <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)"> памяти. А благодаря такой реализации время его построения также есть величина <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)"> &mdash; ведь каждый список строится за линейное относительно его размера время. (Кстати говоря, здесь прослеживается очевидная аналогия с алгоритмом <b>сортировки слиянием</b>: только здесь мы сохраняем информацию со всех этапов работы алгоритма, а не только итог.)<p>Теперь рассмотрим <b>ответ на запрос</b>. Будем спускаться по дереву, как это делает стандартный ответ на запрос в дереве отрезков, разбивая наш отрезок <img class=tex src="../tex2png/cache/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a[l \ldots r]"> на несколько подотрезков (порядка <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> штук). Понятно, что ответ на всю задачу равен минимуму среди ответов на каждом из этих подотрезков. Поймём теперь, как отвечать на запрос на одном таком подотрезке, совпадающем с некоторой вершиной дерева.<p>Итак, мы пришли в какую-то вершину дерева отрезков и хотим посчитать ответ на ней, т.е. найти минимальное число, больше либо равное данного <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">. Для этого нам всего лишь надо выполнить <b>бинарный поиск</b> по списку, посчитанному в этой вершине дерева, и вернуть первое число из этого списка, больше либо равное <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">.<p>Таким образом, ответ на запрос в одном подотрезке происходит за <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">, а весь запрос обрабатывается за время <img class=tex src="../tex2png/cache/5f31d6f46e03579a1025f178e6d85150.png" alt="O (\log^2 n)">.<p><pre class="notranslate cpp"><span class="kw4">int</span> query <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r, <span class="kw4">int</span> x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">&gt;</span> r<span class="br0">&#41;</span>
		<span class="kw1">return</span> INF<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> tr <span class="sy1">==</span> r<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">iterator</span> pos <span class="sy1">=</span> lower_bound <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, x<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>pos <span class="sy3">!</span><span class="sy1">=</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
			<span class="kw1">return</span> <span class="sy2">*</span>pos<span class="sy4">;</span>
		<span class="kw1">return</span> INF<span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> min <span class="br0">&#40;</span>
		query <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, min<span class="br0">&#40;</span>r,<span class="kw4">tm</span><span class="br0">&#41;</span>, x<span class="br0">&#41;</span>,
		query <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, max<span class="br0">&#40;</span>l,<span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span>, r, x<span class="br0">&#41;</span>
	<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Константа <img class=tex src="../tex2png/cache/a7edbf6ce4bf393cf5db4311b9f2d11c.png" alt="\rm INF"> равна некоторому большому числу, заведомо большему, чем любое число в массиве. Она несёт смысл "ответа в заданном отрезке не существует".<p><h4>Поиск наименьшего числа, больше либо равного заданного, в указанном отрезке. Допускаются запросы модификации</h4><p>Задача аналогична предыдущей, только теперь разрешены запросы модификации: обработать присвоение <img class=tex src="../tex2png/cache/7353f11d35dc517eab4a2cb55fa502f3.png" alt="a[i] = y">.<p>Решение также аналогично решению предыдущей задачи, только вместо простых списков в каждой вершине дерева отрезков мы будем хранить сбалансированный список, который позволяет быстро искать требуемое число, удалять его, а также вставлять новое число. Учитывая, что вообще говоря число во входном массиве могут повторяться, оптимальным выбором является структура данных STL <img class=tex src="../tex2png/cache/837e3e64817a11afc8df22006c713a4c.png" alt="\rm multiset">.<p><b>Построение</b> такого дерева отрезков происходит примерно так же, как и в предыдущей задаче, только теперь надо объединять не отсортированные списки, а <img class=tex src="../tex2png/cache/837e3e64817a11afc8df22006c713a4c.png" alt="\rm multiset">, что приведёт к тому, что асимптотика построения ухудшится до <img class=tex src="../tex2png/cache/0099e97e473671511b813930b9a76fdf.png" alt="n \log^2 n"> (хотя, по-видимому, красно-чёрные деревья позволяют выполнить слияние двух деревьев за линейное время, однако библиотека STL этого не гарантирует).<p>Ответ на <b>запрос поиска</b> вообще практически эквивалентен приведённому выше коду, только теперь <img class=tex src="../tex2png/cache/ef06ba88ff5e8e3e5acd0d038b89f321.png" alt="\rm lower\_bound"> надо вызывать от <img class=tex src="../tex2png/cache/984b49d9311673e2bd809524d195f995.png" alt="t[v]">.<p>Наконец, <b>запрос модификации</b>. Для его обработки мы должны спуститься по дереву, внеся изменения во все <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> списков, содержащих затрагиваемый элемент. Мы просто удаляем старое значение этого элемента (не забыв, что нам не надо удалить вместе с ним все повторы этого числа) и вставляем его новое значение.<p><pre class="notranslate cpp"><span class="kw4">void</span> update <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos, <span class="kw4">int</span> new_val<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">erase</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">find</span> <span class="br0">&#40;</span>a<span class="br0">&#91;</span>pos<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	t<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">insert</span> <span class="br0">&#40;</span>new_val<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy3">!</span><span class="sy1">=</span> tr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">&#41;</span>
			update <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, pos, new_val<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			update <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos, new_val<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">else</span>
		a<span class="br0">&#91;</span>pos<span class="br0">&#93;</span> <span class="sy1">=</span> new_val<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Обработка этого запроса происходит также за время <img class=tex src="../tex2png/cache/5f31d6f46e03579a1025f178e6d85150.png" alt="O (\log^2 n)">.<p><h4>Поиск наименьшего числа, больше либо равного заданного, в указанном отрезке. Ускорение с помощью техники "частичного каскадирования"</h4><p>Улучшим время ответа на запрос поиска до времени <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> с помощью применения техники <b>"частичного каскадирования"</b> ("fractional cascading").<p>Частичное каскадирование &mdash; это простой приём, который позволяет улучшить время работы нескольких бинарных поисков, ведущихся по одному и тому же значению. В самом деле, ответ на запрос поиска заключается в том, что мы разбиваем нашу задачу на несколько подзадач, каждая из которых затем решается бинарным поиском по числу <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">. Частичное каскадирование позволяет заменить все эти двоичные поиски на один.<p>Простейшим и самым наглядным примером частичного каскадирования является <b>следующая задача</b>: есть несколько отсортированных списков чисел, и мы должны в каждом списке найти первое число, больше либо равное заданного.<p>Если бы мы решали задачу "в лоб", то вынуждены были бы запустить бинарный поиск по каждому из этих списков, что, если этих списков много, становится весьма существенным фактором: если всего списков <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, то асимптотика получится <img class=tex src="../tex2png/cache/36305a4c5be51fe8537b1e3b15a34838.png" alt="O (k \log(n/k))">, где <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> &mdash; суммарный размер всех списков (асимптотика такова, потому что худший случай &mdash; когда все списки примерно равны друг другу по длине, т.е. равны <img class=tex src="../tex2png/cache/67a0b3e3294957583af82f1450f16a88.png" alt="n/k">).<p>Вместо этого, мы могли бы объединить все эти списки в один отсортированный список, в котором для каждого числа <img class=tex src="../tex2png/cache/015908c458a90fd729e3b6a927029ce1.png" alt="n_i"> будем хранить список позиций: позицию в первом списке первого числа, больше либо равного <img class=tex src="../tex2png/cache/015908c458a90fd729e3b6a927029ce1.png" alt="n_i">, аналогичную позицию во втором списке, и так далее. Иными словами, для каждого встречающегося числа мы храним вместе с этим числом результаты двоичных поисков по нему в каждом из списков. В таком случае асимптотика ответа на запрос получается <img class=tex src="../tex2png/cache/442fa4917638c096d0a18727a9e67395.png" alt="O (\log n + k)">, что существенно лучше, однако мы вынуждены расплачиваться большим потреблением памяти: а именно, нам требуется <img class=tex src="../tex2png/cache/45ac05c1a1331c87b1df10a93e50cbe7.png" alt="O (nk)"> ячеек памяти.<p>Техника частичного каскадирования идёт дальше в решении этой задачи и добивается потребления памяти <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"> при том же самом времени ответа на запрос <img class=tex src="../tex2png/cache/442fa4917638c096d0a18727a9e67395.png" alt="O (\log n + k)">. (Для этого мы храним не один большой список длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, а снова возвращаемся к <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> спискам, но вместе с каждым списком храним каждый второй элемент из следующего списка; нам снова придётся вместе с каждым числом записывать его позицию в обоих списках (текущем и следующем), однако это позволит по-прежнему эффективно отвечать на запрос: мы делаем двоичный поиск по первому списку, а затем идём по этим спискам по порядку, переходя каждый раз в следующий список с помощью предпосчитанных указателей, и делая один шаг влево, учитывая тем самым, что половина чисел следующего списка учтена не была).<p>Но нам в нашем приложении к дереву отрезков <b>не нужна</b> полная мощь этой техники. Дело в том, что список в текущей вершине содержит все числа, которые могут встречаться в левом и правом сыновьях. Поэтому, чтобы избежать бинарного поиска по списку сына, нам достаточно для каждого списка в дереве отрезков посчитать для каждого числа его позиции в списках левого и правого сыновей (точнее, позиции первого числа, меньшего либо равного текущему).<p>Таким образом, вместо обычного списка всех чисел мы храним список троек: само число, позиция в списке левого сына, позиция в списке правого сына. Это позволит нам за <img class=tex src="../tex2png/cache/d0ea0c0a39869a72fadf80b704c58fbf.png" alt="O (1)"> определять позицию в списке левого или правого сына, вместо того чтобы делать двоичный список по нему.<p>Проще всего эту технику применять к задаче, когда запросы модификации отсутствуют, &mdash; тогда эти позиции представляют собой просто числа, а подсчитывать их при построении дерева очень легко внутри алгоритма слияния двух отсортированных последовательностей.<p>В случае, когда разрешены запросы модификации, всё несколько усложняется: эти позиции теперь надо хранить в виде итераторов внутри <img class=tex src="../tex2png/cache/837e3e64817a11afc8df22006c713a4c.png" alt="\rm multiset">, а при запросе обновления &mdash; правильно уменьшать/увеличивать для тех элементов, для которых это требуется.<p>Так или иначе, задача уже сводится к чисто реализационным тонкостям, а основная идея &mdash; замена <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> бинарных поисков одним бинарным поиском по списку в корне дерева &mdash; описана полностью.<p><h4>Другие возможные направления</h4><p>Заметим, что эта техника подразумевает под собой целый класс возможных приложений &mdash; всё определяется структурой данных, выбранной для хранения в каждой вершине дерева. Выше были рассмотрены приложения с использованием <img class=tex src="../tex2png/cache/34f8b10596e5ad6a9b0d89adee5103d1.png" alt="\rm vector"> и <img class=tex src="../tex2png/cache/837e3e64817a11afc8df22006c713a4c.png" alt="\rm multiset">, в то время как вообще использоваться может любая другая компактная структура данных: другое дерево отрезков (об этом немного сказано ниже в разделе о многомерных деревьях отрезков), <a href="fenwick_tree.html">дерево Фенвика</a>, <a href="treap.html">декартово дерево</a> и т.д.<p><p><h3 style="padding-top:15px;">Обновление на отрезке</h3><p>Выше рассматривались только задачи, когда запрос модификации затрагивает единственный элемент массива. На самом деле, дерево отрезков позволяет делать запросы, которые применяются к целым отрезкам подряд идущих элементов, причём выполнять эти запросы за то же время <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">.<p><h4>Прибавление на отрезке</h4><p>Начнём рассмотрение деревьев отрезков такого рода с самого простого случая: запрос модификации представляет собой прибавление ко всем числам на некотором подотрезке <img class=tex src="../tex2png/cache/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a[l \ldots r]"> некоторого числа <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">. Запрос чтения &mdash; по-прежнему считывание значения некоторого числа <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]">.<p>Чтобы делать запрос прибавления эффективно, будем хранить в каждой вершине дерева отрезков, сколько надо прибавить ко всем числам этого отрезка целиком. Например, если приходит запрос "прибавить ко всему массиву <img class=tex src="../tex2png/cache/2f7c3ec9c849a4dcbfc3195989056b93.png" alt="a[0 \ldots n-1]"> число 2", то мы поставим в корне дерева число <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2">. Тем самым мы сможем обрабатывать запрос прибавления на любом подотрезке эффективно, вместо того чтобы изменять все <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"> значений.<p>Если теперь приходит запрос чтения значения того или иного числа, то нам достаточно спуститься по дереву, просуммировав все встреченные по пути значения, записанные в вершинах дерева.<p><pre class="notranslate cpp"><span class="kw4">void</span> build <span class="br0">&#40;</span><span class="kw4">int</span> a<span class="br0">&#91;</span><span class="br0">&#93;</span>, <span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="br0">&#91;</span>tl<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build <span class="br0">&#40;</span>a, v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span><span class="br0">&#41;</span><span class="sy4">;</span>
		build <span class="br0">&#40;</span>a, v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> update <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r, <span class="kw4">int</span> add<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">&gt;</span> r<span class="br0">&#41;</span>
		<span class="kw1">return</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> tr <span class="sy1">==</span> r<span class="br0">&#41;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> add<span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		update <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, min<span class="br0">&#40;</span>r,<span class="kw4">tm</span><span class="br0">&#41;</span>, add<span class="br0">&#41;</span><span class="sy4">;</span>
		update <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, max<span class="br0">&#40;</span>l,<span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span>, r, add<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> get <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		<span class="kw1">return</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> get <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, pos<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">else</span>
		<span class="kw1">return</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> get <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><h4>Присвоение на отрезке</h4><p>Пусть теперь запрос модификации представляет собой присвоение всем элементам некоторого отрезка <img class=tex src="../tex2png/cache/61de5ad6b5b41c84e862798a8f59f0a9.png" alt="a[l \ldots r]"> некоторого значения <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">. В качестве второго запроса будем рассматривать считывание значения массива <img class=tex src="../tex2png/cache/3530c8c1281c8ee618b020a2333a22ca.png" alt="a[i]">.<p>Чтобы делать модификацию на целом отрезке, придётся в каждой вершине дерева отрезков хранить, покрашен ли этот отрезок целиком в какое-либо число или нет (и если покрашен, то хранить само это число). Это позволит нам делать <b>"запаздывающее" обновление</b> дерева отрезков: при запросе модификации мы, вместо того чтобы менять значения во множестве вершин дерева отрезков, поменяем только некоторые из них, оставив флаги "покрашен" для других отрезков, что означает, что весь этот отрезок вместе со своими подотрезками должен быть покрашен в этот цвет.<p>Итак, после выполнения запроса модификации дерево отрезков становится, вообще говоря, неактуальным &mdash; в нём остались недовыполненными некоторые модификации.<p>Например, если пришёл запрос модификации "присвоить всему массиву <img class=tex src="../tex2png/cache/2f7c3ec9c849a4dcbfc3195989056b93.png" alt="a[0 \ldots n-1]"> какое-то число", то в дереве отрезков мы сделаем единственное изменение &mdash; пометим корень дерева, что он покрашен целиком в это число. Остальные же вершины дерева останутся неизменёнными, хотя на самом деле всё дерево должно быть покрашено в одно и то же число.<p>Предположим теперь, что в том же дереве отрезков пришёл второй запрос модификации &mdash; покрасить первую половину массива <img class=tex src="../tex2png/cache/956cf050b80daaa13a7143f3acb10f4e.png" alt="a[0 \ldots n/2]"> в какое-либо другое число. Чтобы обработать такой запрос, мы должны покрасить целиком левого сына корня в этот новый цвет, однако перед тем как сделать это, мы должны разобраться с корнем дерева. Тонкость здесь в том, что в дереве должно сохраниться, что правая половина покрашена в старый цвет, а в данный момент в дереве никакой информации для правой половины не сохранено.<p>Выход таков: произвести <b>проталкивание</b> информации из корня, т.е. если корень дерева был покрашен в какое-либо число, то покрасить в это число его правого и левого сына, а из корня эту отметку убрать. После этого мы можем спокойно красить левого сына корня, не теряя никакой нужной информации.<p>Обобщая, получаем: при любых запросах с таким деревом (запрос модификации или чтения) во время спуска по дереву мы всегда должны делать проталкивание информации из текущей вершины в обоих её сыновей. Можно понимать это так, что при спуске по дереву мы применяем запаздывающие модификации, но ровно настолько, насколько это необходимо (чтобы не ухудшить асимптотику с <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">).<p>При реализации это означает, что нам надо сделать функцию <img class=tex src="../tex2png/cache/176a4d7539ede6a2826ee87fd28aa331.png" alt="\rm push">, которой будет передаваться вершина дерева отрезков, и она будет производить проталкивание информации из этой вершины в обоих её сыновей. Вызывать эту функцию следует в самом начале функций обработки запросов (но не вызывать её из листьев, ведь из листа проталкивать информацию не надо, да и некуда).<p><pre class="notranslate cpp"><span class="kw4">void</span> push <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy1">=</span> t<span class="br0">&#91;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy1">=</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy4">;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> update <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r, <span class="kw4">int</span> color<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">&gt;</span> r<span class="br0">&#41;</span>
		<span class="kw1">return</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> tr <span class="sy1">==</span> r<span class="br0">&#41;</span>
		t<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> color<span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		push <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		update <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, l, min<span class="br0">&#40;</span>r,<span class="kw4">tm</span><span class="br0">&#41;</span>, color<span class="br0">&#41;</span><span class="sy4">;</span>
		update <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, max<span class="br0">&#40;</span>l,<span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span>, r, color<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> get <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		<span class="kw1">return</span> t<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy4">;</span>
	push <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> get <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span>, tl, <span class="kw4">tm</span>, pos<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">else</span>
		<span class="kw1">return</span> get <span class="br0">&#40;</span>v<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Функцию <img class=tex src="../tex2png/cache/75ab7597c32a38a478cc195daa874346.png" alt="\rm get"> можно было бы реализовать и по-другому: не делать в ней запаздывающих обновлений, а сразу возвращать ответ, как только она попадает в вершину дерева отрезков, целиком покрашенную в тот или иной цвет.<p><h4>Прибавление на отрезке, запрос максимума</h4><p>Пусть теперь запросом модификации снова будет запрос прибавления ко всем числам некоторого подотрезка одного и того же числа, а запросом чтения будет нахождение максимума в некотором подотрезке.<p>Тогда в каждой вершине дерева отрезков надо будет дополнительно хранить максимум на всём этом подотрезке. Но тонкость здесь заключается в том, как надо пересчитывать эти значения.<p>Например, пусть произошёл запрос "прибавить ко всей первой половине, т.е. <img class=tex src="../tex2png/cache/956cf050b80daaa13a7143f3acb10f4e.png" alt="a[0 \ldots n/2]">, число 2". Тогда в дереве это отразится записью числа <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2"> в левого сына корня. Как теперь посчитать новое значение максимума в левом сыне и в корне? Здесь становится важно не запутаться &mdash; какой максимум хранится в вершине дерева: максимум без учёта прибавления на всей этой вершине, или же с учётом его. Выбрать можно любой из этих подходов, но главное &mdash; последовательно использовать его везде. Например, при первом подходе максимум в корне будет получаться как максимум из двух чисел: максимум в левом сыне плюс прибавление в левом сыне, и максимум в правом сыне плюс прибавление в нём. При втором же подходе максимум в корне будет получаться как прибавление в корне плюс максимум из максимумов в левом и правом сыновьях.<p><h4>Другие направления</h4><p>Здесь были рассмотрены только базовые применения деревьев отрезков в задачах с модификациями на отрезке. Остальные задачи получаются на основе тех же самых идей, что описаны здесь.<p>Важно только быть очень аккуратным при работе с отложенными модификациями: следует помнить, что даже если в текущей вершине мы уже "протолкнули" отложенную модификацию, то в левом и правом сыновьях, скорее всего, этого ещё не сделали. Поэтому часто необходимым является вызывать <img class=tex src="../tex2png/cache/176a4d7539ede6a2826ee87fd28aa331.png" alt="\rm push"> также от левого и правого сыновей текущей вершины, либо же аккуратно учитывать отложенные модификации в них.<p><p><h3 style="padding-top:15px;">Обобщение на большие размерности</h3><p>Дерево отрезков обобщается вполне естественным образом на двумерный и вообще многомерный случай. Если в одномерном случае мы разбивали индексы массива на отрезки, то в двумерном случае теперь будем сначала разбивать всё по первым индексам, а для каждого отрезка по первым индексам &mdash; строить обычное дерево отрезков по вторым индексам. Таким образом, основная идея решения &mdash; это вкладывание деревьев отрезков по вторым индексам внутрь дерева отрезков по первым индексам.<p>Поясним эту идею на примере конкретной задачи.<p><h4>Двумерное дерево отрезков в простейшем варианте</h4><p>Дана прямоугольная матрица <img class=tex src="../tex2png/cache/6b94972ed8ba79bb3e8e49686ab1e9ec.png" alt="a[0 \ldots n-1, 0 \ldots m-1]">, и поступают запросы поиска суммы (или минимума/максимума) на некоторых подпрямоугольниках <img class=tex src="../tex2png/cache/9899cae2fa585d045f979f7879a339b5.png" alt="a[x_1 \ldots x_2, y_1 \ldots y_2]">, а также запросы модификации отдельных элементов матрицы (т.е. запросы вида <img class=tex src="../tex2png/cache/e716b0e93c8fd88c80cdf5c34bc7635a.png" alt="a[x][y] = p">).<p>Итак, будем строить двумерное дерево отрезков: сначала дерево отрезков по первой координате (<img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">), затем &mdash; по второй (<img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">).<p>Чтобы <b>процесс построения</b> был более понятен, можно на время забыть, что исходный массив был двумерным, и оставить только первую координату. Будем строить обычное одномерное дерево отрезков, работая только с первой координатой. Но в качестве значения каждого отрезка мы будем записывать не какое-то число, как в одномерном случае, а целое дерево отрезков: т.е. в этот момент мы вспоминаем, что у нас есть ещё и вторая координата; но т.к. в этот момент уже зафиксировано, что первая координата есть некоторый отрезок <img class=tex src="../tex2png/cache/653023af1da32cf3f51fe321fa0778da.png" alt="[l \ldots r]">, то мы фактически работаем с такой полосой <img class=tex src="../tex2png/cache/6667265fa55232c5f15f9e7541be3730.png" alt="a[l \ldots r, 0 \ldots m-1]">, и для неё строим дерево отрезков.<p>Приведём реализацию операции построения двумерного дерева. Она фактически представляет собой два отдельных блока: построение дерева отрезков по координате <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> (<img class=tex src="../tex2png/cache/e3112df90e1fb46809b8f6056d346482.png" alt="\rm build\_x">) и по координате <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> (<img class=tex src="../tex2png/cache/4eb2e24d0e09179a13bec9519d32481d.png" alt="\rm build\_y">). Если первая функция почти ничем не отличается от обычного одномерного дерева, то вторая вынуждена разбираться отдельно с двумя случаями: когда текущий отрезок по первой координате (<img class=tex src="../tex2png/cache/3988cf2204e9d8fd5c18e5a01d578a0b.png" alt="[tlx \ldots trx]">) имеет единичную длину, и когда &mdash; длину, большую единицы. В первом случае мы просто берём нужное значение из матрицы <img class=tex src="../tex2png/cache/f9fa957c4ed546b728381d1556189238.png" alt="a[][]">, а во втором &mdash; объединяем значения двух деревьев отрезков из левого сына и правого сына по координате <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">.<p><pre class="notranslate cpp"><span class="kw4">void</span> build_y <span class="br0">&#40;</span><span class="kw4">int</span> vx, <span class="kw4">int</span> lx, <span class="kw4">int</span> rx, <span class="kw4">int</span> vy, <span class="kw4">int</span> ly, <span class="kw4">int</span> ry<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>ly <span class="sy1">==</span> ry<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>lx <span class="sy1">==</span> rx<span class="br0">&#41;</span>
			t<span class="br0">&#91;</span>vx<span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="br0">&#91;</span>lx<span class="br0">&#93;</span><span class="br0">&#91;</span>ly<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			t<span class="br0">&#91;</span>vx<span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="br0">&#93;</span> <span class="sy1">=</span> t<span class="br0">&#91;</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="br0">&#93;</span> <span class="sy2">+</span> t<span class="br0">&#91;</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> my <span class="sy1">=</span> <span class="br0">&#40;</span>ly <span class="sy2">+</span> ry<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build_y <span class="br0">&#40;</span>vx, lx, rx, vy<span class="sy2">*</span><span class="nu0">2</span>, ly, my<span class="br0">&#41;</span><span class="sy4">;</span>
		build_y <span class="br0">&#40;</span>vx, lx, rx, vy<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, my<span class="sy2">+</span><span class="nu0">1</span>, ry<span class="br0">&#41;</span><span class="sy4">;</span>
		t<span class="br0">&#91;</span>vx<span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="br0">&#93;</span> <span class="sy1">=</span> t<span class="br0">&#91;</span>vx<span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy2">+</span> t<span class="br0">&#91;</span>vx<span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> build_x <span class="br0">&#40;</span><span class="kw4">int</span> vx, <span class="kw4">int</span> lx, <span class="kw4">int</span> rx<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>lx <span class="sy3">!</span><span class="sy1">=</span> rx<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> mx <span class="sy1">=</span> <span class="br0">&#40;</span>lx <span class="sy2">+</span> rx<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		build_x <span class="br0">&#40;</span>vx<span class="sy2">*</span><span class="nu0">2</span>, lx, mx<span class="br0">&#41;</span><span class="sy4">;</span>
		build_x <span class="br0">&#40;</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, mx<span class="sy2">+</span><span class="nu0">1</span>, rx<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	build_y <span class="br0">&#40;</span>vx, lx, rx, <span class="nu0">1</span>, <span class="nu0">0</span>, m<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Такое дерево отрезков занимает по-прежнему линейный объём памяти, но уже с большей константой: <img class=tex src="../tex2png/cache/7df4261488a6ff1c04fccf17800bdd58.png" alt="16 n m"> ячеек памяти. Понятно, что строится оно описанной выше процедурой <img class=tex src="../tex2png/cache/e3112df90e1fb46809b8f6056d346482.png" alt="\rm build\_x"> тоже за линейное время.<p>Перейдем теперь к <b>обработке запросов</b>. Отвечать на двумерный запрос будем по тому же самому принципу: сначала разбивать запрос по первой координате, а затем, когда мы дошли до какой-то вершины дерева отрезков по первой координате &mdash; вызывать запрос от соответствующего дерева отрезков по второй координате.<p><pre class="notranslate cpp"><span class="kw4">int</span> sum_y <span class="br0">&#40;</span><span class="kw4">int</span> vx, <span class="kw4">int</span> vy, <span class="kw4">int</span> tly, <span class="kw4">int</span> try_, <span class="kw4">int</span> ly, <span class="kw4">int</span> ry<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>ly <span class="sy1">&gt;</span> ry<span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>ly <span class="sy1">==</span> tly <span class="sy3">&amp;&amp;</span> try_ <span class="sy1">==</span> ry<span class="br0">&#41;</span>
		<span class="kw1">return</span> t<span class="br0">&#91;</span>vx<span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw4">int</span> tmy <span class="sy1">=</span> <span class="br0">&#40;</span>tly <span class="sy2">+</span> try_<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> sum_y <span class="br0">&#40;</span>vx, vy<span class="sy2">*</span><span class="nu0">2</span>, tly, tmy, ly, min<span class="br0">&#40;</span>ry,tmy<span class="br0">&#41;</span><span class="br0">&#41;</span>
		<span class="sy2">+</span> sum_y <span class="br0">&#40;</span>vx, vy<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, tmy<span class="sy2">+</span><span class="nu0">1</span>, try_, max<span class="br0">&#40;</span>ly,tmy<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span>, ry<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> sum_x <span class="br0">&#40;</span><span class="kw4">int</span> vx, <span class="kw4">int</span> tlx, <span class="kw4">int</span> trx, <span class="kw4">int</span> lx, <span class="kw4">int</span> rx, <span class="kw4">int</span> ly, <span class="kw4">int</span> ry<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>lx <span class="sy1">&gt;</span> rx<span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>lx <span class="sy1">==</span> tlx <span class="sy3">&amp;&amp;</span> trx <span class="sy1">==</span> rx<span class="br0">&#41;</span>
		<span class="kw1">return</span> sum_y <span class="br0">&#40;</span>vx, <span class="nu0">1</span>, <span class="nu0">0</span>, m<span class="sy2">-</span><span class="nu0">1</span>, ly, ry<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw4">int</span> tmx <span class="sy1">=</span> <span class="br0">&#40;</span>tlx <span class="sy2">+</span> trx<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> sum_x <span class="br0">&#40;</span>vx<span class="sy2">*</span><span class="nu0">2</span>, tlx, tmx, lx, min<span class="br0">&#40;</span>rx,tmx<span class="br0">&#41;</span>, ly, ry<span class="br0">&#41;</span>
		<span class="sy2">+</span> sum_x <span class="br0">&#40;</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, tmx<span class="sy2">+</span><span class="nu0">1</span>, trx, max<span class="br0">&#40;</span>lx,tmx<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span>, rx, ly, ry<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Эта функция работает за время <img class=tex src="../tex2png/cache/d74b09d786f708ee7fe805ea61527587.png" alt="O (\log n \log m)">, поскольку она сначала спускается по дереву по первой координате, а для каждой пройденной вершины этого дерева &mdash; делает запрос у обычного дерева отрезков по второй координате.<p>Наконец, рассмотрим <b>запрос модификации</b>. Мы хотим научиться модифицировать дерево отрезков в соответствии с изменением значения какого-либо элемента <img class=tex src="../tex2png/cache/e716b0e93c8fd88c80cdf5c34bc7635a.png" alt="a[x][y] = p">. Понятно, что изменения произойдут только в тех вершинах первого дерева отрезков, которые накрывают координату <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> (а таких будет <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">), а для деревьев отрезков, соответствующих им &mdash; изменения будут только в тех вершинах, которые накрывают координату <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> (и таких будет <img class=tex src="../tex2png/cache/1598b628fc5926ef873e70421a929113.png" alt="O (\log m)">). Поэтому реализация запроса модификации не будет сильно отличаться от одномерного случая, только теперь мы сначала спускаемся по первой координате, а затем &mdash; по второй.<p><pre class="notranslate cpp"><span class="kw4">void</span> update_y <span class="br0">&#40;</span><span class="kw4">int</span> vx, <span class="kw4">int</span> lx, <span class="kw4">int</span> rx, <span class="kw4">int</span> vy, <span class="kw4">int</span> ly, <span class="kw4">int</span> ry, <span class="kw4">int</span> x, <span class="kw4">int</span> y, <span class="kw4">int</span> new_val<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>ly <span class="sy1">==</span> ry<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>lx <span class="sy1">==</span> rx<span class="br0">&#41;</span>
			t<span class="br0">&#91;</span>vx<span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="br0">&#93;</span> <span class="sy1">=</span> new_val<span class="sy4">;</span>
		<span class="kw1">else</span>
			t<span class="br0">&#91;</span>vx<span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="br0">&#93;</span> <span class="sy1">=</span> t<span class="br0">&#91;</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="br0">&#93;</span> <span class="sy2">+</span> t<span class="br0">&#91;</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> my <span class="sy1">=</span> <span class="br0">&#40;</span>ly <span class="sy2">+</span> ry<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>y <span class="sy1">&lt;=</span> my<span class="br0">&#41;</span>
			update_y <span class="br0">&#40;</span>vx, lx, rx, vy<span class="sy2">*</span><span class="nu0">2</span>, ly, my, x, y, new_val<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			update_y <span class="br0">&#40;</span>vx, lx, rx, vy<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, my<span class="sy2">+</span><span class="nu0">1</span>, ry, x, y, new_val<span class="br0">&#41;</span><span class="sy4">;</span>
		t<span class="br0">&#91;</span>vx<span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="br0">&#93;</span> <span class="sy1">=</span> t<span class="br0">&#91;</span>vx<span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="sy2">*</span><span class="nu0">2</span><span class="br0">&#93;</span> <span class="sy2">+</span> t<span class="br0">&#91;</span>vx<span class="br0">&#93;</span><span class="br0">&#91;</span>vy<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> update_x <span class="br0">&#40;</span><span class="kw4">int</span> vx, <span class="kw4">int</span> lx, <span class="kw4">int</span> rx, <span class="kw4">int</span> x, <span class="kw4">int</span> y, <span class="kw4">int</span> new_val<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>lx <span class="sy3">!</span><span class="sy1">=</span> rx<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> mx <span class="sy1">=</span> <span class="br0">&#40;</span>lx <span class="sy2">+</span> rx<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>x <span class="sy1">&lt;=</span> mx<span class="br0">&#41;</span>
			update_x <span class="br0">&#40;</span>vx<span class="sy2">*</span><span class="nu0">2</span>, lx, mx, x, y, new_val<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">else</span>
			update_x <span class="br0">&#40;</span>vx<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">1</span>, mx<span class="sy2">+</span><span class="nu0">1</span>, rx, x, y, new_val<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	update_y <span class="br0">&#40;</span>vx, lx, rx, <span class="nu0">1</span>, <span class="nu0">0</span>, m<span class="sy2">-</span><span class="nu0">1</span>, x, y, new_val<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><h4>Сжатие двумерного дерева отрезков</h4><p>Пусть задача следующая: есть <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> точек на плоскости, заданных своими координатами <img class=tex src="../tex2png/cache/a5be10853e90ed2cd02bc9bf3215a165.png" alt="(x_i,y_i)">, и поступают запросы вида "посчитать количество точек, лежащих в прямоугольнике <img class=tex src="../tex2png/cache/dd10350ae2982d2e000611454248ac69.png" alt="((x_1,y_1),(x_2,y_2))">". Понятно, что в случае такой задачи становится неоправданно расточительным строить двумерное дерево отрезков с <img class=tex src="../tex2png/cache/4cd2772b06262896a7cf8a9d3c989ea4.png" alt="O (n^2)"> элементами. Большая часть этой памяти будет потрачена впустую, поскольку каждая отдельно взятая точка может попасть только в <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> отрезков дерева отрезков по первой координате, а, значит, суммарный "полезный" размер всех деревьев отрезков по второй координате есть величина <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">.<p>Тогда поступим следующим образом: в каждой вершине дерева отрезков по первой координате будем хранить дерево отрезков, построенное только по тем вторым координатам, которые встречаются в текущем отрезке первых координат. Иными словами, при построении дерева отрезков внутри какой-то вершины с номером <img class=tex src="../tex2png/cache/968e4d769467a3b751b5ca8d21a356e3.png" alt="vx"> и границами <img class=tex src="../tex2png/cache/c32e945279af4fef66bfad6836f4deb8.png" alt="tlx, trx"> мы будем рассматривать только те точки, которые попадают в этот отрезок <img class=tex src="../tex2png/cache/77d95cf1d114134382e7c25b638f34dd.png" alt="x \in [tlx; trx]">, и строить дерево отрезков только над ними.<p>Тем самым мы добьёмся того, что каждое дерево отрезков по второй координате будет занимать ровно столько памяти, сколько и должно. В итоге суммарный <b>объём памяти</b> уменьшится до <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">. <b>Отвечать на запрос</b> мы будем по-прежнему за <img class=tex src="../tex2png/cache/5f31d6f46e03579a1025f178e6d85150.png" alt="O (\log^2 n)">, просто теперь при вызове запроса от дерева отрезков по второй координате мы должны будем сделать бинарный поиск по второй координате, но асимптотику это не ухудшит.<p>Но расплатой станет невозможность делать произвольный <b>запрос модификации</b>: в самом деле, если появится новая точка, то это приведёт к тому, что мы должны будем в каком-либо дереве отрезков по второй координате добавить новый элемент в середину, что эффективно сделать невозможно.<p>В завершение отметим, что сжатое описанным образом двумерное дерево отрезков становится практически <b>эквивалентным</b> описанной выше модификации одномерного дерева отрезков (см. "Сохранение всего подмассива в каждой вершине дерева отрезков"). В частности, получается, что описываемое здесь двумерное дерево отрезков &mdash; это просто частный случай сохранения подмассива в каждой вершине дерева, где подмассив сам хранится в виде дерева отрезков. Отсюда следует, что если приходится отказываться от двумерного дерева отрезков по причине невозможности выполнения того или иного запроса, то имеет смысл попробовать заменить вложенное дерево отрезков на какую-либо более мощную структуру данных, например, <a href="treap.html">декартово дерево</a>.<p><p><h3 style="padding-top:15px;">Дерево отрезков с сохранением истории его значений (улучшение до persistent-структуры данных)</h3><p>Persistent-структурой данных называется такая структура данных, которая при каждой модификации запоминает своё предыдущее состояние. Это позволяет при необходимости обратиться к любой интересующей нас версии этой структуры данных и выполнить запрос на ней.<p>Дерево отрезков является одной из тех структур данных, которая может быть превращена в persistent-структуру данных (разумеется, мы рассматриваем эффективную persistent-структуру, а не такую, которая копирует всю себя целиком перед каждым обновлением).<p>В самом деле, любой запрос изменения в дереве отрезков приводит к изменению данных в <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> вершинах, причём вдоль пути, начинающегося из корня. Значит, если мы будем хранить дерево отрезков на указателях (т.е. указатели на левого и правого сыновей сделать указателями, хранящимися в вершине), то при запросе обновления мы должны просто вместо изменения имеющихся вершин создать новые вершины, ссылки из которых направлять на старые вершины. Тем самым, при запросе обновления будет создано <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> новых вершин, в том числе будет создан новый корень дерева отрезков, а вся предыдующая версия дерева, подвешенная за старый корень, останется без изменений.<p>Приведём пример реализации для простейшего дерева отрезков: когда есть только запрос подсчёта суммы на подотрезке и запрос модификации единственного числа.<p><pre class="notranslate cpp"><span class="kw4">struct</span> vertex <span class="br0">&#123;</span>
	vertex <span class="sy2">*</span> l, <span class="sy2">*</span> r<span class="sy4">;</span>
	<span class="kw4">int</span> sum<span class="sy4">;</span>
&nbsp;
	vertex <span class="br0">&#40;</span><span class="kw4">int</span> val<span class="br0">&#41;</span>
		<span class="sy4">:</span> l<span class="br0">&#40;</span><span class="kw2">NULL</span><span class="br0">&#41;</span>, r<span class="br0">&#40;</span><span class="kw2">NULL</span><span class="br0">&#41;</span>, sum<span class="br0">&#40;</span>val<span class="br0">&#41;</span>
	<span class="br0">&#123;</span> <span class="br0">&#125;</span>
&nbsp;
	vertex <span class="br0">&#40;</span>vertex <span class="sy2">*</span> l, vertex <span class="sy2">*</span> r<span class="br0">&#41;</span>
		<span class="sy4">:</span> l<span class="br0">&#40;</span>l<span class="br0">&#41;</span>, r<span class="br0">&#40;</span>r<span class="br0">&#41;</span>, sum<span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span>
	<span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>l<span class="br0">&#41;</span>  sum <span class="sy2">+</span><span class="sy1">=</span> l<span class="sy2">-</span><span class="sy1">&gt;</span>sum<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>r<span class="br0">&#41;</span>  sum <span class="sy2">+</span><span class="sy1">=</span> r<span class="sy2">-</span><span class="sy1">&gt;</span>sum<span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
&nbsp;
vertex <span class="sy2">*</span> build <span class="br0">&#40;</span><span class="kw4">int</span> a<span class="br0">&#91;</span><span class="br0">&#93;</span>, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="kw3">new</span> vertex <span class="br0">&#40;</span>a<span class="br0">&#91;</span>tl<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> <span class="kw3">new</span> vertex <span class="br0">&#40;</span>
		build <span class="br0">&#40;</span>a, tl, <span class="kw4">tm</span><span class="br0">&#41;</span>,
		build <span class="br0">&#40;</span>a, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr<span class="br0">&#41;</span>
	<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> get_sum <span class="br0">&#40;</span>vertex <span class="sy2">*</span> t, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> l, <span class="kw4">int</span> r<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">&gt;</span> r<span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>l <span class="sy1">==</span> tl <span class="sy3">&amp;&amp;</span> tr <span class="sy1">==</span> r<span class="br0">&#41;</span>
		<span class="kw1">return</span> t<span class="sy2">-</span><span class="sy1">&gt;</span>sum<span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">return</span> get_sum <span class="br0">&#40;</span>t<span class="sy2">-</span><span class="sy1">&gt;</span>l, tl, <span class="kw4">tm</span>, l, min<span class="br0">&#40;</span>r,<span class="kw4">tm</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
		<span class="sy2">+</span> get_sum <span class="br0">&#40;</span>t<span class="sy2">-</span><span class="sy1">&gt;</span>r, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, max<span class="br0">&#40;</span>l,<span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span>, r<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
vertex <span class="sy2">*</span> update <span class="br0">&#40;</span>vertex <span class="sy2">*</span> t, <span class="kw4">int</span> tl, <span class="kw4">int</span> tr, <span class="kw4">int</span> pos, <span class="kw4">int</span> new_val<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>tl <span class="sy1">==</span> tr<span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="kw3">new</span> vertex <span class="br0">&#40;</span>new_val<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw4">int</span> <span class="kw4">tm</span> <span class="sy1">=</span> <span class="br0">&#40;</span>tl <span class="sy2">+</span> tr<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>pos <span class="sy1">&lt;=</span> <span class="kw4">tm</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="kw3">new</span> vertex <span class="br0">&#40;</span>
				update <span class="br0">&#40;</span>t<span class="sy2">-</span><span class="sy1">&gt;</span>l, tl, <span class="kw4">tm</span>, pos, new_val<span class="br0">&#41;</span>,
				t<span class="sy2">-</span><span class="sy1">&gt;</span>r
			<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">else</span>
		<span class="kw1">return</span> <span class="kw3">new</span> vertex <span class="br0">&#40;</span>
				t<span class="sy2">-</span><span class="sy1">&gt;</span>l,
				update <span class="br0">&#40;</span>t<span class="sy2">-</span><span class="sy1">&gt;</span>r, <span class="kw4">tm</span><span class="sy2">+</span><span class="nu0">1</span>, tr, pos, new_val<span class="br0">&#41;</span>
			<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>С помощью этого подхода можно превратить в persistent-структуру данных практически любое дерево отрезков.<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>