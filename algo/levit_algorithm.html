<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Алгоритм Левита нахождения кратчайших путей от заданной вершины до всех остальных вершин за O (N M)</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 19:39<br>редактировано: 2 Oct 2010 1:35</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="levit_algorithm.html#" id="contents-hide">[скрыть]</a><a href="levit_algorithm.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Алгоритм Левита нахождения кратчайших путей от заданной вершины до всех остальных вершин</h1>

<p>Пусть дан граф с N вершинами и M ребрами, для каждого из которых указан его вес L<sub>i</sub>. Также дана стартовая вершина V<sub>0</sub>. Требуется найти кратчайшие пути от вершины V<sub>0</sub> до всех остальных вершин.</p>
<p>Алгоритм Левита решает эту задачу весьма эффективно (по поводу асимптотики и скорости работы см. ниже).</p>
<h2>Описание</h2>
<p>Пусть массив D[1..N] будет содержать текущие кратчайшие длины путей, т.е. D<sub>i</sub> - это текущая длина кратчайшего пути от вершины V<sub>0</sub> до вершины i. Изначально массив D заполнен значениями "бесконечность", кроме D<sub>V<sub>0</sub></sub> = 0. По окончании работы алгоритма этот массив будет содержать окончательные кратчайшие расстояния.</p>
<p>Пусть массив P[1..N] содержит текущих предков, т.е. P<sub>i</sub> - это вершина, предшествующая вершине i в кратчайшем пути от вершины V<sub>0</sub> до i. Так же как и массив D, массив P изменяется постепенно по ходу алгоритма и к концу его принимает окончательные значения.</p>
<p>&nbsp;</p>
<p>Теперь собственно сам алгоритм Левита. На каждом шаге поддерживается три множества вершин:</p>
<ul>
<li>M<sub>0</sub> - вершины, расстояние до которых уже вычислено (но, возможно, не окончательно);</li>
<li>M<sub>1</sub> - вершины, расстояние до которых вычисляется;</li>
<li>M<sub>2</sub> - вершины, расстояние до которых ещё не вычислено.</li>
</ul>
<p>Вершины в множестве M<sub>1</sub> хранятся в виде двунаправленной очереди (deque).</p>
<p>&nbsp;</p>
<p>Изначально все вершины помещаются в множество M<sub>2</sub>, кроме вершины V<sub>0</sub>, которая помещается в множество M<sub>1</sub>.</p>
<p>На каждом шаге алгоритма мы берём вершину из множества M<sub>1</sub> (достаём верхний элемент из очереди). Пусть V - это выбранная вершина. Переводим эту вершину во множество M<sub>0</sub>. Затем просматриваем все рёбра, выходящие из этой вершины. Пусть T - это второй конец текущего ребра (т.е. не равный V), а L - это длина текущего ребра.</p>
<ul>
<li>Если T принадлежит M<sub>2</sub>, то T переносим во множество M<sub>1</sub> в конец очереди. D<sub>T</sub> полагаем равным D<sub>V</sub> + L.</li>
<li>Если T принадлежит M<sub>1</sub>, то пытаемся улучшить значение D<sub>T</sub>: D<sub>T</sub> = min (D<sub>T</sub>, D<sub>V</sub> + L). Сама вершина T никак не передвигается в очереди.</li>
<li>Если T принадлежит M<sub>0</sub>, и если D<sub>T</sub> можно улучшить (D<sub>T</sub> > D<sub>V</sub> + L), то улучшаем D<sub>T</sub>, а вершину T возвращаем в множество M<sub>1</sub>, помещая её в начало очереди.</li>
</ul>
<p>Разумеется, при каждом обновлении массива D следует обновлять и значение в массиве P.</p>
<h2>Подробности реализации</h2>
<p>Создадим массив ID[1..N], в котором для каждой вершины будем хранить, какому множеству она принадлежит: 0 - если M<sub>2</sub> (т.е. расстояние равно бесконечности), 1 - если M<sub>1</sub> (т.е. вершина находится в очереди), и 2 - если M<sub>0</sub> (некоторый путь уже был найден, расстояние меньше бесконечности).</p>
<p>Очередь обработки можно реализовать стандартной структурой данных deque. Однако есть более эффективный способ. Во-первых, очевидно, в очереди в любой момент времени будет храниться максимум N элементов. Но, во-вторых, мы можем добавлять элементы и в начало, и в конец очереди. Следовательно, мы можем организовать очередь на массиве размера N, однако нужно зациклить его. Т.е. делаем массив Q[1..N], указатели (int) на первый элемент QH и на элемент после последнего QT. Очередь пуста, когда QH == QT. Добавление в конец - просто запись в Q[QT] и увеличение QT на 1; если QT после этого вышел за пределы очереди (QT == N), то делаем QT = 0. Добавление в начало очереди - уменьшаем QH на 1, если она вышла за пределы очереди (QH == -1), то делаем QH = N-1.</p>
<p>Сам алгоритм реализуем в точности по описанию выше.</p>
<h2>Асимптотика</h2>
<p>Мне не известна более-менее хорошая асимптотическая оценка этого алгоритма. Я встречал только оценку O (N M) у похожего алгоритма.</p>
<p>Однако на практике алгоритма зарекомендовал себя очень хорошо: время его работы я оцениваю как <b>O (M log N)</b>, хотя, повторюсь, это исключительно <b>экспериментальная</b> оценка.</p>
<h2>Реализация</h2>
<pre>typedef pair&lt;int,int> rib;
typedef vector &lt; vector&lt;rib> > graph;

const int inf = 1000*1000*1000;


int main()
{
	int n, v1, v2;
	graph g (n);

	... чтение графа ...

	vector&lt;int> d (n, inf);
	d[v1] = 0;
	vector&lt;int> id (n);
	deque&lt;int> q;
	q.push_back (v1);
	vector&lt;int> p (n, -1);

	while (!q.empty())
	{
		int v = q.front(),  q.pop_front();
		id[v] = 1;
		for (size_t i=0; i&lt;g[v].size(); ++i)
		{
			int to = g[v][i].first, len = g[v][i].second;
			if (d[to] > d[v] + len)
			{
				d[to] = d[v] + len;
				if (id[to] == 0)
					q.push_back (to);
				else if (id[to] == 1)
					q.push_front (to);
				p[to] = v;
				id[to] = 1;
			}
		}
	}

	... вывод результата ...

}</pre>
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>