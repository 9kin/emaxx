<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Поиск компонент сильной связности, построение конденсации графа</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 19:27<br>редактировано: 9 Jul 2009 18:24</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="strong_connected_components.html#" id="contents-hide">[скрыть]</a><a href="strong_connected_components.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Поиск компонент сильной связности, построение конденсации графа</h1><p><h2 style="padding-top:40px;">Определения, постановка задачи</h2><p>Дан ориентированный граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">, множество вершин которого <img class=tex src="../tex2png/cache/f4727a593e3ecb8bea258213a2ce0988.png" alt="V"> и множество рёбер &mdash; <img class=tex src="../tex2png/cache/75014114e5532780acf8715ec0ab6829.png" alt="E">. Петли и кратные рёбра допускаются. Обозначим через <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> количество вершин графа, через <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> &mdash; количество рёбер.<p><b>Компонентой сильной связности</b> (strongly connected component) называется такое (максимальное по включению) подмножество вершин <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C">, что любые две вершины этого подмножества достижимы друг из друга, т.е. для <img class=tex src="../tex2png/cache/c69756722f9cf4e3bf90209aa7de301e.png" alt="\forall u,v \in C">:<p class=formula><img class=tex src="../tex2png/cache/ec43a3ffcfe5f7301d5ed1c8768193de.png" alt=" u \mapsto v, v \mapsto u "></p>где символом <img class=tex src="../tex2png/cache/95e4120676efdca9c88aabdc1b1ab69d.png" alt="\mapsto"> здесь и далее мы будем обозначать достижимость, т.е. существование пути из первой вершины во вторую.<p>Понятно, что компоненты сильной связности для данного графа не пересекаются, т.е. фактически это разбиение всех вершин графа. Отсюда логично определение <b>конденсации</b> <img class=tex src="../tex2png/cache/e201c4980ef37e534679fb4c1770026f.png" alt="G^{\rm SCC}"> как графа, получаемого из данного графа сжатием каждой компоненты сильной связности в одну вершину. Каждой вершине графа конденсации соответствует компонента сильной связности графа <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">, а ориентированное ребро между двумя вершинами <img class=tex src="../tex2png/cache/5ff63044085d8ddaac6cf944b3b365e0.png" alt="C_i"> и <img class=tex src="../tex2png/cache/83a5c9615dfb31409b4b064c8b3b559b.png" alt="C_j"> графа конденсации проводится, если найдётся пара вершин <img class=tex src="../tex2png/cache/ebd5287cd277f2758d92b32e4769c8f1.png" alt="u \in C_i, v \in C_j">, между которыми существовало ребро в исходном графе, т.е. <img class=tex src="../tex2png/cache/193905ef76405d1ab4610c2e1004cb9e.png" alt="(u,v) \in E">.<p>Важнейшим свойством графа конденсации является то, что он <b>ацикличен</b>. Действительно, предположим, что <img class=tex src="../tex2png/cache/481c2fdd3aefc372687a6f717d1f7d6f.png" alt="C \mapsto C^\prime">, докажем, что <img class=tex src="../tex2png/cache/b2f55b2fb30b9841482a9dd595f4040f.png" alt="C^\prime \not\mapsto C">. Из определения конденсации получаем, что найдутся две вершины <img class=tex src="../tex2png/cache/37918fb73af429e34c7e1f647a278783.png" alt="u \in C"> и <img class=tex src="../tex2png/cache/62b6ea4adb356af9ffb6ae4d99a955ed.png" alt="v \in C^\prime">, что <img class=tex src="../tex2png/cache/7295bfd4ea7007ae8999c29e268aa78d.png" alt="u \mapsto v">. Доказывать будем от противного, т.е. предположим, что <img class=tex src="../tex2png/cache/96671f9c9c5c5e14e5c24fd8e3f31d9e.png" alt="C^\prime \mapsto C">, тогда найдутся две вершины <img class=tex src="../tex2png/cache/30992aa7f859cf7a92e77ae470c2eb1a.png" alt="u^\prime \in C"> и <img class=tex src="../tex2png/cache/9845b4cdc7ee4b72b496fa875b691f48.png" alt="v^\prime \in C^\prime">, что <img class=tex src="../tex2png/cache/7becf36a89af4e9c31922c6b98b9e031.png" alt="v^\prime \mapsto u^\prime">. Но т.к. <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> и <img class=tex src="../tex2png/cache/6382e9bda88b7e75ec88477f5a779d67.png" alt="u^\prime"> находятся в одной компоненте сильной связности, то между ними есть путь; аналогично для <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> и <img class=tex src="../tex2png/cache/ab97c9efb0fdd55f330e041b7b0ca02d.png" alt="v^\prime">. В итоге, объединяя пути, получаем, что <img class=tex src="../tex2png/cache/326a508ebbcc8466932e284f6abe73cc.png" alt="v \mapsto u">, и одновременно <img class=tex src="../tex2png/cache/7295bfd4ea7007ae8999c29e268aa78d.png" alt="u \mapsto v">. Следовательно, <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> и <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> должны принадлежать одной компоненте сильной связности, т.е. получили противоречие, что и требовалось доказать.<p>Описываемый ниже алгоритм выделяет в данном графе все компоненты сильной связности. Построить по ним граф конденсации не составит труда.<p><h2 style="padding-top:40px;">Алгоритм</h2><p>Описываемый здесь алгоритм был предложен независимо Косараю (Kosaraju) и Шариром (Sharir) в 1979 г. Это очень простой в реализации алгоритм, основанный на двух сериях <a href="dfs.html">поисков в глубину</a>, и потому работающий за время <img class=tex src="../tex2png/cache/d20d4ea468976eeb83adea753c1fd674.png" alt="O(n+m)">.<p><b>На первом шаге</b> алгоритма выполняется серия обходов в глубину, посещающая весь граф. Для этого мы проходимся по всем вершинам графа и из каждой ещё не посещённой вершины вызываем обход в глубину. При этом для каждой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> запомним <b>время выхода</b> <img class=tex src="../tex2png/cache/99b88c931b98a54e8722307984f4da07.png" alt="{\rm tout}[v]">. Эти времена выхода играют ключевую роль в алгоритме, и эта роль выражена в приведённой ниже теореме.<p>Сначала введём обозначение: время выхода <img class=tex src="../tex2png/cache/7b4e555e54cfe3524ad6b97eaf8aab98.png" alt="{\rm tout}[C]"> из компоненты <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C"> сильной связности определим как максимум из значений <img class=tex src="../tex2png/cache/99b88c931b98a54e8722307984f4da07.png" alt="{\rm tout}[v]"> для всех <img class=tex src="../tex2png/cache/a698c48b821d02d90cbbfe4db046dea2.png" alt="v \in C">. Кроме того, в доказательстве теоремы будут упоминаться и времена входа в каждую вершину <img class=tex src="../tex2png/cache/f9caafde0d5d355ebaee1bdd7e59d23a.png" alt="{\rm tin}[v]">, и аналогично определим времена входа <img class=tex src="../tex2png/cache/d8f8cb55fe3478a0a865e6e18ed11413.png" alt="{\rm tin}[C]"> для каждой компоненты сильной связности как минимум из величин <img class=tex src="../tex2png/cache/f9caafde0d5d355ebaee1bdd7e59d23a.png" alt="{\rm tin}[v]"> для всех <img class=tex src="../tex2png/cache/a698c48b821d02d90cbbfe4db046dea2.png" alt="v \in C">.<p><b>Теорема</b>. Пусть <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C"> и <img class=tex src="../tex2png/cache/62e58d00cddaed10b3396c29a13519f5.png" alt="C^\prime"> &mdash; две различные компоненты сильной связности, и пусть в графе конденсации между ними есть ребро <img class=tex src="../tex2png/cache/73014047927925cdd9d354c8e2331dfa.png" alt="(C,C^\prime)">. Тогда <img class=tex src="../tex2png/cache/a070b458218777148992a9ed4031e477.png" alt="{\rm tout}[C] > {\rm tout}[C^\prime]">.<p>При доказательстве возникает два принципиально различных случая в зависимости от того, в какую из компонент первой зайдёт обход в глубину, т.е. в зависимости от соотношения между <img class=tex src="../tex2png/cache/d8f8cb55fe3478a0a865e6e18ed11413.png" alt="{\rm tin}[C]"> и <img class=tex src="../tex2png/cache/90940e13b4c2c9df5ab68d455b2e3e14.png" alt="{\rm tin}[C^\prime]">:<p><ul><li>Первой была достигнута компонента <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C">. Это означает, что в какой-то момент времени обход в глубину заходит в некоторую вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> компоненты <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C">, при этом все остальные вершины компонент <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C"> и <img class=tex src="../tex2png/cache/62e58d00cddaed10b3396c29a13519f5.png" alt="C^\prime"> ещё не посещены. Но, т.к. по условию в графе конденсаций есть ребро <img class=tex src="../tex2png/cache/73014047927925cdd9d354c8e2331dfa.png" alt="(C,C^\prime)">, то из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> будет достижима не только вся компонента <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C">, но и вся компонента <img class=tex src="../tex2png/cache/62e58d00cddaed10b3396c29a13519f5.png" alt="C^\prime">. Это означает, что при запуске из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> обход в глубину пройдёт по всем вершинам компонент <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C"> и <img class=tex src="../tex2png/cache/62e58d00cddaed10b3396c29a13519f5.png" alt="C^\prime">, а, значит, они станут потомками по отношению к <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> в дереве обхода в глубину, т.е. для любой вершины <img class=tex src="../tex2png/cache/66e757a2b45f51062e8364c7ea5e6400.png" alt="u \in C \cup C^\prime, u \ne v"> будет выполнено <img class=tex src="../tex2png/cache/9a964e89ae58f9f72c671a2df4daa814.png" alt="{\rm tout}[v] > {\rm tout}[u]">, ч.т.д.<li>Первой была достигнута компонента <img class=tex src="../tex2png/cache/62e58d00cddaed10b3396c29a13519f5.png" alt="C^\prime">. Опять же, в какой-то момент времени обход в глубину заходит в некоторую вершину <img class=tex src="../tex2png/cache/62b6ea4adb356af9ffb6ae4d99a955ed.png" alt="v \in C^\prime">, причём все остальные вершины компонент <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C"> и <img class=tex src="../tex2png/cache/62e58d00cddaed10b3396c29a13519f5.png" alt="C^\prime"> не посещены. Поскольку по условию в графе конденсаций существовало ребро <img class=tex src="../tex2png/cache/73014047927925cdd9d354c8e2331dfa.png" alt="(C,C^\prime)">, то, вследствие ацикличности графа конденсаций, не существует обратного пути <img class=tex src="../tex2png/cache/b2f55b2fb30b9841482a9dd595f4040f.png" alt="C^\prime \not\mapsto C">, т.е. обход в глубину из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> не достигнет вершин <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C">. Это означает, что они будут посещены обходом в глубину позже, откуда и следует <img class=tex src="../tex2png/cache/a070b458218777148992a9ed4031e477.png" alt="{\rm tout}[C] > {\rm tout}[C^\prime]">, ч.т.д.</ul><p>Доказанная теорема является <b>основой алгоритма</b> поиска компонент сильной связности. Из неё следует, что любое ребро <img class=tex src="../tex2png/cache/73014047927925cdd9d354c8e2331dfa.png" alt="(C,C^\prime)"> в графе конденсаций идёт из компоненты с большей величиной <img class=tex src="../tex2png/cache/16ddb02fc85eb0efc5bcb1f251de51e0.png" alt="{\rm tout}"> в компоненту с меньшей величиной.<p>Если мы отсортируем все вершины <img class=tex src="../tex2png/cache/76f98369ddb598fa22c6a7410bd46455.png" alt="v \in V"> в порядке убывания времени выхода <img class=tex src="../tex2png/cache/99b88c931b98a54e8722307984f4da07.png" alt="{\rm tout}[v]">, то первой окажется некоторая вершина <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">, принадлежащая "корневой" компоненте сильной связности, т.е. в которую не входит ни одно ребро в графе конденсаций. Теперь нам хотелось бы запустить такой обход из этой вершины <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">, который бы посетил только эту компоненту сильной связности и не зашёл ни в какую другую; научившись это делать, мы сможем постепенно выделить все компоненты сильной связности: удалив из графа вершины первой выделенной компоненты, мы снова найдём среди оставшихся вершину с наибольшей величиной <img class=tex src="../tex2png/cache/16ddb02fc85eb0efc5bcb1f251de51e0.png" alt="{\rm tout}">, снова запустим из неё этот обход, и т.д.<p>Чтобы научиться делать такой обход, рассмотрим <b>транспонированный граф</b> <img class=tex src="../tex2png/cache/21b54bd962295e31dfddd771f24f360d.png" alt="G^T">, т.е. граф, полученный из <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> изменением направления каждого ребра на противоположное. Нетрудно понять, что в этом графе будут те же компоненты сильной связности, что и в исходном графе. Более того, граф конденсации <img class=tex src="../tex2png/cache/e11e1b9c2c0f2ce4a5da1c964427ae0f.png" alt="(G^T)^{\rm SCC}"> для него будет равен транспонированному графу конденсации исходного графа <img class=tex src="../tex2png/cache/e201c4980ef37e534679fb4c1770026f.png" alt="G^{\rm SCC}">. Это означает, что теперь из рассматриваемой нами "корневой" компоненты уже не будут выходить рёбра в другие компоненты.<p>Таким образом, чтобы обойти всю "корневую" компоненту сильной связности, содержащую некоторую вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, достаточно запустить обход из вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> в графе <img class=tex src="../tex2png/cache/21b54bd962295e31dfddd771f24f360d.png" alt="G^T">. Этот обход посетит все вершины этой компоненты сильной связности и только их. Как уже говорилось, дальше мы можем мысленно удалить эти вершины из графа, находить очередную вершину с максимальным значением <img class=tex src="../tex2png/cache/99b88c931b98a54e8722307984f4da07.png" alt="{\rm tout}[v]"> и запускать обход на транспонированном графе из неё, и т.д.<p>Итак, мы построили следующий <b>алгоритм</b> выделения компонент сильной связности:<p>1 шаг. Запустить серию обходов в глубину графа <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">, которая возвращает вершины в порядке увеличения времени выхода <img class=tex src="../tex2png/cache/16ddb02fc85eb0efc5bcb1f251de51e0.png" alt="{\rm tout}">, т.е. некоторый список <img class=tex src="../tex2png/cache/633452602455fba003c02b84d602f23c.png" alt="\rm order">.<p>2 шаг. Построить транспонированный граф <img class=tex src="../tex2png/cache/21b54bd962295e31dfddd771f24f360d.png" alt="G^T">. Запустить серию обходов в глубину/ширину этого графа в порядке, определяемом списком <img class=tex src="../tex2png/cache/633452602455fba003c02b84d602f23c.png" alt="\rm order"> (а именно, в обратном порядке, т.е. в порядке уменьшения времени выхода). Каждое множество вершин, достигнутое в результате очередного запуска обхода, и будет очередной компонентой сильной связности.<p><b>Асимптотика</b> алгоритма, очевидно, равна <img class=tex src="../tex2png/cache/d20d4ea468976eeb83adea753c1fd674.png" alt="O(n+m)">, поскольку он представляет собой всего лишь два обхода в глубину/ширину.<p>Наконец, уместно отметить связь с понятием <b><a href="topological_sort.html">топологической сортировки</b></a>. Во-первых, шаг 1 алгоритма представляет собой не что иное, как топологическую сортировку графа <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> (фактически именно это и означает сортировка вершин по времени выхода). Во-вторых, сама схема алгоритма такова, что и компоненты сильной связности он генерирует в порядке уменьшения их времён выхода, таким образом, он генерирует компоненты - вершины графа конденсации в порядке топологической сортировки.<p><h2 style="padding-top:40px;">Реализация</h2><p><pre class="notranslate cpp">vector <span class="sy1">&lt;</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> g, gr<span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span> used<span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> order, component<span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> dfs1 <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	used<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="br0">&#93;</span><span class="br0">&#41;</span>
			dfs1 <span class="br0">&#40;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	order.<span class="me1">push_back</span> <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> dfs2 <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	used<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
	component.<span class="me1">push_back</span> <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>gr<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span> gr<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="br0">&#93;</span><span class="br0">&#41;</span>
			dfs2 <span class="br0">&#40;</span>gr<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n<span class="sy4">;</span>
	... чтение n ...
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> a, b<span class="sy4">;</span>
		... чтение очередного ребра <span class="br0">&#40;</span>a,b<span class="br0">&#41;</span> ...
		<span class="me1">g</span><span class="br0">&#91;</span>a<span class="br0">&#93;</span>.<span class="me1">push_back</span> <span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="sy4">;</span>
		gr<span class="br0">&#91;</span>b<span class="br0">&#93;</span>.<span class="me1">push_back</span> <span class="br0">&#40;</span>a<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	used.<span class="me1">assign</span> <span class="br0">&#40;</span>n, <span class="kw2">false</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>
			dfs1 <span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>
	used.<span class="me1">assign</span> <span class="br0">&#40;</span>n, <span class="kw2">false</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> v <span class="sy1">=</span> order<span class="br0">&#91;</span>n<span class="sy2">-</span><span class="nu0">1</span><span class="sy2">-</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			dfs2 <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
			... вывод очередной component ...
			<span class="me1">component</span>.<span class="me1">clear</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Здесь в <img class=tex src="../tex2png/cache/74b332862718f9b2b1fcdedaa034d947.png" alt="\rm g"> хранится сам граф, а <img class=tex src="../tex2png/cache/0c2697992324946bca2a0e0cb210eb0d.png" alt="\rm gr"> &mdash; транспонированный граф. Функция <img class=tex src="../tex2png/cache/17e0ea0708bd251586a934b2c9843b43.png" alt="\rm dfs1"> выполняет обход в глубину на графе <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">, функция <img class=tex src="../tex2png/cache/ced33888dd0e467fbfdefb39a254e9de.png" alt="\rm dfs2"> &mdash; на транспонированном <img class=tex src="../tex2png/cache/21b54bd962295e31dfddd771f24f360d.png" alt="G^T">. Функция <img class=tex src="../tex2png/cache/17e0ea0708bd251586a934b2c9843b43.png" alt="\rm dfs1"> заполняет список <img class=tex src="../tex2png/cache/633452602455fba003c02b84d602f23c.png" alt="\rm order"> вершинами в порядке увеличения времени выхода (фактически, делает топологическую сортировку). Функция <img class=tex src="../tex2png/cache/ced33888dd0e467fbfdefb39a254e9de.png" alt="\rm dfs2"> сохраняет все достигнутые вершины в списке <img class=tex src="../tex2png/cache/ff515acf5d309448ee15a3fa92d0108c.png" alt="\rm component">, который после каждого запуска будет содержать очередную компоненту сильной связности.<p><h2 style="padding-top:40px;">Литература</h2><p><ul><li><a href="http://www.e-maxx-ru.1gb.ru/bookz/files/cormen.djvu">Томас Кормен, Чарльз Лейзерсон, Рональд Ривест, Клиффорд Штайн. <b>Алгоритмы: Построение и анализ</b> [2005]</a><li>M. Sharir. <b>A strong-connectivity algorithm and its applications in data-flow
analysis</b> [1979]</ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>