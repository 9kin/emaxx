<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Наименьший общий предок. Нахождение за O (log N) с препроцессингом O (N log N) (метод двоичного подъёма)</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 22:48<br>редактировано: 14 Mar 2012 2:09</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="lca_simpler.html#" id="contents-hide">[скрыть]</a><a href="lca_simpler.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Наименьший общий предок. Нахождение за O (log N) (метод двоичного подъёма)</h1>

<p>Пусть дано дерево G. На вход поступают запросы вида (V1, V2), для каждого запроса требуется найти их наименьшего общего предка, т.е. вершину V, которая лежит на пути от корня до V1, на пути от корня до V2, и из всех таких вершин следует выбирать самую нижнюю. Иными словами, искомая вершина V - предок и V1, и V2, и среди всех таких общих предков выбирается нижний. Очевидно, что наименьший общий предок вершин V1 и V2 - это их общий предок, лежащий на кратчайшем пути из V1 в V2. В частности, например, если V1 является предком V2, то V1 является их наименьшим общим предком.</p>
<p>На английском эта задача называется задачей LCA - Least Common Ancestor.</p>
<p>Здесь будет рассмотрен алгоритм, который пишется намного быстрее, чем описанный <a href="lca.html">здесь</a>.</p>
<p>Асимптотика полученного алгоритма будет равна: препроцессинг за <b>O (N log N)</b> и ответ на каждый запрос за <b>O (log N)</b>.</p>
<h2>Алгоритм</h2>
<p>Предпосчитаем для каждой вершины её 1-го предка, 2-го предка, 4-го, и т.д. Обозначим этот массив через P, т.е. P[i][j] - это 2<sup>j</sup>-й предок вершины i, i = 1..N, j = 0..&lceil;logN&rceil;. Также для каждой вершины найдём времена захода в неё и выхода поиска в глубину (см. <a href="dfs.html">"Поиск в глубину"</a>) - это нам понадобится, чтобы определять за O (1), является ли одна вершина предком другой (не обязательно непосредственным). Такой препроцессинг можно выполнить за <b>O (N log N)</b>.</p>
<p>Пусть теперь поступил очередной запрос - пара вершин (A,B). Сразу проверим, не является ли одна вершина предком другой - в таком случае она и является результатом. Если A не предок B, и B не предок A, то будем подниматься по предкам A, пока не найдём самую высокую (т.е. наиболее близкую к корню) вершину, которая ещё не является предком (не обязательно непосредственным) B (т.е. такую вершину X, что X не предок B, а P[X][0] - предок B). При этом находить эту вершину X будем за O (log N), пользуясь массивом P.</p>
<p>Опишем этот процесс подробнее. Пусть L = &lceil;logN&rceil;. Пусть сначала I = L. Если P[A][I] не является предком B, то присваиваем A = P[A][I], и уменьшаем I. Если же P[A][I] является предком B, то просто уменьшаем I. Очевидно, что когда I станет меньше нуля, вершина A как раз и будет являться искомой вершиной - т.е. такой, что A не предок B, но P[A][0] - предок B.</p>
<p>Теперь, очевидно, ответом на LCA будет являться P[A][0] - т.е. наименьшая вершина среди предков исходной вершины A, являющаяся также и предком B.</p>
<p>Асимптотика. Весь алгоритм ответа на запрос состоит из изменения I от L = &lceil;logN&rceil; до 0, а также проверки на каждом шаге за O(1), является ли одна вершина предком другой. Следовательно, на каждый запрос будет найден ответ за O (log N).</p>
<h2>Реализация</h2>
<pre>int n, l;
vector &lt; vector&lt;int> > g;
vector&lt;int> tin, tout;
int timer;
vector &lt; vector&lt;int> > up;

void dfs (int v, int p = 0) {
	tin[v] = ++timer;
	up[v][0] = p;
	for (int i=1; i&lt;=l; ++i)
		up[v][i] = up[up[v][i-1]][i-1];
	for (size_t i=0; i&lt;g[v].size(); ++i) {
		int to = g[v][i];
		if (to != p)
			dfs (to, v);
	}
	tout[v] = ++timer;
}

bool upper (int a, int b) {
	return tin[a] &lt;= tin[b] && tout[a] >= tout[b];
}

int lca (int a, int b) {
	if (upper (a, b))  return a;
	if (upper (b, a))  return b;
	for (int i=l; i>=0; --i)
		if (! upper (up[a][i], b))
			a = up[a][i];
	return up[a][0];
}

int main() {

	... чтение n и g ...

	tin.resize (n),  tout.resize (n),  up.resize (n);
	l = 1;
	while ((1&lt;&lt;l) &lt;= n)  ++l;
	for (int i=0; i&lt;n; ++i)  up[i].resize (l+1);
	dfs (0);

	for (;;) {
		int a, b; // текущий запрос
		int res = lca (a, b); // ответ на запрос
	}

}</pre><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>