<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Задача о назначениях. Венгерский алгоритм (алгоритм Куна)</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 22:59<br>редактировано: 23 Aug 2012 18:00</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="assignment_hungary.html#" id="contents-hide">[скрыть]</a><a href="assignment_hungary.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Венгерский алгоритм решения задачи о назначениях </h1><p><p><p><h2 style="padding-top:40px;"> Постановка задачи о назначениях </h2><p>Задача о назначениях ставится весьма естественно.<p>Приведём несколько <b>вариантов постановки</b> (как легко видеть, все они эквивалентны друг другу):<p><ul><p><li>Есть <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> рабочих и <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> заданий. Для каждого рабочего известно, сколько денег он запросит за выполнение того или иного задания. Каждый рабочий может взять себе только одно задание. Требуется распределить задания по рабочим так, чтобы минимизировать суммарные расходы.<p><li>Дана матрица <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> размера <img class=tex src="../tex2png/cache/0fc9328e33c84faad487e059a12d8e47.png" alt="n \times n">. Требуется в каждой её строке выбрать по одному числу так, чтобы в любом столбце также было выбрано ровно по одному числу, и при этом сумма выбранных чисел была бы минимальной.<p><li>Дана матрица <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> размера <img class=tex src="../tex2png/cache/0fc9328e33c84faad487e059a12d8e47.png" alt="n \times n">. Требуется найти такую перестановку <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, что величина <img class=tex src="../tex2png/cache/583910c3797ab54af5e6e95b6b9f6d34.png" alt="\sum a[i][p[i]]"> &mdash; минимальна.<p><li>Дан полный двудольный граф с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами; каждому ребру приписан некоторый вес. Требуется найти совершенное паросочетание минимального веса.<p></ul><p>Отметим, что все приведённые выше постановки "<b>квадратны</b>": в них обе размерности всегда совпадают (и равны <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">). На практике часто встречаются аналогичные "<b>прямоугольные</b>" постановки, когда <img class=tex src="../tex2png/cache/01f887f97a9342f12213f9fac05e40a2.png" alt="n \ne m">, и надо выбрать <img class=tex src="../tex2png/cache/d3dbdb62453aa770c0d223a23edfd07e.png" alt="\min(n,m)"> элементов. Впрочем, как легко заметить, от "прямоугольной" задачи всегда можно перейти к "квадратной", добавив строки/столбцы с нулевыми/бесконечными значениями соответственно.<p>Также заметим, что по аналогии с поиском <b>минимального</b> решения также можно ставить задачу поиска <b>максимального</b> решения. Впрочем, эти две задачи эквивалентны друг другу: достаточно все веса умножить на <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1">.<p><p><p><h2 style="padding-top:40px;"> Венгерский алгоритм </h2><p><p><h3 style="padding-top:15px;"> Историческая справка </h3><p>Алгоритм был разработан и опубликован Гарольдом <b>Куном</b> (Harold Kuhn) в 1955 г. Сам Кун дал алгоритму название "венгерский", потому что он был в значительной степени основан на более ранних работах двух венгерских математиков: Денеша <b>Кёнига</b> (D&#233;nes K&#337;nig) и Эйгена <b>Эгервари</b> (Jen&#337; Egerv&#225;ry).<p>В 1957 г. Джеймс <b>Манкрес</b> (James Munkres) показал, что этот алгоритм работает за (строго) полиномиальное время (т.е. за время порядка полинома от <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, не зависящего от величины стоимостей).<p>Поэтому в литературе данный алгоритм известен не только как "венгерский", но и как "алгоритм Куна-Манкреса" или "алгоритм Манкреса".<p>Впрочем, недавно (в 2006 г.) выяснилось, что точно такой же алгоритм был изобретён <b>за век до Куна</b> немецким математиком Карлом Густавом <b>Якоби</b> (Carl Gustav Jacobi). Дело в том, что его работа "About the research of the order of a system of arbitrary ordinary differential equations", напечатанная посмертно в 1890 г., содержавшая помимо прочих результатов и полиномиальный алгоритм решения задачи о назначениях, была написана на латыни, а её публикация <b>прошла незамеченной</b> среди математиков.<p>Также стоит отметить, что первоначальный алгоритм Куна имел асимптотику <img class=tex src="../tex2png/cache/022492c591829f1c0253baf809f9aeb3.png" alt="O(n^4)">, и лишь позже Джек <b>Эдмондс</b> (Jack Edmonds) и Ричард <b>Карп</b> (Richard Karp) (и независимо от них <b>Томидзава</b> (Tomizawa)) показали, каким образом улучшить его до асимптотики <img class=tex src="../tex2png/cache/5333bf52919bd2805f33a181851ebbf4.png" alt="O(n^3)">.<p><p><h3 style="padding-top:15px;"> Построение алгоритма за <img class=tex src="../tex2png/cache/528f2a9b7034622a521a5d07d1bab759.png" alt="O(n^4)"> </h3><p>Сразу отметим во избежание неоднозначностей, что мы в основном рассматриваем здесь задачу о назначениях в матричной постановке (т.е. дана матрица <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, и надо выбрать из неё <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> ячеек, находящихся в разных строках и столбцах). Индексацию массивов мы начинаем с единицы, т.е., например, матрица <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> имеет индексы <img class=tex src="../tex2png/cache/f96b2b23e071e674c843253fe4a24e0e.png" alt="a[1 \ldots n][1 \ldots n]">.<p>Также мы будем считать, что все числа в матрице <img class=tex src="../tex2png/cache/f9fa957c4ed546b728381d1556189238.png" alt="a[][]"> <b>неотрицательны</b> (если это не так, то всегда можно перейти к неотрицательной матрице, прибавив ко всем числам некоторое число).<p>Назовём <b>потенциалом</b> два произвольных массива чисел <img class=tex src="../tex2png/cache/2fbab67e91f739e953c0715a06df91e0.png" alt="u[1 \ldots n]"> и <img class=tex src="../tex2png/cache/6dd0d36ad50f2466f2fff0d1aa49264e.png" alt="v[1 \ldots n]"> таких, что выполняется условие:<p><p class=formula><img class=tex src="../tex2png/cache/8ce779ac0166a3bb19321dcf16010394.png" alt=" u[i] + v[j] \le a[i][j] ~~~~ (i = 1 \ldots n, ~~ [...]"></p><p>(Как видно, числа <img class=tex src="../tex2png/cache/cd28e725b18eb1910c6a957c98aac196.png" alt="u[i]"> соответствуют строкам, а числа <img class=tex src="../tex2png/cache/c48423f425bbabba1b9c75f585981c22.png" alt="v[j]"> &mdash; столбцам матрицы.)<p>Назовём <b>значением <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> потенциала</b> сумму его чисел:<p><p class=formula><img class=tex src="../tex2png/cache/9933d0c755175c095483e987f553ba04.png" alt=" f = \sum_{i=1}^n u[i] + \sum_{i=1}^n v[i]. "></p><p>С одной стороны, легко заметить, что стоимость искомого решения <img class=tex src="../tex2png/cache/fcb411f756eaf486a4032d88078a49a6.png" alt="sol"> <b>не меньше</b> значения любого потенциала:<p><p class=formula><img class=tex src="../tex2png/cache/2c130a06e6213272f951e803fa54a364.png" alt=" sol \ge f. "></p><p>(Доказательство. Искомое решение задачи представляет из себя <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> ячеек матрицы, и для каждой из них выполняется условие <img class=tex src="../tex2png/cache/97e2f215e65b229363bf265c8ffa2391.png" alt="u[i] + v[j] \le a[i][j]">. Поскольку все элементы находятся в разных строках и столбцах, то, суммируя эти неравенства по всем выбранным <img class=tex src="../tex2png/cache/60cf76e819ed3733bf887dc748d4b3ef.png" alt="a[i][j]">, в левой части неравенства получаем <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f">, а в правой &mdash; <img class=tex src="../tex2png/cache/fcb411f756eaf486a4032d88078a49a6.png" alt="sol">, что и требовалось доказать.)<p>С другой стороны, оказывается, что всегда существует решение и потенциал, на которых это неравенство <b>обращается в равенство</b>. Венгерский алгоритм, описанный ниже, будет конструктивным доказательством этого факта. Пока же лишь обратим внимание на то, что если какое-либо решение имеет стоимость, равную по величине какому-либо потенциалу, то это решение &mdash; <b>оптимально</b>.<p>Зафиксируем некоторый потенциал. Назовём ребро <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)"> <b>жёстким</b>, если выполняется:<p><p class=formula><img class=tex src="../tex2png/cache/63c373d65586ead3e1cec8fbf406e3cb.png" alt=" u[i] + v[j] = a[i][j]. "></p><p>Вспомним об альтернативной постановке задачи о назначениях, с помощью двудольного графа. Обозначим через <img class=tex src="../tex2png/cache/6bdb95cd9c9cf2e6e2c25ed807acfc09.png" alt="H"> двудольный граф, составленный только из жёстких рёбер. Фактически, венгерский алгоритм поддерживает для текущего потенциала <b>максимальное по количеству рёбер паросочетание <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"></b> графа <img class=tex src="../tex2png/cache/6bdb95cd9c9cf2e6e2c25ed807acfc09.png" alt="H">: и как только это паросочетание станет содержать <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> рёбер, рёбра этого паросочетания и будут являться искомым оптимальным решением (ведь это будет решение, стоимость которого совпадает с величиной потенциала).<p>Перейдём непосредственно к <b>описанию алгоритма</b>.<p><ul><p><li>В начале алгоритма потенциал полагается равным нулю <img class=tex src="../tex2png/cache/7ccc3040dcd904355c246bc084b57ad1.png" alt="u[i] = v[i] = 0">, и паросочетание <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> полагается пустым.<p><li>Далее, на каждом шаге алгоритма мы пытаемся, не меняя потенциала, увеличить мощность текущего паросочетания <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> на единицу (напоминаем, паросочетание ищется в графе жёстких рёбер <img class=tex src="../tex2png/cache/6bdb95cd9c9cf2e6e2c25ed807acfc09.png" alt="H">).<p>Для этого фактически используется обычный <a href="kuhn_matching.html">алгоритм Куна поиска максимального паросочетания в двудольных графах</a>. Напомним здесь этот алгоритм.<p>Все рёбра паросочетания <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> ориентируются по направлению от второй доли к первой, все остальные рёбра графа <img class=tex src="../tex2png/cache/6bdb95cd9c9cf2e6e2c25ed807acfc09.png" alt="H"> ориентируются в противоположную сторону.<p>Напомним (из терминологии поиска паросочетаний), что вершина называется насыщенной, если ей смежно ребро из текущего паросочетания. Вершина, которой не смежно ни одно ребро из текущего паросочетания, называется ненасыщенной. Путь нечётной длины, в котором первое ребро не принадлежит паросочетанию, а для всех последующих рёбер происходит чередование (принадлежит/не принадлежит) &mdash; называется увеличивающим путём.<p>Из всех ненасыщенных вершин первой доли запускается обход <a href="dfs.html">в глубину</a>/<a href="bfs.html">в ширину</a>. Если в результате обхода удалось достигнуть ненасыщенной вершины второй доли, то это означает, что мы нашли увеличивающий путь из первой доли во вторую. Если прочередовать рёбра вдоль этого пути (т.е. первое ребро включить в паросочетание, второе исключить, третье включить, и т.д.), то тем самым мы увеличим мощность паросочетания на единицу.<p>Если же увеличивающего пути не было, то это означает, что текущее паросочетание <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> &mdash; максимально в графе <img class=tex src="../tex2png/cache/6bdb95cd9c9cf2e6e2c25ed807acfc09.png" alt="H">, поэтому в таком случае переходим к следующему пункту.<p><li>Если на текущем шаге не удалось увеличить мощность текущего паросочетания, то производится некий пересчёт потенциала таким образом, чтобы на следующих шагах появилось больше возможностей для увеличения паросочетания.<p>Обозначим через <img class=tex src="../tex2png/cache/8581eafb88ed483506028706543a75ea.png" alt="Z_1"> множество вершин первой доли, которые были посещены обходом алгоритма Куна при попытке поиска увеличивающей цепи; через <img class=tex src="../tex2png/cache/8faced0db4a3576460707aeb2fcbb665.png" alt="Z_2"> &mdash; множество посещённых вершин второй доли.<p>Посчитаем величину <img class=tex src="../tex2png/cache/b10959d13d437bdf88c1a3c489e71f65.png" alt="\Delta">:<p><p class=formula><img class=tex src="../tex2png/cache/a830e36d03f40f69f341cb720012ff9f.png" alt=" \Delta = \min_{i \in Z_1, j \notin Z_2} \{ a[i][j[...]"></p><p>Эта величина строго положительна.<p>(Доказательство. Предположим, что <img class=tex src="../tex2png/cache/7c587d4c0c0914cc882b3b22a95eed3a.png" alt="\Delta = 0">. Тогда существует жёсткое ребро <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)">, причём <img class=tex src="../tex2png/cache/1d7e0dab4c6244a40f6d6ab09eddce1b.png" alt="i \in Z_1"> и <img class=tex src="../tex2png/cache/806335c3397ca98ccaf076e84c935958.png" alt="j \notin Z_2">. Из этого следует, что ребро <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)"> должно было быть ориентированным от второй доли к первой, т.е. это жёсткое ребро <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)"> должно входить в паросочетание <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M">. Однако это невозможно, т.к. мы не могли попасть в насыщенную вершину <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, кроме как пройдя по ребру из <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> в <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">. Пришли к противоречию, значит, <img class=tex src="../tex2png/cache/a3156b1a0f82f506489937dd31e03674.png" alt="\Delta > 0">.)<p>Теперь <b>пересчитаем потенциал</b> таким образом: для всех вершин <img class=tex src="../tex2png/cache/1d7e0dab4c6244a40f6d6ab09eddce1b.png" alt="i \in Z_1"> сделаем <img class=tex src="../tex2png/cache/66f481f1e37e768724fc668c53ce39b8.png" alt="u[i] += \Delta">, а для всех вершин <img class=tex src="../tex2png/cache/b919a9395036363ff0cd53d8f3cf23c1.png" alt="j \in Z_2"> &mdash; сделаем <img class=tex src="../tex2png/cache/302b4aac9df8b9f6fe5685876d4557e6.png" alt="v[j] -= \Delta">. Получившийся потенциал по-прежнему останется корректным потенциалом.<p>(Доказательство. Для этого надо показать, что по-прежнему для всех <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> выполняется: <img class=tex src="../tex2png/cache/97e2f215e65b229363bf265c8ffa2391.png" alt="u[i] + v[j] \le a[i][j]">. Для случаев, когда <img class=tex src="../tex2png/cache/3a3d08817d51be93ae70397db70d2528.png" alt="i \in Z_1 \& j \in Z_2"> или <img class=tex src="../tex2png/cache/d3bbab224899da2a0d43a6598d6f6f00.png" alt="i \notin Z_1 \& j \notin Z_2"> &mdash; это так, поскольку для них сумма <img class=tex src="../tex2png/cache/cd28e725b18eb1910c6a957c98aac196.png" alt="u[i]"> и <img class=tex src="../tex2png/cache/c48423f425bbabba1b9c75f585981c22.png" alt="v[j]"> не изменилась. Когда <img class=tex src="../tex2png/cache/8785d2ea58fb129425664c466fade838.png" alt="i \notin Z_1 \& j \in Z_2"> &mdash; неравенство только усилилось. Наконец, для случая <img class=tex src="../tex2png/cache/4c7e149b24372fb94e075593ce7ffce7.png" alt="i \in Z_1 \& j \notin Z_2"> &mdash; хотя левая часть неравенства и увеличивается, неравенство всё равно сохраняется, поскольку величина <img class=tex src="../tex2png/cache/b10959d13d437bdf88c1a3c489e71f65.png" alt="\Delta">, как видно по её определению &mdash; это как раз максимальное увеличение, не приводящее к нарушению неравенства.)<p>Кроме того, старое паросочетание <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> из жёстких рёбер можно будет оставить, т.е. все рёбра паросочетания останутся жёсткими.<p>(Доказательство. Чтобы некоторое жёсткое ребро <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)"> перестало быть жёстким в результате изменения потенциала, надо, чтобы равенство <img class=tex src="../tex2png/cache/8fb3939c5bdfdf0c5061722f131029b2.png" alt="u[i] + v[j] = a[i][j]"> превратилось в неравенство <img class=tex src="../tex2png/cache/66c04d4056d077d159ec5904a8c75943.png" alt="u[i] + v[j] < a[i][j]">. Однако левая часть могла уменьшиться только в одном случае: когда <img class=tex src="../tex2png/cache/8785d2ea58fb129425664c466fade838.png" alt="i \notin Z_1 \& j \in Z_2">. Но раз <img class=tex src="../tex2png/cache/e8e3ca4f7c942a2ce43ae799cf80dc05.png" alt="i \notin Z_1">, то это означает, что ребро <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)"> не могло быть ребром паросочетания, что и требовалось доказать.)<p>Наконец, чтобы показать, что изменения потенциала <b>не могут происходить бесконечно</b>, заметим, что при каждом таком изменении потенциала количество вершин, достижимых обходом, т.е. <img class=tex src="../tex2png/cache/a84ae54e3d3139882546641a4628606e.png" alt="|Z_1|+|Z_2|">, строго увеличивается. (При этом нельзя утверждать, что увеличивается количество жёстких рёбер.)<p>(Доказательство. Во-первых, любая вершина, которая была достижимой, достижимой и останется. В самом деле, если некоторая вершина достижима, то до неё есть некоторый путь из достижимых вершин, начинающийся в ненасыщенной вершине первой доли; а поскольку для рёбер вида <img class=tex src="../tex2png/cache/3adef15da6f42e75a2a5183a2c2cc537.png" alt="(i,j), i \in Z_1 \& j \in Z_2"> сумма <img class=tex src="../tex2png/cache/9f29f96c077c338dfa064e202adec6de.png" alt="u[i] + v[j]"> не меняется, то весь этот путь сохранится и после изменения потенциала, что и требовалось доказать. Во-вторых, покажем, что в результате пересчёта потенциала появилась хотя бы одна новая достижимая вершина. Но это почти очевидно, если вернуться к определению <img class=tex src="../tex2png/cache/b10959d13d437bdf88c1a3c489e71f65.png" alt="\Delta">: то ребро <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)">, на котором был достигнут минимум, теперь станет жёстким, а, значит, вершина <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> станет достижимой благодаря этому ребру и вершине <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">.)<p>Таким образом, всего может происходить не более <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> пересчётов потенциала, прежде чем обнаружится увеличивающая цепочка и мощность паросочетания <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M"> будет увеличена.<p></ul><p>Таким образом, рано или поздно будет найден потенциал, которому соответствует совершенное паросочетание <img class=tex src="../tex2png/cache/1cd011e00eb4014fe99892f5ffbf5abd.png" alt="M">, являющееся ответом на задачу.<p>Если говорить об <b>асимптотике</b> алгоритма, то она составляет <img class=tex src="../tex2png/cache/022492c591829f1c0253baf809f9aeb3.png" alt="O(n^4)">, поскольку всего должно произойти <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> увеличений паросочетания, перед каждым из которых происходит не более <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> пересчётов потенциала, каждый из которых выполняется за время <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)">.<p>Реализацию за <img class=tex src="../tex2png/cache/022492c591829f1c0253baf809f9aeb3.png" alt="O(n^4)"> мы здесь приводить не будем, поскольку она всё равно получится не короче, чем описанная ниже реализация за <img class=tex src="../tex2png/cache/5333bf52919bd2805f33a181851ebbf4.png" alt="O(n^3)">.<p><p><h3 style="padding-top:15px;"> Построение алгоритма за <img class=tex src="../tex2png/cache/d533acd79daf7af976fc1c3bd2c80972.png" alt="O(n^3)"> (<img class=tex src="../tex2png/cache/44a06896e54f97eb48c159a80e76e58c.png" alt="O(n^2 m)">) </h3><p>Научимся теперь реализовывать тот же алгоритм за асимптотику <img class=tex src="../tex2png/cache/ee6e2ce73ecd60d80d4fa8f04d0691e9.png" alt="O (n^3)"> (для прямоугольных задач <img class=tex src="../tex2png/cache/ed0e13f7024ff254a4fccd689fe21ad3.png" alt="n \times m"> &mdash; <img class=tex src="../tex2png/cache/1367a77a36eaa4ae982770b23acfa231.png" alt="O(n^2 m)">).<p>Ключевая идея: теперь мы будем <b>добавлять в рассмотрение строки матрицы одну за одной</b>, а не рассматривать их все сразу. Таким образом, описанный выше алгоритм примет вид:<p><ul><p><li>Добавляем в рассмотрение очередную строку матрицы <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">.<p><li>Пока нет увеличивающей цепи, начинающейся в этой строке, пересчитываем потенциал.<p><li>Как только появляется увеличивающая цепь, чередуем паросочетание вдоль неё (включая тем самым последнюю строку в паросочетание), и переходим к началу (к рассмотрению следующей строки).<p></ul><p>Чтобы достичь требуемой асимптотики, надо реализовать шаги 2-3, выполняющиеся для каждой строки матрицы, за время <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)"> (для прямоугольных задач &mdash; за <img class=tex src="../tex2png/cache/a6b2398465a599d7b0ac3127f16f0244.png" alt="O (n m)">).<p>Для этого мы вспомним два факта, доказанных нами выше:<p><ul><p><li>При изменении потенциала вершины, которые были достижимы обходом Куна, достижимыми и останутся.<p><li>Всего могло произойти лишь <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> пересчётов потенциала, прежде чем будет найдена увеличивающая цепь.<p></ul><p>Отсюда вытекают <b>ключевые идеи</b>, позволяющие достичь требуемой асимптотики:<p><ul><p><li>Для проверки наличия увеличивающей цепочки нет необходимости запускать обход Куна заново после каждого пересчёта потенциала. Вместо этого можно оформить обход Куна в <b>итеративном</b> виде: после каждого пересчёта потенциала мы просматриваем добавившиеся жёсткие рёбра и, если их левые концы были достижимыми, помечаем их правые концы также как достижимые и продолжаем обход из них.<p><li>Развивая эту идею дальше, можно прийти к такому представлению алгоритма: это цикл, на каждом шаге которого сначала пересчитывается потенциал, затем находится столбец, ставший достижимым (а таковой всегда найдётся, поскольку после пересчёта потенциала всегда появляются новые достижимые вершины), и если этот столбец был ненасыщен, то найдена увеличивающая цепь, а если столбец был насыщен &mdash; то соответствующая ему в паросочетании строка также становится достижимой.<p>Теперь алгоритм принимает вид: цикл добавления столбцов, на каждом из которых сначала пересчитывается потенциал, а затем какой-то новый столбец помечается как достижимый.<p><li>Чтобы быстро пересчитывать потенциал (быстрее, чем наивный вариант за <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)">), надо поддерживать вспомогательные минимумы по каждому из столбцов <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">:<p><p class=formula><img class=tex src="../tex2png/cache/44e454827e0493a0a8abf5ec8f3ac35e.png" alt=" minv[j] = \min_{i \in Z_1} \{ a[i][j] - u[i] - v[[...]"></p><p>Как легко видеть, искомая величина <img class=tex src="../tex2png/cache/b10959d13d437bdf88c1a3c489e71f65.png" alt="\Delta"> выражается через них следующим образом:<p><p class=formula><img class=tex src="../tex2png/cache/02b60881aa840b6ec02359d8274236e4.png" alt=" \Delta = \min_{j \notin Z_2} \{ minv[j] \}. "></p><p>Таким образом, нахождение <img class=tex src="../tex2png/cache/b10959d13d437bdf88c1a3c489e71f65.png" alt="\Delta"> теперь можно произвести за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">.<p>Поддерживать этот массив <img class=tex src="../tex2png/cache/f3744f78adf3ac1b9fef978299fd373a.png" alt="minv[]"> необходимо при появлении новых посещённых строк. Это, очевидно, можно сделать за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> на одну добавляемую строку (что в сумме даст <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)">). Также обновлять массив <img class=tex src="../tex2png/cache/f3744f78adf3ac1b9fef978299fd373a.png" alt="minv[]"> надо при пересчёте потенциала, что также делается за время <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> на один пересчёт потенциала (поскольку <img class=tex src="../tex2png/cache/f3744f78adf3ac1b9fef978299fd373a.png" alt="minv[]"> меняется только для недостигнутых пока столбцов: а именно, уменьшается на <img class=tex src="../tex2png/cache/b10959d13d437bdf88c1a3c489e71f65.png" alt="\Delta">).<p></ul><p>Таким образом, алгоритм принимает такой вид: во внешнем цикле мы добавляем в рассмотрение строки матрицы одну за другой. Каждая строка обрабатывается за время <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)">, поскольку при этом могло происходить лишь <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> пересчётов потенциала (каждый &mdash; за время <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">), для чего за время <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)"> поддерживается массив <img class=tex src="../tex2png/cache/f3744f78adf3ac1b9fef978299fd373a.png" alt="minv[]">; алгоритм Куна суммарно отработает за время <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)"> (поскольку он представлен в форме <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> итераций, на каждой из которых посещается новый столбец).<p>Итоговая асимптотика составляет <img class=tex src="../tex2png/cache/5333bf52919bd2805f33a181851ebbf4.png" alt="O(n^3)"> &mdash; или, если задача прямоугольна, <img class=tex src="../tex2png/cache/1367a77a36eaa4ae982770b23acfa231.png" alt="O(n^2 m)">.<p><p><h3 style="padding-top:15px;"> Реализация венгерского алгоритма за <img class=tex src="../tex2png/cache/d533acd79daf7af976fc1c3bd2c80972.png" alt="O(n^3)"> (<img class=tex src="../tex2png/cache/44a06896e54f97eb48c159a80e76e58c.png" alt="O(n^2 m)">) </h3><p>Приведённая реализация фактически была разработана <b>Андреем Лопатиным</b> несколько лет назад. Её отличает удивительная лаконичность: весь алгоритм помещается в <b>30 строк кода</b>.<p>Данная реализация ищет решение для прямоугольной входной матрицы <img class=tex src="../tex2png/cache/09dcd007fbaa7eb8214a97da31111b6e.png" alt="a[1 \ldots n][1 \ldots m]">, где <img class=tex src="../tex2png/cache/e74dff4a9144fa64ff2439e7d93569d4.png" alt="n \le m">. Матрица хранится в <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1">-индексации в целях удобства и краткости кода. Дело в том, что в данной реализации вводятся фиктивные нулевая строка и нулевой столбец, что позволяет написать многие циклы в общем виде, без дополнительных проверок.<p>Массивы <img class=tex src="../tex2png/cache/b270af0639c354a858e5c93d72e26203.png" alt="u[0 \ldots n]"> и <img class=tex src="../tex2png/cache/57dca9c64639c50f47cde004c38110ae.png" alt="v[0 \ldots m]"> хранят потенциал. Изначально он нулевой, что верно для матрицы, состоящей из нуля строк. (Отметим, что для данной реализации не важно, имеются или нет в матрице <img class=tex src="../tex2png/cache/f9fa957c4ed546b728381d1556189238.png" alt="a[][]"> отрицательные числа.)<p>Массив <img class=tex src="../tex2png/cache/b2a359b41b74b71d7d9e148f4b93c204.png" alt="p[0 \ldots m] "> содержит паросочетание: для каждого столбца <img class=tex src="../tex2png/cache/70c979fc74671374cbb4d4d3ee24bbb8.png" alt="i = 1 \ldots m"> он хранит номер соответствующей выбранной строки <img class=tex src="../tex2png/cache/6fa33a48f7fff7f52d08a07ab012145a.png" alt="p[i]"> (или <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0">, если пока ничего не выбрано). При этом <img class=tex src="../tex2png/cache/13298d26b66ed695fab4fc3fc1f1dbd0.png" alt="p[0]"> для удобства реализации полагается равным номеру текущей рассматриваемой строки.<p>Массив <img class=tex src="../tex2png/cache/e7d4052cc17fd4e4dfbd0c60c3da089f.png" alt="minv[1 \ldots m]"> содержит для каждого столбца <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> вспомогательные минимумы, необходимые для быстрого пересчёта потенциала:<p><p class=formula><img class=tex src="../tex2png/cache/44e454827e0493a0a8abf5ec8f3ac35e.png" alt=" minv[j] = \min_{i \in Z_1} \{ a[i][j] - u[i] - v[[...]"></p><p>Массив <img class=tex src="../tex2png/cache/1b4705a8a827e27daa0974fc84194f24.png" alt="way[1 \ldots m]"> содержит информацию о том, где эти минимумы достигаются, чтобы мы впоследствии смогли восстановить увеличивающую цепочку. На первый взгляд кажется, что в массиве <img class=tex src="../tex2png/cache/9a43520326ae4b6e0a73868a8fb9ca1c.png" alt="way[]"> для каждого столбца надо хранить номер строки, а также завести ещё один массив: для каждой строки запомнить номер столбца, из которого мы в неё пришли. Однако вместо этого можно заметить, что алгоритм Куна всегда попадает в строки, проходя по ребру паросочетания из столбцов, поэтому номера строк для восстановления цепочки всегда можно взять из паросочетания (т.е. из массива <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]">). Таким образом, <img class=tex src="../tex2png/cache/ea2d97b0c731f44bd839c23cbf0d5da1.png" alt="way[j]"> для каждого столбца <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> содержит номер предшествующего столбца (или <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0">, если такого нет).<p>Сам алгоритм представляет из себя внешний <b>цикл по строкам матрицы</b>, внутри которого происходит добавление в рассмотрение <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой строки матрицы. Внутренняя часть представляет собой цикл "do-while (p[j0] != 0)", который работает, пока не будет найден свободный столбец <img class=tex src="../tex2png/cache/3025f60429c295c868b0b57a0083b44d.png" alt="j0">. Каждая итерация цикла помечает посещённым новый столбец с номером <img class=tex src="../tex2png/cache/3025f60429c295c868b0b57a0083b44d.png" alt="j0"> (посчитанным на прошлой итерации; а изначально равным нулю &mdash; т.е. стартуем мы с фиктивного столбца), а также новую строку <img class=tex src="../tex2png/cache/6ea82403fb1533bdf61eef0f2aed682d.png" alt="i0"> &mdash; смежную ему в паросочетании (т.е. <img class=tex src="../tex2png/cache/efcb77fdb5edc6962d7ea5a726096ced.png" alt="p[j0]">; а изначально при <img class=tex src="../tex2png/cache/c73425032b7d3842daa7202e67cc1d1a.png" alt="j0=0"> берётся <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ая строка). Из-за появления новой посещённой строки <img class=tex src="../tex2png/cache/6ea82403fb1533bdf61eef0f2aed682d.png" alt="i0"> нужно соответствующим образом пересчитать массив <img class=tex src="../tex2png/cache/f3744f78adf3ac1b9fef978299fd373a.png" alt="minv[]">, заодно мы находим минимум в нём &mdash; величину <img class=tex src="../tex2png/cache/b77ec0822727f4093b9d5fb9be6b18dd.png" alt="delta">, и в каком столбце <img class=tex src="../tex2png/cache/e855a163990687379b5b635125f68011.png" alt="j1"> этот минимум был достигнут (заметим, что при такой реализации <img class=tex src="../tex2png/cache/b77ec0822727f4093b9d5fb9be6b18dd.png" alt="delta"> могло оказаться равной нулю, что означает, что на текущем шаге потенциал можно не менять: новый достижимый столбец есть и без того). После этого производится пересчёт потенциала <img class=tex src="../tex2png/cache/de9eb494d50dffa3110fdf349ef9eccd.png" alt="u[], v[]">, соответствующее изменение массива <img class=tex src="../tex2png/cache/f3744f78adf3ac1b9fef978299fd373a.png" alt="minv[]">. По окончании цикла "do-while" мы нашли увеличивающую цепочку, оканчивающуюся в столбце <img class=tex src="../tex2png/cache/3025f60429c295c868b0b57a0083b44d.png" alt="j0">, "раскрутить" которую можно, пользуясь массивом предков <img class=tex src="../tex2png/cache/9a43520326ae4b6e0a73868a8fb9ca1c.png" alt="way[]">.<p>Константа <img class=tex src="../tex2png/cache/cc70289d7180b24262c58c3c6942aea7.png" alt="INF"> &mdash; это "бесконечность", т.е. некоторое число, заведомо большее всех возможных чисел во входной матрице <img class=tex src="../tex2png/cache/f9fa957c4ed546b728381d1556189238.png" alt="a[][]">.<p><pre class="notranslate cpp">vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> u <span class="br0">&#40;</span>n<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span>, v <span class="br0">&#40;</span>m<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span>, p <span class="br0">&#40;</span>m<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span>, way <span class="br0">&#40;</span>m<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;=</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	p<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
	<span class="kw4">int</span> j0 <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> minv <span class="br0">&#40;</span>m<span class="sy2">+</span><span class="nu0">1</span>, INF<span class="br0">&#41;</span><span class="sy4">;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span> used <span class="br0">&#40;</span>m<span class="sy2">+</span><span class="nu0">1</span>, <span class="kw2">false</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">do</span> <span class="br0">&#123;</span>
		used<span class="br0">&#91;</span>j0<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
		<span class="kw4">int</span> i0 <span class="sy1">=</span> p<span class="br0">&#91;</span>j0<span class="br0">&#93;</span>,  delta <span class="sy1">=</span> INF,  j1<span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> j<span class="sy1">&lt;=</span>m<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				<span class="kw4">int</span> cur <span class="sy1">=</span> a<span class="br0">&#91;</span>i0<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="sy2">-</span>u<span class="br0">&#91;</span>i0<span class="br0">&#93;</span><span class="sy2">-</span>v<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="sy4">;</span>
				<span class="kw1">if</span> <span class="br0">&#40;</span>cur <span class="sy1">&lt;</span> minv<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span>
					minv<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> cur,  way<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> j0<span class="sy4">;</span>
				<span class="kw1">if</span> <span class="br0">&#40;</span>minv<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">&lt;</span> delta<span class="br0">&#41;</span>
					delta <span class="sy1">=</span> minv<span class="br0">&#91;</span>j<span class="br0">&#93;</span>,  j1 <span class="sy1">=</span> j<span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;=</span>m<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>used<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span>
				u<span class="br0">&#91;</span>p<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> delta,  v<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy2">-</span><span class="sy1">=</span> delta<span class="sy4">;</span>
			<span class="kw1">else</span>
				minv<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy2">-</span><span class="sy1">=</span> delta<span class="sy4">;</span>
		j0 <span class="sy1">=</span> j1<span class="sy4">;</span>
	<span class="br0">&#125;</span> <span class="kw1">while</span> <span class="br0">&#40;</span>p<span class="br0">&#91;</span>j0<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">do</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> j1 <span class="sy1">=</span> way<span class="br0">&#91;</span>j0<span class="br0">&#93;</span><span class="sy4">;</span>
		p<span class="br0">&#91;</span>j0<span class="br0">&#93;</span> <span class="sy1">=</span> p<span class="br0">&#91;</span>j1<span class="br0">&#93;</span><span class="sy4">;</span>
		j0 <span class="sy1">=</span> j1<span class="sy4">;</span>
	<span class="br0">&#125;</span> <span class="kw1">while</span> <span class="br0">&#40;</span>j0<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Восстановление ответа в более привычной форме, т.е. нахождение для каждой строки <img class=tex src="../tex2png/cache/1cf0d52047c38a1a3bbeab42c2de96a3.png" alt="i = 1 \ldots n"> номера выбранного в ней столбца <img class=tex src="../tex2png/cache/cf7dd0b7b747cbca77cf263d4c24d4dc.png" alt="ans[i]">, делается следующим образом:<p><pre class="notranslate cpp">vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> ans <span class="br0">&#40;</span>n<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> j<span class="sy1">&lt;=</span>m<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
	ans<span class="br0">&#91;</span>p<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> j<span class="sy4">;</span></pre><p>Стоимость найденного паросочетания можно просто взять как потенциал нулевого столбца (взятый с противоположным знаком). В самом деле, как легко проследить по коду, <img class=tex src="../tex2png/cache/82be62460c2574dc42b1827b1db870cc.png" alt="-v[0]"> содержит в себе сумму всех величин <img class=tex src="../tex2png/cache/b77ec0822727f4093b9d5fb9be6b18dd.png" alt="delta">, т.е. суммарное изменение потенциала. Хотя при каждом изменении потенциала изменяться могли сразу несколько величин <img class=tex src="../tex2png/cache/cd28e725b18eb1910c6a957c98aac196.png" alt="u[i]"> и <img class=tex src="../tex2png/cache/c48423f425bbabba1b9c75f585981c22.png" alt="v[j]">, суммарное изменение величины потенциала в точности равно <img class=tex src="../tex2png/cache/b77ec0822727f4093b9d5fb9be6b18dd.png" alt="delta">, поскольку пока нет увеличивающей цепи, число достижимых строк ровно на единицу больше числа достижимых столбцов (только текущая строка <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> не имеет себе "пары" в виде посещённого столбца):<p><pre class="notranslate cpp"><span class="kw4">int</span> cost <span class="sy1">=</span> <span class="sy2">-</span>v<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="sy4">;</span></pre><p><p><h2 style="padding-top:40px;"> Примеры задач </h2><p>Приведём здесь несколько примеров на решение задачи о назначениях: начиная от совсем тривиальных, и заканчивая менее очевидными задачами:<p><ul><p><li>Дан двудольный граф, требуется найти в нём паросочетание <b>максимальное паросочетание минимального веса</b> (т.е. в первую очередь максимизируется размер паросочетания, во вторую &mdash; минимизируется его стоимость).<p>Для решения просто строим задачу о назначениях, ставя на месте отсутствующих рёбер число "бесконечность". После этого решаем задачу венгерским алгоритмом, и удаляем из ответа рёбра бесконечного веса (они могли войти в ответ, если у задачи нет решения в виде совершенного паросочетания).<p><li>Дан двудольный граф, требуется найти в нём паросочетание <b>максимальное паросочетание максимального веса</b>.<p>Решение опять же очевидно, только все веса надо умножить на минус единицу (либо в венгерском алгоритме заменить все минимумы на максимумы, а бесконечности &mdash; на минус бесконечности).<p><li>Задача <b>детектирования движущихся объектов по снимкам</b>: было произведено два снимка, по итогам которых было получено два набор координат. Требуется соотнести объекты на первом и втором снимке, т.е. определить для каждой точки второго снимка, какой точке первого снимка она соответствовала. При этом требуется минимизировать сумму расстояний между сопоставленными точками (т.е. мы ищем решение, в котором объекты суммарно прошли наименьший путь).<p>Для решения мы просто строим и решаем задачу о назначениях, где в качестве весов рёбер выступают евклидовы расстояния между точками.<p><li>Задача <b>детектирования движущихся объектов по локаторам</b>: есть два локатора, которые умеют определять не положение объекта в пространстве, а лишь направление на него. С обоих локаторов (расположенных в различных точках) поступила информация в виде <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> таких направлений. Требуется определить положение объектов, т.е. определить предполагаемые положения объектов и соответствующие им пары направлений так, чтобы минимизировать сумму расстояний от объектов до лучей-направлений.<p>Решение &mdash; опять же, просто строим и решаем задачу о назначениях, где вершинами первой доли являются <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> направлений с первого локатора, вершинами второй доли &mdash; <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> направлений со второго локатора, а весами рёбер &mdash; расстояния между соответствующими лучами.<p><li>Покрытие <b>ориентированного ациклического графа путями</b>: дан ориентированный ациклический граф, требуется найти наименьшее число путей (при равенстве &mdash; с наименьшим суммарным весом), чтобы каждая вершина графа лежала бы ровно в одном пути.<p>Решение &mdash; построить по данному графу соответствующий двудольный граф, и найти в нём максимальное паросочетание минимального веса. Более подробно см. <a href="path_cover.html">отдельную статью</a>.<p><li><b>Раскраска дерева</b>. Дано дерево, в котором каждая вершина, кроме листьев, имеет ровно <img class=tex src="../tex2png/cache/658627816b5be3d0859b8d0d52d03fd5.png" alt="k-1"> сыновей. Требуется выбрать для каждой вершины некоторый цвет из <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> цветов так, чтобы никакие две смежные вершины не имели одинакового цвета. Кроме того, для каждой вершины и каждого цвета известна стоимость покраски этой вершины в этот цвет, и требуется минимизировать суммарную стоимость.<p>Для решения воспользуемся методом динамического программирования. А именно, научимся считать величину <img class=tex src="../tex2png/cache/3ac11c592874cc6f4c7eee0c16e5a83c.png" alt="d[v][c]">, где <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> &mdash; номер вершины, <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> &mdash; номер цвета, а само значение <img class=tex src="../tex2png/cache/3ac11c592874cc6f4c7eee0c16e5a83c.png" alt="d[v][c]"> &mdash; это минимальная стоимость раскраски вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> вместе с её потомками, причём сама вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> имеет цвет <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">. Чтобы посчитать такую величину <img class=tex src="../tex2png/cache/3ac11c592874cc6f4c7eee0c16e5a83c.png" alt="d[v][c]">, надо распределить остальные <img class=tex src="../tex2png/cache/658627816b5be3d0859b8d0d52d03fd5.png" alt="k-1"> цветов по сыновьям вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, а для этого надо построить и решить задачу о назначениях (в которой вершины одной доли &mdash; цвета, вершины другой доли &mdash; вершины-сыновья, а веса рёбер &mdash; это значения соответствующих динамик <img class=tex src="../tex2png/cache/2108d8213526c488460c3eb1fe11c115.png" alt="d[][]">).<p>Таким образом, каждая величина <img class=tex src="../tex2png/cache/3ac11c592874cc6f4c7eee0c16e5a83c.png" alt="d[v][c]"> считается с помощью решения задачи о назначениях, что в итоге даёт асимптотику <img class=tex src="../tex2png/cache/62aa29e9dd6db85a2191ef28ecfada3c.png" alt="O(n k^4)">.<p><li>Если в задаче о назначениях веса заданы не у рёбер, а у вершин, причём только <b>у вершин одной доли</b>, то можно обойтись без венгерского алгоритма, а достаточно лишь отсортировать вершины по весу и запустить обычный <a href="kuhn_matching.html">алгоритм Куна</a> (более подробно см. <a href="vertex_weighted_matching.html">отдельную статью</a>).<p><li>Рассмотрим следующий <b>частный случай</b>. Пусть каждой вершине первой доли приписано некоторое число <img class=tex src="../tex2png/cache/a705844feefe6f1f381c626ecc93aed7.png" alt="\alpha[i]">, а каждой вершине второй доли &mdash; <img class=tex src="../tex2png/cache/fec94b56ca50adb9422d832e419c31d8.png" alt="\beta[j]">. Пусть вес любого ребра <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)"> равен <img class=tex src="../tex2png/cache/b06138c6525c48ed81f9b6cea5cd8751.png" alt="\alpha[i] \cdot \beta[j]"> (числа <img class=tex src="../tex2png/cache/a705844feefe6f1f381c626ecc93aed7.png" alt="\alpha[i]"> и <img class=tex src="../tex2png/cache/fec94b56ca50adb9422d832e419c31d8.png" alt="\beta[j]"> нам известны). Решить задачу о назначениях.<p>Для решения без венгерского алгоритма рассмотрим сначала случай, когда в обеих долях по две вершины. В этом случае, как нетрудно убедиться, выгодно соединять вершины в обратном порядке: вершину с меньшей <img class=tex src="../tex2png/cache/a705844feefe6f1f381c626ecc93aed7.png" alt="\alpha[i]"> соединить с вершиной с большей <img class=tex src="../tex2png/cache/fec94b56ca50adb9422d832e419c31d8.png" alt="\beta[j]">. Это правило легко обобщить на произвольное количество вершин: надо отсортировать вершины первой доли в порядке увеличения <img class=tex src="../tex2png/cache/a705844feefe6f1f381c626ecc93aed7.png" alt="\alpha[i]">, второй доли &mdash; в порядке уменьшения <img class=tex src="../tex2png/cache/fec94b56ca50adb9422d832e419c31d8.png" alt="\beta[j]">, и соединять вершины попарно в таком порядке. Таким образом, мы получаем решение с асимптотикой <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">.<p><li><b>Задача о потенциалах</b>. Дана матрица <img class=tex src="../tex2png/cache/09dcd007fbaa7eb8214a97da31111b6e.png" alt="a[1 \ldots n][1 \ldots m]">. Требуется найти два массива <img class=tex src="../tex2png/cache/2fbab67e91f739e953c0715a06df91e0.png" alt="u[1 \ldots n]"> и <img class=tex src="../tex2png/cache/bfc368487fe4be46fc3694ac29af777b.png" alt="v[1 \ldots m]"> такие, что для любых <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> выполняется <img class=tex src="../tex2png/cache/97e2f215e65b229363bf265c8ffa2391.png" alt="u[i] + v[j] \le a[i][j]">, но при этом сумма элементов массивов <img class=tex src="../tex2png/cache/df09cae95940e511f8d96cbe8d9ad6b7.png" alt="u[]"> и <img class=tex src="../tex2png/cache/1aa48326c6d9b7ed1aca626b3c52c100.png" alt="v[]"> максимальна.<p>Зная венгерский алгоритм, решение этой задачи не составит никакого труда: венгерский алгоритм как раз находит именно такой потенциал <img class=tex src="../tex2png/cache/de9eb494d50dffa3110fdf349ef9eccd.png" alt="u[], v[]">, который удовлетворяет условию задачи. С другой стороны, без знания венгерского алгоритма решить такую задачу представляется почти невозможным.<p></ul><p><p><p><h2 style="padding-top:40px;"> Литература </h2><p><ul><p><li><a href="../bookz/files/ahuja_flows.djvu">Ravindra Ahuja, Thomas Magnanti, James Orlin. <b>Network Flows</b> [1993]</a><li>Harold Kuhn. <b>The Hungarian Method for the Assignment Problem</b> [1955]<li>James Munkres. <b>Algorithms for Assignment and Transportation Problems</b> [1957]</ul><p><p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Список задач на решение задачи о назначениях:<p><ul><p><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1687">UVA #10746 <b>"Crime Wave – The Sequel"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><p><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1829">UVA #10888 <b>"Warehouse"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p><li><a href="http://acm.sgu.ru/problem.php?contest=0&problem=210">SGU #210 <b>"Beloved Sons"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p><li><a href="http://livearchive.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1277">UVA #3276 <b>"The Great Wall Game"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: высокая]</a><p><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1237">UVA #10296 <b>"Jogging Trails"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: высокая]</a><p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>