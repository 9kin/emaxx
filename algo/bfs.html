<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Поиск в ширину в графе и его приложения</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 19:17<br>редактировано: 25 May 2012 14:18</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="bfs.html#" id="contents-hide">[скрыть]</a><a href="bfs.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Поиск в ширину </h1><p>Поиск в ширину (обход в ширину, breadth-first search) &mdash; это один из основных алгоритмов на графах.<p>В результате поиска в ширину находится путь кратчайшей длины в невзвешенном графе, т.е. путь, содержащий наименьшее число рёбер.<p>Алгоритм работает за <img class=tex src="../tex2png/cache/ee018e7d5a8d6095dc6cd39658989d5b.png" alt="O (n+m)">, где <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> &mdash; число вершин, <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> &mdash; число рёбер.<p><p><h2 style="padding-top:40px;"> Описание алгоритма </h2><p>На вход алгоритма подаётся заданный граф (невзвешенный), и номер стартовой вершины <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">. Граф может быть как ориентированным, так и неориентированным, для алгоритма это не важно.<p>Сам алгоритм можно понимать как процесс "поджигания" графа: на нулевом шаге поджигаем только вершину <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">. На каждом следующем шаге огонь с каждой уже горящей вершины перекидывается на всех её соседей; т.е. за одну итерацию алгоритма происходит расширение "кольца огня" в ширину на единицу (отсюда и название алгоритма).<p>Более строго это можно представить следующим образом. Создадим очередь <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q">, в которую будут помещаться горящие вершины, а также заведём булевский массив <img class=tex src="../tex2png/cache/6dc2b892307ecd0144800faa123f2de9.png" alt="\rm used[]">, в котором для каждой вершины будем отмечать, горит она уже или нет (или иными словами, была ли она посещена).<p>Изначально в очередь помещается только вершина <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, и <img class=tex src="../tex2png/cache/d9dd6d03358cdc8a7145f96ffaaf32a0.png" alt="\rm used[s] = true">, а для всех остальных вершин <img class=tex src="../tex2png/cache/293fb04a9f90f3e44bc9818848ae9ec7.png" alt="\rm used[] = false">. Затем алгоритм представляет собой цикл: пока очередь не пуста, достать из её головы одну вершину, просмотреть все рёбра, исходящие из этой вершины, и если какие-то из просмотренных вершин ещё не горят, то поджечь их и поместить в конец очереди.<p>В итоге, когда очередь опустеет, обход в ширину обойдёт все достижимые из <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> вершины, причём до каждой дойдёт кратчайшим путём. Также можно посчитать длины кратчайших путей (для чего просто надо завести массив длин путей <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]">), и компактно сохранить информацию, достаточную для восстановления всех этих кратчайших путей (для этого надо завести массив "предков" <img class=tex src="../tex2png/cache/f41743bb1304c4dfaee1474862f9de80.png" alt="p[]">, в котором для каждой вершины хранить номер вершины, по которой мы попали в эту вершину).<p><p><h2 style="padding-top:40px;"> Реализация </h2><p>Реализуем вышеописанный алгоритм на языке C++.<p>Входные данные:<p><pre class="notranslate cpp">&nbsp;
vector <span class="sy1">&lt;</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> g<span class="sy4">;</span> <span class="co1">// граф</span>
<span class="kw4">int</span> n<span class="sy4">;</span> <span class="co1">// число вершин</span>
<span class="kw4">int</span> s<span class="sy4">;</span> <span class="co1">// стартовая вершина (вершины везде нумеруются с нуля)</span>
&nbsp;
<span class="co1">// чтение графа</span>
...</pre><p>Сам обход:<p><pre class="notranslate cpp">&nbsp;
queue<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> q<span class="sy4">;</span>
q.<span class="me1">push</span> <span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">bool</span><span class="sy1">&gt;</span> used <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> d <span class="br0">&#40;</span>n<span class="br0">&#41;</span>, p <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
used<span class="br0">&#91;</span>s<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
p<span class="br0">&#91;</span>s<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy3">!</span>q.<span class="me1">empty</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> v <span class="sy1">=</span> q.<span class="me1">front</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	q.<span class="me1">pop</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> to <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			used<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
			q.<span class="me1">push</span> <span class="br0">&#40;</span>to<span class="br0">&#41;</span><span class="sy4">;</span>
			d<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
			p<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Если теперь надо восстановить и вывести кратчайший путь до какой-то вершины <img class=tex src="../tex2png/cache/f7896bcdbeaef5c80849d97eecb4b8bb.png" alt="\rm to">, это можно сделать следующим образом:<p><pre class="notranslate cpp">&nbsp;
<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span>
	<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;No path!&quot;</span><span class="sy4">;</span>
<span class="kw1">else</span> <span class="br0">&#123;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> path<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="sy1">=</span>to<span class="sy4">;</span> v<span class="sy3">!</span><span class="sy1">=</span><span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> v<span class="sy1">=</span>p<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span>
		path.<span class="me1">push_back</span> <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
	reverse <span class="br0">&#40;</span>path.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, path.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;Path: &quot;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>path.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> path<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">+</span> <span class="nu0">1</span> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot; &quot;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h2 style="padding-top:40px;"> Приложения алгоритма </h2><p><ul><p><li>Поиск <b>кратчайшего пути</b> в невзвешенном графе.<p><li>Поиск <b>компонент связности</b> в графе за <img class=tex src="../tex2png/cache/d20d4ea468976eeb83adea753c1fd674.png" alt="O(n+m)">.<p>Для этого мы просто запускаем обход в ширину от каждой вершины, за исключением вершин, оставшихся посещёнными (<img class=tex src="../tex2png/cache/111b4bcea96a54334bdccf611236fe84.png" alt="\rm used=true">) после предыдущих запусков. Таким образом, мы выполняем обычный запуск в ширину от каждой вершины, но не обнуляем каждый раз массив <img class=tex src="../tex2png/cache/6dc2b892307ecd0144800faa123f2de9.png" alt="\rm used[]">, за счёт чего мы каждый раз будем обходить новую компоненту связности, а суммарное время работы алгоритма составит по-прежнему <img class=tex src="../tex2png/cache/d20d4ea468976eeb83adea753c1fd674.png" alt="O(n+m)"> (такие несколько запусков обхода на графе без обнуления массива <img class=tex src="../tex2png/cache/4ecdf68925044e45b2fd890bdbbe9ef5.png" alt="\rm used"> называются серией обходов в ширину).<p><li>Нахождения решения какой-либо задачи (игры) <b>с наименьшим числом ходов</b>, если каждое состояние системы можно представить вершиной графа, а переходы из одного состояния в другое &mdash; рёбрами графа.<p>Классический пример &mdash; игра, где робот двигается по полю, при этом он может передвигать ящики, находящиеся на этом же поле, и требуется за наименьшее число ходов передвинуть ящики в требуемые позиции. Решается это обходом в ширину по графу, где состоянием (вершиной) является набор координат: координаты робота, и координаты всех коробок.<p><li>Нахождение кратчайшего пути в <b>0-1-графе</b> (т.е. графе взвешенном, но с весами равными только 0 либо 1): достаточно немного модифицировать поиск в ширину: если текущее ребро нулевого веса, и происходит улучшение расстояния до какой-то вершины, то эту вершину добавляем не в конец, а в начало очереди.<p><li>Нахождение <b>кратчайшего цикла</b> в ориентированном невзвешенном графе: производим поиск в ширину из каждой вершины; как только в процессе обхода мы пытаемся пойти из текущей вершины по какому-то ребру в уже посещённую вершину, то это означает, что мы нашли кратчайший цикл, и останавливаем обход в ширину; среди всех таких найденных циклов (по одному от каждого запуска обхода) выбираем кратчайший.<p><li>Найти все рёбра, лежащие <b>на каком-либо кратчайшем пути</b> между заданной парой вершин <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)">. Для этого надо запустить 2 поиска в ширину: из <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, и из <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">. Обозначим через <img class=tex src="../tex2png/cache/584a16e790c5f051338a0d5e54bcfb82.png" alt="d_a[]"> массив кратчайших расстояний, полученный в результате первого обхода, а через <img class=tex src="../tex2png/cache/299cd0e4edd6c252e705bef81b7d9a29.png" alt="d_b[]"> &mdash; в результате второго обхода. Теперь для любого ребра <img class=tex src="../tex2png/cache/00e36d5afb42bb0ea9cc0e95d95c50da.png" alt="(u,v)"> легко проверить, лежит ли он на каком-либо кратчайшем пути: критерием будет условие <img class=tex src="../tex2png/cache/44a52471ac387a794be35fe9738d2a9b.png" alt="d_a[u] + 1 + d_b[v] = d_a[b]">.<p><li>Найти все вершины, лежащие <b>на каком-либо кратчайшем пути</b> между заданной парой вершин <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)">. Для этого надо запустить 2 поиска в ширину: из <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, и из <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">. Обозначим через <img class=tex src="../tex2png/cache/584a16e790c5f051338a0d5e54bcfb82.png" alt="d_a[]"> массив кратчайших расстояний, полученный в результате первого обхода, а через <img class=tex src="../tex2png/cache/299cd0e4edd6c252e705bef81b7d9a29.png" alt="d_b[]"> &mdash; в результате второго обхода. Теперь для любой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> легко проверить, лежит ли он на каком-либо кратчайшем пути: критерием будет условие <img class=tex src="../tex2png/cache/42a3f030d44f997116d096fcb46e440d.png" alt="d_a[v] + d_b[v] = d_a[b]">.<p><li>Найти <b>кратчайший чётный путь</b> в графе (т.е. путь чётной длины). Для этого надо построить вспомогательный граф, вершинами которого будут состояния <img class=tex src="../tex2png/cache/5a5cc161c081abd04b4bf978827a3880.png" alt="(v,c)">, где <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> &mdash; номер текущей вершины, <img class=tex src="../tex2png/cache/0b97b07742e485417e464b229c0845c0.png" alt="c = 0 \ldots 1"> &mdash; текущая чётность. Любое ребро <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> исходного графа в этом новом графе превратится в два ребра <img class=tex src="../tex2png/cache/68e523c8c4d7710148d9b41a8f9ffe27.png" alt="((u,0),(v,1))"> и <img class=tex src="../tex2png/cache/350287a54d60fe09405d40ee8a830e2f.png" alt="((u,1),(v,0))">. После этого на этом графе надо обходом в ширину найти кратчайший путь из стартовой вершины в конечную, с чётностью, равной 0.<p></ul><p><p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Список задач, которые можно сдать, используя обход в ширину:<p><ul><p><li><a href="http://acm.sgu.ru/problem.php?contest=0&problem=213">SGU #213 <b>"Strong Defence"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>