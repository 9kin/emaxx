<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Бинарное возведение в степень</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 16:41<br>редактировано: 3 May 2012 2:34</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="binary_pow.html#" id="contents-hide">[скрыть]</a><a href="binary_pow.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Бинарное возведение в степень </h1><p><p>Бинарное (двоичное) возведение в степень &mdash; это приём, позволяющий возводить любое число в <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">-ую степень за <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)"> умножений (вместо <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> умножений при обычном подходе).<p>Более того, описываемый здесь приём применим к любой <b>ассоциативной</b> операции, а не только к умножению чисел. Напомним, операция называется ассоциативной, если для любых <img class=tex src="../tex2png/cache/ecf2de9b5d0f4a800ecb5a458e60f7a8.png" alt="a, b, c"> выполняется:<p class=formula><img class=tex src="../tex2png/cache/b8e3f11e93822d31fc2b1bf60c224126.png" alt=" (a \cdot b) \cdot c = a \cdot (b \cdot c) "></p><p>Наиболее очевидное обобщение &mdash; на остатки по некоторому модулю (очевидно, ассоциативность сохраняется). Следующим по "популярности" является обобщение на произведение матриц (его ассоциативность общеизвестна).<p><p><p><h2 style="padding-top:40px;"> Алгоритм </h2><p>Заметим, что для любого числа <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <b>чётного</b> числа <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> выполнимо очевидное тождество (следующее из ассоциативности операции умножения):<p class=formula><img class=tex src="../tex2png/cache/82360a5dc48289ddf14d6589879dbef1.png" alt=" a^n = (a^{n/2})^2 = a^{n/2} \cdot a^{n/2} "></p>Оно и является основным в методе бинарного возведения в степень. Действительно, для чётного <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> мы показали, как, потратив всего одну операцию умножения, можно свести задачу к вдвое меньшей степени.<p>Осталось понять, что делать, если степень <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> <b>нечётна</b>. Здесь мы поступаем очень просто: перейдём к степени <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">, которая будет уже чётной:<p class=formula><img class=tex src="../tex2png/cache/8cb386d7a53b020558ae14581907021a.png" alt=" a^n = a^{n-1} \cdot a "></p><p>Итак, мы фактически нашли рекуррентную формулу: от степени <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> мы переходим, если она чётна, к <img class=tex src="../tex2png/cache/48b1c5206b1d914c2ec894c9078c06ca.png" alt="n/2">, а иначе &mdash; к <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">. Понятно, что всего будет не более <img class=tex src="../tex2png/cache/10e8b1d7e97df47a2ab729ed2d412927.png" alt="2 \log n"> переходов, прежде чем мы придём к <img class=tex src="../tex2png/cache/a3eccfd00c4f9140f971a5f52d712db1.png" alt="n = 0"> (базе рекуррентной формулы). Таким образом, мы получили алгоритм, работающий за <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> умножений.<p><p><p><h2 style="padding-top:40px;"> Реализация </h2><p>Простейшая рекурсивная реализация:<p><pre class="notranslate cpp"><span class="kw4">int</span> binpow <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> n<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>n <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>n <span class="sy2">%</span> <span class="nu0">2</span> <span class="sy1">==</span> <span class="nu0">1</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> binpow <span class="br0">&#40;</span>a, n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy2">*</span> a<span class="sy4">;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> b <span class="sy1">=</span> binpow <span class="br0">&#40;</span>a, n<span class="sy2">/</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">return</span> b <span class="sy2">*</span> b<span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Нерекурсивная реализация, также оптимизированная (деления на 2 заменены битовыми операциями):<p><pre class="notranslate cpp"><span class="kw4">int</span> binpow <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> n<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> res <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>n<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>n <span class="sy3">&amp;</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			res <span class="sy2">*</span><span class="sy1">=</span> a<span class="sy4">;</span>
			<span class="sy2">--</span>n<span class="sy4">;</span>
		<span class="br0">&#125;</span>
		<span class="kw1">else</span> <span class="br0">&#123;</span>
			a <span class="sy2">*</span><span class="sy1">=</span> a<span class="sy4">;</span>
			n <span class="sy1">&gt;&gt;=</span> <span class="nu0">1</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="kw1">return</span> res<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Эту реализацию можно ещё несколько упростить, заметив, что возведение <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> в квадрат осуществляется всегда, независимо от того, сработало условие нечётности <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> или нет:<p><pre class="notranslate cpp"><span class="kw4">int</span> binpow <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> n<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> res <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>n<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>n <span class="sy3">&amp;</span> <span class="nu0">1</span><span class="br0">&#41;</span>
			res <span class="sy2">*</span><span class="sy1">=</span> a<span class="sy4">;</span>
		a <span class="sy2">*</span><span class="sy1">=</span> a<span class="sy4">;</span>
		n <span class="sy1">&gt;&gt;=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> res<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Наконец, стоит отметить, что бинарное возведение в степень уже реализовано в языке Java, но только для класса длинной арифметики BigInteger (функция pow этого класса работает именно по алгоритму бинарного возведения).<p><p><p><h2 style="padding-top:40px;"> Примеры решения задач </h2><p><p><h3 style="padding-top:15px;"> Эффективное вычисление чисел Фибоначчи </h3><p><b>Условие</b>. Дано число <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Требуется вычислить <img class=tex src="../tex2png/cache/7dcd6b01c7bd079818d4c4c37d4a511a.png" alt="F_n">, где <img class=tex src="../tex2png/cache/6f20aa15b643326c3c95219518f4e2a4.png" alt="F_i"> &mdash; <a href="fibonacci_numbers.html">последовательность чисел Фибоначчи</a>.<p><b>Решение</b>. Более подробно это решение описано в <a href="fibonacci_numbers.html">статье о последовательности Фибоначчи</a>. Здесь же мы лишь кратко приведём суть этого решения.<p>Основная идея следующая. Вычисление очередного числа Фибоначчи основывается на знании двух предыдущих чисел Фибоначчи: а именно, каждое следующее число Фибоначчи получается как сумма двух предыдущих. Это означает, что мы можем построить матрицу <img class=tex src="../tex2png/cache/3a68c8aa5b4e3ec95fb589df27386a92.png" alt="2 \times 2">, которая будет соответствовать этому преобразованию: как по двум числам Фибоначчи <img class=tex src="../tex2png/cache/6f20aa15b643326c3c95219518f4e2a4.png" alt="F_i"> и <img class=tex src="../tex2png/cache/6966865d75f1ffefb6557fb0bbe466db.png" alt="F_{i+1}"> вычислить следующее число, т.е. перейти к паре <img class=tex src="../tex2png/cache/6966865d75f1ffefb6557fb0bbe466db.png" alt="F_{i+1}">, <img class=tex src="../tex2png/cache/6db1c7751cbd4f308cb546fecb294409.png" alt="F_{i+2}">. Например, применяя это преобразование <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> раз к паре <img class=tex src="../tex2png/cache/fc9d8805dc1ef76ee59cac2703222e9a.png" alt="F_0"> и <img class=tex src="../tex2png/cache/726660d2baf5e074ca3df566ef434b68.png" alt="F_1">, мы получим пару <img class=tex src="../tex2png/cache/7dcd6b01c7bd079818d4c4c37d4a511a.png" alt="F_n"> и <img class=tex src="../tex2png/cache/77fa1a35e8111fa6498a4345fb0f5dbc.png" alt="F_{n+1}">. Таким образом, возведя матрицу этого преобразования в <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">-ую степень, мы тем самым найдём искомое <img class=tex src="../tex2png/cache/7dcd6b01c7bd079818d4c4c37d4a511a.png" alt="F_n"> за время <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">, что нам и требовалось.<p><p><h3 style="padding-top:15px;"> Возведение перестановки в <img class=tex src="../tex2png/cache/336a051837a2ed662422914225a362d0.png" alt="k">-ую степень </h3><p><b>Условие</b>. Дана перестановка <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Требуется возвести её в <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ую степень, т.е. найти, что получится, если к тождественной перестановке <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> раз применить перестановку <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">.<p><b>Решение</b>. Просто применим к перестановке <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> описанный выше алгоритм бинарного возведения в степень. Никаких отличий по сравнению с возведением чисел в степень &mdash; нет. Решение получается с асимптотикой <img class=tex src="../tex2png/cache/a8770007d7bdb23d5616ac746b0f45ad.png" alt="O (n \log k)">.<p>(Примечание. Данную задачу можно решить и более эффективно, <b>за линейное время</b>. Для этого достаточно выделить в перестановке все циклы, после чего рассмотреть по отдельности каждый цикл и, взяв <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> по модулю длины текущего цикла, найти ответ для этого цикла.)<p><p><h3 style="padding-top:15px;"> Быстрое применение набора геометрических операций к точкам </h3><p><b>Условие</b>. Даны <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> точек <img class=tex src="../tex2png/cache/b98bee3099688d9f0572adb2ffa3ff68.png" alt="p_i">, и даны <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> преобразований, которые надо применить к каждой из этих точек. Каждое преобразование &mdash; это либо сдвиг на заданный вектор, либо масштабирование (умножение координат на заданные коэффициенты), либо вращение вокруг заданной оси на заданный угол. Кроме того, имеется составная операция циклического повторения: она имеет вид "повторить заданное число раз заданный список преобразований" (операции циклического повторения могут вкладываться друг в друга).<p>Требуется вычислить результат применения указанных операций ко всем точкам (эффективно, т.е. за время, меньшее чем <img class=tex src="../tex2png/cache/984e62335c9742933f82f75ea815b4e4.png" alt="O(n \cdot length)">, где <img class=tex src="../tex2png/cache/665fbf9b89314460d16047185a4d83cb.png" alt="length"> &mdash; общее количество операций, которые необходимо сделать).<p><b>Решение</b>. Посмотрим на разные виды преобразований с точки зрения того, как они изменяют координаты:<p><ul><p><li>Операция сдвига &mdash; она просто прибавляет ко всем координатам единицу, домноженную на некоторые константы.<p><li>Операция масштабирования &mdash; она умножает каждую координату на некоторую константу.<p><li>Операция вращения вокруг оси &mdash; её можно представить следующим образом: новые получаемые координаты можно записать как линейную комбинацию старых.<p>(Мы не будем здесь уточнять, каким образом это производится. Например, можно для простоты представить это в виде комбинации пяти двумерных поворотов: сначала в плоскостях <img class=tex src="../tex2png/cache/77343242e5324226d97c7b5ee6f7cf6a.png" alt="OXY"> и <img class=tex src="../tex2png/cache/150a8be2aacb21e464fadf490e8adc71.png" alt="OXZ"> так, чтобы ось вращения совпала с положительным направлением оси <img class=tex src="../tex2png/cache/bab569f88c9ce0dab231f852ba017d11.png" alt="OX">, затем требуемый поворот вокруг оси в плоскости <img class=tex src="../tex2png/cache/d206a78d7cd189d8b4dfe107605b05ae.png" alt="YZ">, затем обратные повороты в плоскостях <img class=tex src="../tex2png/cache/150a8be2aacb21e464fadf490e8adc71.png" alt="OXZ"> и <img class=tex src="../tex2png/cache/77343242e5324226d97c7b5ee6f7cf6a.png" alt="OXY"> так, чтобы ось вращения вернулась в своё исходное положение.)<p></ul><p>Как легко видеть, каждое из этих преобразований &mdash; это пересчёт координат по линейным формулам. Таким образом, любое такое преобразование можно записать в виде матрицы <img class=tex src="../tex2png/cache/65eae3d8d7ea49c97ff7c2a0c574a319.png" alt="4 \times 4">:<p><p class=formula><img class=tex src="../tex2png/cache/20e0877eb39d2dfcd4c409be5febd39f.png" alt=" \begin{pmatrix}
a_11 & a_{12} & a_{13} & a_{14} [...]"></p><p>которое при умножении (слева) на строку из старых координат и константы-единицы даёт строку из новых координат и константы-единицы:<p><p class=formula><img class=tex src="../tex2png/cache/aea76b845cc5812749cfbfc78384d807.png" alt=" \begin{pmatrix} x & y & z & 1 \end{pmatrix} \cdot[...]"></p><p>(Почему понадобилось вводить фиктивную четвёртую координату, всегда равную единице? Без этого не получилось бы реализовать операцию сдвига: ведь сдвиг &mdash; это как раз прибавление к координатам единицы, домноженной на некоторые коэффициенты. Без фиктивной единицы мы бы смогли только реализовывать линейные комбинации самих координат, а прибавлять к ним заданные константы &mdash; не смогли бы.)<p>Теперь решение задачи становится почти тривиальным. Раз каждая элементарная операция описывается матрицей, то последовательность операций описывается произведением этих матриц, а операция циклического повторения &mdash; возведением этой матрицы в степень. Таким образом, мы за время <img class=tex src="../tex2png/cache/3552fa8853bc6d39d1236f3fd534aed2.png" alt="O (m \cdot \log repetition)"> можем предпосчитать матрицу <img class=tex src="../tex2png/cache/65eae3d8d7ea49c97ff7c2a0c574a319.png" alt="4 \times 4">, описывающую все преобразования, и затем просто умножить каждую точку <img class=tex src="../tex2png/cache/b98bee3099688d9f0572adb2ffa3ff68.png" alt="p_i"> на эту матрицу &mdash; тем самым, мы ответим на все запросы за время <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)">.<p><p><h3 style="padding-top:15px;"> Количество путей фиксированной длины в графе </h3><p><b>Условие</b>. Дан неориентированный граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами, и дано число <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">. Требуется для каждой пары вершин <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> найти количество путей между ними, содержащих ровно <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> рёбер.<p><b>Решение</b>. Более подробно эта задача рассматривается в <a href="fixed_length_paths.html">отдельной статье</a>. Здесь же лишь напомним суть этого решения: мы просто возводим в <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ую степень матрицу смежности этого графа, и элементы этой матрицы и будут являться решениями. Итоговая асимптотика &mdash; <img class=tex src="../tex2png/cache/49438c599376fcd4d5ac2d11cf6fb81f.png" alt="O (n^3 \log k)">.<p>(Примечание. В <a href="fixed_length_paths.html">той же статье</a> рассматривается и другая вариация этой задачи: когда граф взвешенный, и требуется найти путь минимального веса, содержащий ровно <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> рёбер. Как показано в этой статье, данная задача также решается с помощью бинарного возведения в степень матрицы смежности графа, однако вместо обычной операции перемножения двух матриц следует использовать модифицированную: вместо умножений берётся сумма, а вместо суммирования &mdash; взятие минимума.)<p><p><h3 style="padding-top:15px;"> Вариация бинарного возведения в степень: перемножение двух чисел по модулю </h3><p>Приведём здесь интересную вариацию бинарного возведения в степень.<p>Пусть перед нами стоит такая <b>задача</b>: перемножить два числа <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> по модулю <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m">:<p><p class=formula><img class=tex src="../tex2png/cache/e7743a3d467d533eeb289821b3b27389.png" alt=" a \cdot b \pmod m "></p><p>Предположим, что числа могут быть достаточно велики: настолько, что сами числа помещаются во встроенные типы данных, а вот их непосредственное произведение <img class=tex src="../tex2png/cache/dcbaca9e713cb8511ad35748a054fa56.png" alt="a \cdot b"> &mdash; уже нет (отметим, что нам также потребуется, чтобы сумма чисел помещалась во встроенный тип данных). Соответственно, задача в том, чтобы посчитать искомую величину <img class=tex src="../tex2png/cache/d91b14d66c73e2f9bc083df1e4b080b9.png" alt="(a \cdot b) \pmod m">, не прибегая к помощи <a href="big_integer.html">длинной арифметики</a>.<p><b>Решение</b> таково. Мы просто применяем алгоритм бинарного возведения, описанный выше, только вместо операции умножения мы будем производить сложения. Иными словами, перемножение двух чисел мы свели к <img class=tex src="../tex2png/cache/1598b628fc5926ef873e70421a929113.png" alt="O (\log m)"> операций сложения и умножения на два (что тоже, по сути, есть сложение).<p>(Примечание. Данную задачу можно решить и <b>по-другому</b>, прибегнув к помощи операций с числами с плавающей точкой. А именно, посчитаем в числах с плавающей точкой выражение <img class=tex src="../tex2png/cache/8e1723f1158a28dfb2e9b0dae31c356b.png" alt="a \cdot b / m">, и округлим его к ближайшему целому. Так мы найдём <b>приблизительное</b> частное. Отняв его от произведения <img class=tex src="../tex2png/cache/dcbaca9e713cb8511ad35748a054fa56.png" alt="a \cdot b"> (проигнорировав переполнения), мы, скорее всего, получим относительно небольшое число, которое можно взять по модулю <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> &mdash; и вернуть его в качестве ответа. Это решение выглядит довольно ненадёжным, но оно весьма быстрое, и очень кратко реализуется.)<p><p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Список задач, которые можно решить, используя бинарное возведение в степень:<p><ul><p><li><a href="http://acm.sgu.ru/problem.php?contest=0&problem=265">SGU #265 <b>"Wizards"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p></ul><p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>