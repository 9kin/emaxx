<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Генерация сочетаний из N элементов</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 14 Sep 2008 22:02<br>редактировано: 2 May 2012 0:54</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="generating_combinations.html#" id="contents-hide">[скрыть]</a><a href="generating_combinations.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Генерация сочетаний из N элементов</h1>
<h2>Сочетания из N элементов по K в лексикографическом порядке</h2>
<p>Постановка задачи. Даны натуральные числа N и K. Рассмотрим множество чисел от 1 до N. Требуется вывести все различные его подмножества мощности K, причём в лексикографическом порядке.</p>
<p>Алгоритм весьма прост. Первым сочетанием, очевидно, будет сочетание (1,2,...,K). Научимся для текущего сочетания находить лексикографически следующее. Для этого в текущем сочетании найдём самый правый элемент, не достигший ещё своего наибольшего значения; тогда увеличим его на единицу, а всем последующим элементам присвоим наименьшие значения.</p>
<pre>bool next_combination (vector&lt;int> & a, int n) {
	int k = (int)a.size();
	for (int i=k-1; i>=0; --i)
		if (a[i] &lt; n-k+i+1) {
			++a[i];
			for (int j=i+1; j&lt;k; ++j)
				a[j] = a[j-1]+1;
			return true;
		}
	return false;
}</pre>
<p>С точки зрения производительности, этот алгоритм линеен (в среднем), если K не близко к N (т.е. если не выполняется, что K = N - o(N)). Для этого достаточно доказать, что сравнения "a[i] &lt; n-k+i+1" выполняются в сумме C<sub>n+1</sub><sup>k</sup> раз, т.е. в (N+1) / (N-K+1) раз больше, чем всего есть сочетаний из N элементов по K.</p>
<h2>Сочетания из N элементов по K с изменениями ровно одного элемента</h2>
<p>Требуется выписать все сочетания из N элементов по K, но в таком порядке, что любые два соседних сочетания будут отличаться ровно одним элементом.</p>
<p>Интуитивно можно сразу заметить, что эта задача похожа на задачу генерации всех подмножеств данного множества в таком порядке, когда два соседних подмножества отличаются ровно одним элементом. Эта задача непосредственно решается с помощью <a href="gray_code.html">Кода Грея</a>: если мы каждому подмножеству поставим в соответствие битовую маску, то, генерируя с помощью кодов Грея эти битовые маски, мы и получим ответ.</p>
<p>Может показаться удивительным, но задача генерации сочетаний также непосредственно решается с помощью <b>кода Грея</b>. А именно, сгенерируем коды Грея для чисел от 0 до 2<sup>N</sup>-1, и оставим только те коды, которые содержат ровно K единиц. Удивительный факт заключается в том, что в полученной последовательности любые две соседние маски (а также первая и последняя маски) будут отличаться ровно двумя битами, что нам как раз и требуется.</p>
<p><b>Докажем</b> это.</p>
<p>Для доказательства вспомним факт, что последовательность G(N) кодов Грея можно получить следующим образом:</p>
<pre>G(N) = 0G(N-1) &cup; 1G(N-1)<sup>R</sup></pre>
<p>т.е. берём последовательность кодов Грея для N-1, дописываем в начало каждой маски 0, добавляем к ответу; затем снова берём последовательность кодов Грея для N-1, инвертируем её, дописываем в начало каждой маски 1 и добавляем к ответу.</p>
<p>Теперь мы можем произвести доказательство.</p>
<p>Сначала докажем, что первая и последняя маски будут отличаться ровно в двух битах. Для этого достаточно заметить, что первая маска будет иметь вид N-K нулей и K единиц, а последняя маска будет иметь вид: единица, потом N-K-1 нулей, потом K-1 единица. Доказать это легко по индукции по N, пользуясь приведённой выше формулой для последовательности кодов Грея.</p>
<p>Теперь докажем, что любые два соседних кода будут отличаться ровно в двух битах. Для этого снова обратимся к формуле для последовательности кодов Грея. Пусть внутри каждой из половинок (образованных из G(N-1)) утверждение верно, докажем, что оно верно для всей последовательности. Для этого достаточно доказать, что оно верно в месте "склеивания" двух половинок G(N-1), а это легко показать, основываясь на том, что мы знаем первый и последний элементы этих половинок.</p>
<p>Приведём теперь наивную реализацию, работающую за 2<sup>N</sup>:</p>
<pre>int gray_code (int n) {
	return n ^ (n >> 1);
}

int count_bits (int n) {
	int res = 0;
	for (; n; n>>=1)
		res += n & 1;
	return res;
}

void all_combinations (int n, int k) {
	for (int i=0; i&lt;(1&lt;&lt;n); ++i) {
		int cur = gray_code (i);
		if (count_bits (cur) == k) {
			for (int j=0; j&lt;n; ++j)
				if (cur & (1&lt;&lt;j))
					printf ("%d ", j+1);
			puts ("");
		}
	}
}</pre>
<p>Стоит заметить, что возможна и в некотором смысле более эффективная реализация, которая будет строить всевозможные сочетания на ходу, и тем самым работать за O (C<sub>n</sub><sup>k</sup> n). С другой стороны, эта реализация представляет собой рекурсивную функцию, и поэтому для небольших n, вероятно, она имеет большую скрытую константу, чем предыдущее решение.</p>
<p>Собственно сама реализация - это непосредственное следование формуле:</p>
<pre>G(N,K) = 0G(N-1,K) &cup; 1G(N-1,K-1)<sup>R</sup></pre>
<p>Эта формула легко получается из приведённой выше формулы для последовательности Грея - мы просто выбираем подпоследовательность из подходящих нам элементов.</p>
<pre>bool ans[MAXN];

void gen (int n, int k, int l, int r, bool rev, int old_n) {
	if (k > n || k &lt; 0)  return;
	if (!n) {
		for (int i=0; i&lt;old_n; ++i)
			printf ("%d", (int)ans[i]);
		puts ("");
		return;
	}
	ans[rev?r:l] = false;
	gen (n-1, k, !rev?l+1:l, !rev?r:r-1, rev, old_n);
	ans[rev?r:l] = true;
	gen (n-1, k-1, !rev?l+1:l, !rev?r:r-1, !rev, old_n);
}

void all_combinations (int n, int k) {
	gen (n, k, 0, n-1, false, n);
}</pre><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>