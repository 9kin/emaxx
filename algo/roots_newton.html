<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Поиск корней методом Ньютона (касательных)</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 11 Jun 2008 11:14<br>редактировано: 21 Sep 2010 0:54</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="roots_newton.html#" id="contents-hide">[скрыть]</a><a href="roots_newton.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Метод Ньютона (касательных) для поиска корней</h1><p>Это итерационный метод, изобретённый <b>Исааком Ньютоном</b> (Isaak Newton) около 1664 г. Впрочем, иногда этот метод называют методом Ньютона-Рафсона (Raphson), поскольку Рафсон изобрёл тот же самый алгоритм на несколько лет позже Ньютона, однако его статья была опубликована намного раньше.<p>Задача заключается в следующем. Дано уравнение:<p><p class=formula><img class=tex src="../tex2png/cache/42f1f9463815f75ea3274b137a896fd9.png" alt=" f(x) = 0. "></p><p>Требуется решить это уравнение, точнее, найти один из его корней (предполагается, что корень существует). Предполагается, что <img class=tex src="../tex2png/cache/c08c01c7f11043de3440285568d82570.png" alt="f(x)"> непрерывна и дифференцируема на отрезке <img class=tex src="../tex2png/cache/2876eb358dba6f6f1347e3e76bed79d6.png" alt="[a;b]">.<p><p><h2 style="padding-top:40px;">Алгоритм</h2><p>Входным параметром алгоритма, кроме функции <img class=tex src="../tex2png/cache/c08c01c7f11043de3440285568d82570.png" alt="f(x)">, является также <b>начальное приближение</b> &mdash; некоторое <img class=tex src="../tex2png/cache/469f2c65d8657af638ca2b52341a7edb.png" alt="x_0">, от которого алгоритм начинает идти.<p>Пусть уже вычислено <img class=tex src="../tex2png/cache/bdf4742dd10f0eb4f2b7801e40b0e129.png" alt="x_i">, вычислим <img class=tex src="../tex2png/cache/48ffe0b4dfc482f269284656c04fb1f8.png" alt="x_{i+1}"> следующим образом. Проведём касательную к графику функции <img class=tex src="../tex2png/cache/c08c01c7f11043de3440285568d82570.png" alt="f(x)"> в точке <img class=tex src="../tex2png/cache/fcde3772b6a516c4efad4b048826bacc.png" alt="x = x_i">, и найдём точку пересечения этой касательной с осью абсцисс. <img class=tex src="../tex2png/cache/48ffe0b4dfc482f269284656c04fb1f8.png" alt="x_{i+1}"> положим равным найденной точке, и повторим весь процесс с начала.<p>Нетрудно получить следующую формулу:<p><p class=formula><img class=tex src="../tex2png/cache/198b88bbca161e7da110c25de023ad95.png" alt=" x_{i+1} = x_i - \frac{ f(x_i) }{ f^\prime(x_i) }.[...]"></p><p>Интуитивно ясно, что если функция <img class=tex src="../tex2png/cache/c08c01c7f11043de3440285568d82570.png" alt="f(x)"> достаточно "хорошая" (гладкая), а <img class=tex src="../tex2png/cache/bdf4742dd10f0eb4f2b7801e40b0e129.png" alt="x_i"> находится достаточно близко от корня, то <img class=tex src="../tex2png/cache/48ffe0b4dfc482f269284656c04fb1f8.png" alt="x_{i+1}"> будет находиться ещё ближе к искомому корню.<p>Скорость сходимости является <b>квадратичной</b>, что, условно говоря, означает, что число точных разрядов в приближенном значении <img class=tex src="../tex2png/cache/bdf4742dd10f0eb4f2b7801e40b0e129.png" alt="x_i"> удваивается с каждой итерацией.<p><p><h2 style="padding-top:40px;">Применение для вычисления квадратного корня</h2><p>Рассмотрим метод Ньютона на примере вычисления квадратного корня.<p>Если подставить <img class=tex src="../tex2png/cache/d60389a442c336944a8d41ce94225372.png" alt="f(x) = \sqrt{x}">, то после упрощения выражения получаем:<p><p class=formula><img class=tex src="../tex2png/cache/1ff1f0baa740915008c43a1ab726cc10.png" alt=" x_{i+1} = \frac{ x_i + \frac{n}{x_i} }{ 2 }. "></p><p>Первый типичный вариант задачи &mdash; когда дано дробное число <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, и нужно подсчитать его корень с некоторой точностью <img class=tex src="../tex2png/cache/1a0d8efafc744f1b3ed9f417a47f5e8d.png" alt="\rm EPS">:<p><pre class="notranslate cpp"><span class="kw4">double</span> n<span class="sy4">;</span>
<span class="kw3">cin</span> <span class="sy1">&gt;&gt;</span> n<span class="sy4">;</span>
<span class="kw4">const</span> <span class="kw4">double</span> EPS <span class="sy1">=</span> <span class="nu19">1E-15</span><span class="sy4">;</span>
<span class="kw4">double</span> x <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">double</span> nx <span class="sy1">=</span> <span class="br0">&#40;</span>x <span class="sy2">+</span> n <span class="sy2">/</span> x<span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw3">abs</span> <span class="br0">&#40;</span>x <span class="sy2">-</span> nx<span class="br0">&#41;</span> <span class="sy1">&lt;</span> EPS<span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
	x <span class="sy1">=</span> nx<span class="sy4">;</span>
<span class="br0">&#125;</span>
<span class="kw3">printf</span> <span class="br0">&#40;</span><span class="st0">&quot;%.15lf&quot;</span>, x<span class="br0">&#41;</span><span class="sy4">;</span></pre><p>Другой распространённый вариант задачи &mdash; когда требуется посчитать целочисленный корень (для данного <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> найти наибольшее <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> такое, что <img class=tex src="../tex2png/cache/23082231eb31b79e07343922760554c6.png" alt="x^2 \le n">). Здесь приходится немного изменять условие останова алгоритма, поскольку может случиться, что <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> начнёт "скакать" возле ответа. Поэтому мы добавляем условие, что если значение <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> на предыдущем шаге уменьшилось, а на текущем шаге пытается увеличиться, то алгоритм надо остановить.<p><pre class="notranslate cpp"><span class="kw4">int</span> n<span class="sy4">;</span>
<span class="kw3">cin</span> <span class="sy1">&gt;&gt;</span> n<span class="sy4">;</span>
<span class="kw4">int</span> x <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="kw4">bool</span> decreased <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> nx <span class="sy1">=</span> <span class="br0">&#40;</span>x <span class="sy2">+</span> n <span class="sy2">/</span> x<span class="br0">&#41;</span> <span class="sy1">&gt;&gt;</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>x <span class="sy1">==</span> nx <span class="sy3">||</span> nx <span class="sy1">&gt;</span> x <span class="sy3">&amp;&amp;</span> decreased<span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
	decreased <span class="sy1">=</span> nx <span class="sy1">&lt;</span> x<span class="sy4">;</span>
	x <span class="sy1">=</span> nx<span class="sy4">;</span>
<span class="br0">&#125;</span>
<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> x<span class="sy4">;</span></pre><p>Наконец, приведём ещё третий вариант &mdash; для случая длинной арифметики. Поскольку число <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> может быть достаточно большим, то имеет смысл обратить внимание на начальное приближение. Очевидно, что чем оно ближе к корню, тем быстрее будет достигнут результат. Достаточно простым и эффективным будет брать в качестве начального приближения число <img class=tex src="../tex2png/cache/fd43b028211fbdcfbca0dc6ae0777bd9.png" alt="2^{{\rm bits}/2}">, где <img class=tex src="../tex2png/cache/d4a557314afeec10078584aa95cec859.png" alt="\rm bits"> &mdash; количество битов в числе <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Вот код на языке Java, демонстрирующий этот вариант:<p><pre class="notranslate cpp">BigInteger n<span class="sy4">;</span> <span class="co1">// входные данные</span>
&nbsp;
BigInteger a <span class="sy1">=</span> BigInteger.<span class="me1">ONE</span>.<span class="me1">shiftLeft</span> <span class="br0">&#40;</span>n.<span class="me1">bitLength</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy2">/</span> <span class="nu0">2</span><span class="br0">&#41;</span><span class="sy4">;</span>
boolean p_dec <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	BigInteger b <span class="sy1">=</span> n.<span class="me1">divide</span><span class="br0">&#40;</span>a<span class="br0">&#41;</span>.<span class="me1">add</span><span class="br0">&#40;</span>a<span class="br0">&#41;</span>.<span class="me1">shiftRight</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>a.<span class="me1">compareTo</span><span class="br0">&#40;</span>b<span class="br0">&#41;</span> <span class="sy1">==</span> <span class="nu0">0</span> <span class="sy3">||</span> a.<span class="me1">compareTo</span><span class="br0">&#40;</span>b<span class="br0">&#41;</span> <span class="sy1">&lt;</span> <span class="nu0">0</span> <span class="sy3">&amp;&amp;</span> p_dec<span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
	p_dec <span class="sy1">=</span> a.<span class="me1">compareTo</span><span class="br0">&#40;</span>b<span class="br0">&#41;</span> <span class="sy1">&gt;</span> <span class="nu0">0</span><span class="sy4">;</span>
	a <span class="sy1">=</span> b<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Например, этот вариант кода выполняется для числа <img class=tex src="../tex2png/cache/640bd399af440c0e8468b1a25df3e969.png" alt="10^{1000}"> за <img class=tex src="../tex2png/cache/31c2879c51665cbc91c1606e55680cb0.png" alt="60"> миллисекунд, а если убрать улучшенный выбор начального приближения (просто начинать с <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1">), то будет выполняться примерно <img class=tex src="../tex2png/cache/8f93f06863f31e46a9da8f92b32f9994.png" alt="120"> миллисекунд.<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>