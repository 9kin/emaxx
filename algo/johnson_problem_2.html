<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Задача Джонсона с двумя станками</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 11 Jun 2008 11:21<br>редактировано: 15 Sep 2011 1:36</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="johnson_problem_2.html#" id="contents-hide">[скрыть]</a><a href="johnson_problem_2.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Задача Джонсона с двумя станками </h1><p>Имеется <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> деталей и два станка. Каждая деталь должна сначала пройти обработку на первом станке, затем &mdash; на втором. При этом <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ая деталь обрабатывается на первом станке за <img class=tex src="../tex2png/cache/ef875bf5bad8370d4f3bbe3c740d3dd3.png" alt="a_i"> времени, а на втором &mdash; за <img class=tex src="../tex2png/cache/0993821d823b5b792321f13c90efa683.png" alt="b_i"> времени. Каждый станок в каждый момент времени может работать только с одной деталью.<p>Требуется составить такой порядок подачи деталей на станки, чтобы итоговое время обработки всех деталей было бы минимальным.<p>Эта задача называется иногда задачей двухпроцессорного обслуживания задач, или задачей Джонсона (по имени S.M. Johnson, который в 1954 г. предложил алгоритм для её решения).<p>Стоит отметить, что когда число станков больше двух, эта задача становится NP-полной (как доказал Гэри (Garey) в 1976 г.).<p><p><h2 style="padding-top:40px;"> Построение алгоритма </h2><p>Заметим вначале, что можно считать, что порядок обработки деталей <b>на первом и втором станках должен совпадать</b>. В самом деле, т.к. детали для второго станка становятся доступными только после обработки на первом, а при наличии нескольких доступных для второго станка деталей время их обработки будет равно сумме их <img class=tex src="../tex2png/cache/0993821d823b5b792321f13c90efa683.png" alt="b_i"> независимо от их порядка &mdash; то выгоднее всего отправлять на второй станок ту из деталей, которая раньше других прошла обработку на первом станке.<p>Рассмотрим порядок подачи деталей на станки, совпадающий с их входным порядком: <img class=tex src="../tex2png/cache/2c5a22be32f90ec5986f61666d42ae61.png" alt="1, 2, \ldots, n">.<p>Обозначим через <img class=tex src="../tex2png/cache/bdf4742dd10f0eb4f2b7801e40b0e129.png" alt="x_i"> <b>время простоя</b> второго станка непосредственно перед обработкой <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой детали (после обработки <img class=tex src="../tex2png/cache/81feab0e2cc1a37ff2c95e0a32cf5fc3.png" alt="i-1">-ой детали). Наша цель &mdash; <b>минимизировать суммарный простой</b>:<p><p class=formula><img class=tex src="../tex2png/cache/f6bf14916cc21af0374e7efd1548f168.png" alt=" F(x) = \sum x_i \longrightarrow \min. "></p><p>Для первой детали мы имеем:<p><p class=formula><img class=tex src="../tex2png/cache/cc8aaa864839d9cd15620df6abb99edc.png" alt=" x_1 = a_1. "></p><p>Для второй &mdash; т.к. она становится готовой к отправке на второй станок в момент времени <img class=tex src="../tex2png/cache/2268b91de40020de864452a7de975228.png" alt="a_1+a_2">, а второй станок освобождается в момент времени <img class=tex src="../tex2png/cache/b7dc1575746a0dac5d2bf39ef0877d6b.png" alt="x_1 + b_1">, то имеем:<p><p class=formula><img class=tex src="../tex2png/cache/915c71aaca440906ac17d61259ceeb75.png" alt=" x_2 = \max \Big( (a_1+a_2) - (x_1+b_1), 0 \Big). "></p><p>Третья деталь становится доступной для второго станка в момент <img class=tex src="../tex2png/cache/a9bbc2af0afddac0d2be62ceee50756c.png" alt="a_1+a_2+a_3">, а станок освобождается в <img class=tex src="../tex2png/cache/7119e166edc379eaba4169805e662b80.png" alt="x_1+b_1+x_2+b_2">, поэтому:<p><p class=formula><img class=tex src="../tex2png/cache/b4b9186340c304ff051619596e67b8d8.png" alt=" x_3 = \max \Big( (a_1+a_2+a_3) - (x_1+b_1+x_2+b_2[...]"></p><p>Таким образом, общий вид для <img class=tex src="../tex2png/cache/bdf4742dd10f0eb4f2b7801e40b0e129.png" alt="x_i"> выглядит так:<p><p class=formula><img class=tex src="../tex2png/cache/011979606ef124aa0e0a2377b534274e.png" alt=" x_k = \max \left( \sum_{i=1}^{k} a_i - \sum_{i=1}[...]"></p><p>Посчитаем теперь <b>суммарный простой</b> <img class=tex src="../tex2png/cache/f3ed7dc1b1cc63bdf86d090351726fa0.png" alt="F(x)">. Утверждается, что он имеет вид:<p><p class=formula><img class=tex src="../tex2png/cache/254353742f37b7de7ac9adff352a8443.png" alt=" F(x) = \max_{k=1 \ldots n} K_i, "></p><p>где<p><p class=formula><img class=tex src="../tex2png/cache/19bc96767b1da224c0de60848e4bf784.png" alt=" K_i = \sum_{i=1}^{k} a_i - \sum_{i=1}^{k-1} b_i. "></p><p>(В это можно убедиться по индукции, либо последовательно находя выражения для суммы первых двух, трёх, и т.д. <img class=tex src="../tex2png/cache/bdf4742dd10f0eb4f2b7801e40b0e129.png" alt="x_i">.)<p>Воспользуемся теперь <b>перестановочным приёмом</b>: попробуем обменять какие-либо два соседних элемента <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> и <img class=tex src="../tex2png/cache/c8ed7217716b47abf98aede9ec9508b9.png" alt="j+1"> и посмотрим, как при этом изменится суммарный простой.<p>По виду функции выражений для <img class=tex src="../tex2png/cache/c4da123415abcf1fc93e5efa10cfae0a.png" alt="K_i"> понятно, что изменятся только <img class=tex src="../tex2png/cache/7c7df723d4c8614106d6bda11c9aa566.png" alt="K_j"> и <img class=tex src="../tex2png/cache/5512eb23983840eca79c6a551e4271f1.png" alt="K_{j+1}">; обозначим их новые значения через <img class=tex src="../tex2png/cache/43f0b79dc88ba557644def58a6d35caf.png" alt="K_j^\prime"> и <img class=tex src="../tex2png/cache/37bf9adcce13245714ddc40ef1967657.png" alt="K_{j+1}^\prime">.<p>Таким образом, чтобы деталь <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> шла до детали <img class=tex src="../tex2png/cache/c8ed7217716b47abf98aede9ec9508b9.png" alt="j+1">, достаточно (хотя и не необходимо), чтобы:<p><p class=formula><img class=tex src="../tex2png/cache/433a588b9aad16fe4cb22ad64783e1f0.png" alt=" \max \left( K_j, K_{j+1} \right) \le \max \left( [...]"></p><p>(т.е. мы проигнорировали остальные, не изменившиеся, аргументы максимума в выражении для <img class=tex src="../tex2png/cache/f3ed7dc1b1cc63bdf86d090351726fa0.png" alt="F(x)">, получив тем самым достаточное, но не необходимое условие того, что старое <img class=tex src="../tex2png/cache/f3ed7dc1b1cc63bdf86d090351726fa0.png" alt="F(x)"> меньше либо равно нового значения)<p>Отняв <img class=tex src="../tex2png/cache/b6edc9ee5202e2db5324a7938f0957e1.png" alt=" \sum_{i=1}^{j+1} a_i - \sum_{i=1}^{j-1} b_i "> от обеих частей этого неравенства, получим:<p><p class=formula><img class=tex src="../tex2png/cache/2ca6cabb685333aed8c7cc32846b7915.png" alt=" \max (-a_{j+1}, -b_j) \le \max (-b_{j+1}, -a_j), "></p><p>или, избавляясь от отрицательных чисел, получаем:<p><p class=formula><img class=tex src="../tex2png/cache/858770fa040197e3d16914dfbbc4dc57.png" alt=" \min (a_j, b_{j+1}) \le \min (b_j, a_{j+1}). "></p><p>Тем самым, мы получили <b>компаратор</b>: отсортировав детали по нему, мы, согласно приведённым выше выкладкам, придём к оптимальному порядку деталей, в котором нельзя переставить местами никакие две детали, улучшив итоговое время.<p>Впрочем, можно ещё больше <b>упростить</b> сортировку, если посмотреть на этот компаратор с другой стороны. Фактически он говорит нам о том, что если минимум из четырёх чисел <img class=tex src="../tex2png/cache/6fd1390a88e59735b67476397dc55cf9.png" alt="(a_j, a_{j+1}, b_{j}, b_{j+1})"> достигается на элементе из массива <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, то соответствующая деталь должна идти раньше, а если на элементе из массива <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> &mdash; то позже. Тем самым мы получаем другую форму алгоритма: отсортировать детали по минимуму из <img class=tex src="../tex2png/cache/c9825f52ae4d8dc6c5f1e0645c8185d5.png" alt="(a_i, b_i)">, и если у текущей детали минимум равен <img class=tex src="../tex2png/cache/ef875bf5bad8370d4f3bbe3c740d3dd3.png" alt="a_i">, то эту деталь надо обработать первой из оставшихся, иначе &mdash; последней из оставшихся.<p>Так или иначе, получается, что задача Джонсона с двумя станками сводится к сортировке деталей с определённой функцией сравнения элементов. Таким образом, асимптотика решения составляет <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">.<p><p><h2 style="padding-top:40px;"> Реализация </h2><p>Реализуем второй вариант описанного выше алгоритма, когда детали сортируются по минимуму из <img class=tex src="../tex2png/cache/c9825f52ae4d8dc6c5f1e0645c8185d5.png" alt="(a_i, b_i)">, и затем отправляются в начало либо в конец текущего списка.<p><pre class="notranslate cpp"><span class="kw4">struct</span> item <span class="br0">&#123;</span>
	<span class="kw4">int</span> a, b, id<span class="sy4">;</span>
&nbsp;
	<span class="kw4">bool</span> operator<span class="sy1">&lt;</span> <span class="br0">&#40;</span>item p<span class="br0">&#41;</span> <span class="kw4">const</span> <span class="br0">&#123;</span>
		<span class="kw1">return</span> min<span class="br0">&#40;</span>a,b<span class="br0">&#41;</span> <span class="sy1">&lt;</span> min<span class="br0">&#40;</span>p.<span class="me1">a</span>,p.<span class="me1">b</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
&nbsp;
&nbsp;
sort <span class="br0">&#40;</span>v.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, v.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
vector<span class="sy1">&lt;</span>item<span class="sy1">&gt;</span> a, b<span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	<span class="br0">&#40;</span>v<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">a</span><span class="sy1">&lt;=</span>v<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">b</span> <span class="sy4">?</span> a <span class="sy4">:</span> b<span class="br0">&#41;</span> .<span class="me1">push_back</span> <span class="br0">&#40;</span>v<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
a.<span class="me1">insert</span> <span class="br0">&#40;</span>a.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, b.<span class="me1">rbegin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, b.<span class="me1">rend</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> t1<span class="sy1">=</span><span class="nu0">0</span>, t2<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	t1 <span class="sy2">+</span><span class="sy1">=</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">a</span><span class="sy4">;</span>
	t2 <span class="sy1">=</span> max<span class="br0">&#40;</span>t2,t1<span class="br0">&#41;</span> <span class="sy2">+</span> a<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">b</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Здесь все детали хранятся в виде структур <img class=tex src="../tex2png/cache/6e14da43080eab2d58251bcf23ca6ab7.png" alt="\rm item">, каждая из которых содержит значения <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> и исходный номер детали.<p>Детали сортируются, затем распределяются по спискам <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> (это те детали, которые были отправлены в начало очереди) и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> (те, что были отправлены в конец). После этого два списка объединяются (причём второй список берётся в обратном порядке), и затем по найденному порядку вычисляется искомое минимальное время: поддерживаются две переменные <img class=tex src="../tex2png/cache/b0d9d011e6176215767b2d0346521c34.png" alt="t_1"> и <img class=tex src="../tex2png/cache/98a9d3b95fa8df513c642a04aa8e1209.png" alt="t_2"> &mdash; время освобождения первого и второго станка соответственно.<p><p><h2 style="padding-top:40px;"> Литература </h2><p><ul><p><li><a href="http://www.rand.org/pubs/papers/2008/P402.pdf">S.M. Johnson. <b>Optimal two- and three-stage production schedules with setup times included</b> [1954]</a><p><li>M.R. Garey. <b>The Complexity of Flowshop and Jobshop Scheduling</b> [1976]<p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>