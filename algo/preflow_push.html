<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Метод Проталкивания предпотока нахождения максимального потока</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 22:52<br>редактировано: 10 Jun 2008 22:53</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="preflow_push.html#" id="contents-hide">[скрыть]</a><a href="preflow_push.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Максимальный поток методом Проталкивания предпотока за O (N<sup>4</sup>)</h1>

<p>Пусть дан граф G, в котором выделены две вершины: исток S и сток T, а у каждого ребра определена пропускная способность C<sub>u,v</sub>. Поток F можно представить как поток вещества, которое могло бы пройти по сети от истока к стоку, если рассматривать граф как сеть труб с некоторыми пропускными способностями. Т.е. поток - функция F<sub>u, v</sub>, определённая на множестве рёбер графа.</p>
<p>&nbsp;</p>
<p>Задача заключается в нахождении максимального потока. Здесь будет рассмотрен метод Проталкивания предпотока, работающий за O (N<sup>4</sup>), или, точнее, за O (N<sup>2</sup> M). Алгоритм был предложен Гольдбергом в 1985 году.</p>
<h2>Алгоритм</h2>
<p>Общая схема алгоритма такова. На каждом шаге будем рассматривать некоторый предпоток - т.е. функцию, которая по свойствам напоминает поток, но не обязательно удовлетворяет закону сохранения потока. На каждом шаге будем пытаться применить какую-либо из двух операций: проталкивание потока или поднятие вершины. Если на каком-то шаге станет невозможно применить какую-либо из двух операций, то мы нашли требуемый поток.</p>
<p>Для каждой вершины определена её высота H<sub>u</sub>, причём H<sub>S</sub> = N, H<sub>T</sub> = 0, и для любого остаточного ребра (u, v) имеем H<sub>u</sub> &lt;= H<sub>v</sub> + 1.</p>
<p>Для каждой вершины (кроме S) можно определить её избыток: E<sub>u</sub> = F<sub>V, u</sub>. Вершина с положительным избытком называется переполненной.</p>
<p>Операция проталкивания Push (u, v) применима, если вершина u переполнена, остаточная пропускная способность Cf<sub>u, v</sub> > 0 и H<sub>u</sub> = H<sub>v</sub> + 1. Операция проталкивания заключается в максимальном увеличении потока из u в v, ограниченном избытком E<sub>u</sub> и остаточной пропускной способностью Cf<sub>u, v</sub>.</p>
<p>Операция поднятия Lift (u) поднимает переполненную вершину u на максимально допустимую высоту. Т.е. H<sub>u</sub> = 1 + min { H<sub>v</sub> }, где (u, v) - остаточное ребро.</p>
<p>Осталось только рассмотреть инициализацию потока. Нужно инициализировать только следующие значения: F<sub>S, v</sub> = C<sub>S, v</sub>, F<sub>u, S</sub> = - C<sub>u, S</sub>, остальные значения положить равными нулю.</p>
<h2>Реализация</h2>
<pre>const int inf = 1000*1000*1000;


typedef vector&lt;int> graf_line;
typedef vector&lt;graf_line> graf;

typedef vector&lt;int> vint;
typedef vector&lt;vint> vvint;


void push (int u, int v, vvint & f, vint & e, const vvint & c)
{
	int d = min (e[u], c[u][v] - f[u][v]);
	f[u][v] += d;
	f[v][u] = - f[u][v];
	e[u] -= d;
	e[v] += d;
}

void lift (int u, vint & h, const vvint & f, const vvint & c)
{
	int d = inf;
	for (int i = 0; i &lt; (int)f.size(); i++)
		if (c[u][i]-f[u][i] > 0)
			d = min (d, h[i]);
	if (d == inf)
		return;
	h[u] = d + 1;
}


int main()
{
	int n;
	cin >> n;
	vvint c (n, vint(n));
	for (int i=0; i&lt;n; i++)
		for (int j=0; j&lt;n; j++)
			cin >> c[i][j];
	// исток - вершина 0, сток - вершина n-1

	vvint f (n, vint(n));
	for (int i=1; i&lt;n; i++)
	{
		f[0][i] = c[0][i];
		f[i][0] = -c[0][i];
	}

	vint h (n);
	h[0] = n;

	vint e (n);
	for (int i=1; i&lt;n; i++)
		e[i] = f[0][i];

	for ( ; ; )
	{
		int i;
		for (i=1; i&lt;n-1; i++)
			if (e[i] > 0)
				break;
		if (i == n-1)
			break;

		int j;
		for (j=0; j&lt;n; j++)
			if (c[i][j]-f[i][j] > 0 && h[i]==h[j]+1)
				break;
		if (j &lt; n)
			push (i, j, f, e, c);
		else
			lift (i, h, f, c);
	}

	int flow = 0;
	for (int i=0; i&lt;n; i++)
		if (c[0][i])
			flow += f[0][i];

	cout &lt;&lt; max(flow,0);

}</pre><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>