<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Нахождение минимального разреза. Алгоритм Штор-Вагнера</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2009 21:03<br>редактировано: 18 Oct 2011 19:15</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="stoer_wagner_mincut.html#" id="contents-hide">[скрыть]</a><a href="stoer_wagner_mincut.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Нахождение минимального разреза. Алгоритм Штор-Вагнера</h1><p><p><h2 style="padding-top:40px;">Постановка задачи</h2><p>Дан неориентированный взвешенный граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами и <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> рёбрами. Разрезом <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C"> называется некоторое подмножество вершин (фактически, разрез &mdash; разбиение вершин на два множества: принадлежащие <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C"> и все остальные). Весом разреза называется сумма весов рёбер, проходящих через разрез, т.е. таких рёбер, ровно один конец которых принадлежит <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C">:<p><p class=formula><img class=tex src="../tex2png/cache/bf1b304bb64cdf42b6a40360bbc6a248.png" alt=" w(C) = \sum_{(v,u) \in E, \atop u \in C, v \not\i[...]"></p><p>где через <img class=tex src="../tex2png/cache/75014114e5532780acf8715ec0ab6829.png" alt="E"> обозначено множество всех рёбер графа <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">, а через <img class=tex src="../tex2png/cache/7539d257018441a40d95216befed8cf4.png" alt="c(v,u)"> &mdash; вес ребра <img class=tex src="../tex2png/cache/fae7fc7228760232ded84ec7bb795757.png" alt="(v,u)">.<p>Требуется найти <b>разрез минимального веса</b>.<p>Иногда эту задачу называют "глобальным минимальным разрезом" &mdash; по контрасту с задачей, когда заданы вершины-сток и исток, и требуется найти минимальный разрез <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C">, содержащий сток и не содержащий исток. Глобальный минимальный разрез равен минимуму среди разрезов минимальной стоимости по всевозможным парам исток-сток.<p>Хотя эту задачу можно решить с помощью алгоритма нахождения максимального потока (запуская его <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)"> раз для всевозможных пар истока и стока), однако ниже описан гораздо более простой и быстрый алгоритм, предложенный Матильдой Штор (Mechthild Stoer) и Франком Вагнером (Frank Wagner) в 1994 г.<p>В общем случае допускаются петли и кратные рёбра, хотя, понятно, петли абсолютно никак не влияют на результат, а все кратные рёбра можно заменить одним ребром с их суммарным весом. Поэтому мы для простоты будем считать, что во входном графе петли и кратные рёбра отсутствуют.<p><p><h2 style="padding-top:40px;">Описание алгоритма</h2><p><b>Базовая идея</b> алгоритма очень проста. Будем итеративно повторять следующий процесс: находить минимальный разрез между какой-нибудь парой вершин <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> и <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">, а затем объединять эти две вершины в одну (соединяя списки смежности). В конце концов, после <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> итерации, граф сожмётся в единственную вершину и процесс остановится. После этого ответом будет являться минимальный среди всех <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> найденных разрезов. Действительно, на каждой <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой стадии найденный минимальный разрез <img class=tex src="../tex2png/cache/5ff63044085d8ddaac6cf944b3b365e0.png" alt="C_i"> между вершинами <img class=tex src="../tex2png/cache/0178ba7bc134eaf6ff236cdbaaed5bfd.png" alt="s_i"> и <img class=tex src="../tex2png/cache/724b75c9890da9892c0220dff280997d.png" alt="t_i"> либо окажется искомым глобальным минимальным разрезом, либо же, напротив, вершины <img class=tex src="../tex2png/cache/0178ba7bc134eaf6ff236cdbaaed5bfd.png" alt="s_i"> и <img class=tex src="../tex2png/cache/724b75c9890da9892c0220dff280997d.png" alt="t_i"> невыгодно относить к разным множествам, поэтому мы ничего не ухудшаем, объединяя эти две вершины в одну.<p>Таким образом, мы свели задачу к следующей: для данного графа найти <b>минимальный разрез между какой-нибудь, произвольной, парой вершин</b> <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> и <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">. Для решения этой задачи был предложен следующий, тоже итеративный процесс. Вводим некоторое множество вершин <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A">, которое изначально содержит единственную произвольную вершину. На каждом шаге находится вершина, <b>наиболее сильно связанная</b> с множеством <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A">, т.е. вершина <img class=tex src="../tex2png/cache/3ce3cc8d638d49841fa93f0e7a499534.png" alt="v \not\in A">, для которой следующая величина максимальна:<p><p class=formula><img class=tex src="../tex2png/cache/26ae2922e3dec5bcec0d92d38ee73784.png" alt=" w(v,A) = \sum_{(v,u) \in E, \atop u \in A} c(v,u)[...]"></p><p>(т.е. максимальна сумма весов рёбер, один конец которых <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, а другой принадлежит <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A">).<p>Опять же, этот процесс завершится через <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> итерацию, когда все вершины перейдут в множество <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> (кстати говоря, этот процесс очень напоминает <a href="mst_prim.html">алгоритм Прима</a>). Тогда, как утверждает <b>теорема Штор-Вагнера</b>, если мы обозначим через <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> и <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> последние две добавленные в <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> вершины, то минимальный разрез между вершинами <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> и <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> будет состоять из единственной вершины &mdash; <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">. Доказательство этой теоремы будет приведено в следующем разделе (как это часто бывает, само по себе оно никак не способствует пониманию алгоритма).<p>Таким образом, общая <b>схема алгоритма</b> Штор-Вагнера такова. Алгоритм состоит из <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> фазы. На каждой фазе множество <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> сначала полагается состоящим из какой-либо вершины; подсчитываются стартовые веса вершин <img class=tex src="../tex2png/cache/cf6f6e4e660fdc088a675bb4df1f206c.png" alt="w(v,A)">. Затем происходит <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> итерация, на каждой из которых выбирается вершина <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> с наибольшим значением <img class=tex src="../tex2png/cache/cf6f6e4e660fdc088a675bb4df1f206c.png" alt="w(v,A)"> и добавляется в множество <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A">, после чего пересчитываются значения <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> для оставшихся вершин (для чего, очевидно, надо пройтись по всем рёбрам списка смежности выбранной вершины <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">). После выполнения всех итераций мы запоминаем в <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> и <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> номера последних двух добавленных вершин, а в качестве стоимости найденного минимального разреза между <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> и <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> можно взять значение <img class=tex src="../tex2png/cache/aeb76b86d557f5717ef54e201803ca74.png" alt="w(t,A \setminus t)">. Затем надо сравнить найденный минимальный разрез с текущим ответом, если меньше, то обновить ответ. Перейти к следующей фазе.<p>Если не использовать никаких сложных структур данных, то самой критичной частью будет нахождение вершины с наибольшей величиной <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">. Если производить это за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">, то, учитывая, что всего фаз <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">, и по <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> итерации в каждой, итоговая <b>асимптотика алгоритма</b> получается <img class=tex src="../tex2png/cache/5333bf52919bd2805f33a181851ebbf4.png" alt="O(n^3)">.<p>Если для нахождения вершины с наибольшей величиной <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> использовать <b>Фибоначчиевы кучи</b> (которые позволяют увеличивать значение ключа за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> в среднем и извлекать максимум за <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)"> в среднем), то все связанные с множеством <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> операции на одной фазе выполнятся за <img class=tex src="../tex2png/cache/22ea2b3171db52cd31096159dede5ad5.png" alt="O(m + n \log n)">. Итоговая асимптотика алгоритма в таком случае составит <img class=tex src="../tex2png/cache/91550a14f3aa60c3033999b27481d2df.png" alt="O(n m + n^2 \log n)">.<p><p><h2 style="padding-top:40px;">Доказательство теоремы Штор-Вагнера</h2><p>Напомним условие этой теоремы. Если добавить в множество <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> по очереди все вершины, каждый раз добавляя вершину, наиболее сильно связанную с этим множеством, то обозначим предпоследнюю добавленную вершину через <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, а последнюю &mdash; через <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">. Тогда минимальный <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">-<img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> разрез состоит из единственной вершины &mdash; <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">.<p>Для доказательства рассмотрим произвольный <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">-<img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> разрез <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C"> и покажем, что его вес не может быть меньше веса разреза, состоящего из единственной вершины <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">:<p><p class=formula><img class=tex src="../tex2png/cache/de1e0d128e895de7d6908f0714297e3f.png" alt=" w(\{t\}) \le w(C). "></p><p>Для этого докажем следующий факт. Пусть <img class=tex src="../tex2png/cache/776f7da54d74d7bda0ad0f5084d5e3c7.png" alt="A_v"> &mdash; состояние множества <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> непосредственно перед добавлением вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Пусть <img class=tex src="../tex2png/cache/58e9fdee1ec1aab2494df06ae89a4405.png" alt="C_v"> &mdash; разрез множества <img class=tex src="../tex2png/cache/9ae18306db051d829196a8db3c359bab.png" alt="A_v \cup v">, индуцированный разрезом <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C"> (проще говоря, <img class=tex src="../tex2png/cache/58e9fdee1ec1aab2494df06ae89a4405.png" alt="C_v"> равно пересечению этих двух множеств вершин). Далее, вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> называется активной (по отношению к разрезу <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C">), если вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> и предыдущая добавленная в <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> вершина принадлежат разным частям разреза <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C">. Тогда, утверждается, для любой активной вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> выполняется неравенство:<p><p class=formula><img class=tex src="../tex2png/cache/435ac896c08fc9effebb2ac4aef80abc.png" alt=" w(v,A_v) \le w(C_v). "></p><p>В частности, <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> является активной вершиной (т.к. перед ним добавлялась вершина <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">), и при <img class=tex src="../tex2png/cache/066b72224cafad898f42f5a12a4f240b.png" alt="v = t"> это неравенство превращается в утверждение теоремы:<p><p class=formula><img class=tex src="../tex2png/cache/15517462db8c56cf29c7a3b6c690427f.png" alt=" w(t,A_t) = w(\{t\}) \le w(C_t) = w(C). "></p><p>Итак, будем доказывать неравенство, для чего воспользуемся методом математической индукции.<p>Для первой активной вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> это неравенство верно (более того, оно обращается в равенство) &mdash; поскольку все вершины <img class=tex src="../tex2png/cache/776f7da54d74d7bda0ad0f5084d5e3c7.png" alt="A_v"> принадлежат одной части разреза, а <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> &mdash; другой.<p>Пусть теперь это неравенство выполнено для всех активных вершин вплоть до некоторой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, докажем его для следующей активной вершины <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">. Для этого преобразуем левую часть:<p><p class=formula><img class=tex src="../tex2png/cache/c256ae48f4a243397e212537c954b35c.png" alt=" w(u,A_u) \equiv w(u,A_v) + w(u,A_u \setminus A_v)[...]"></p><p>Во-первых, заметим, что:<p><p class=formula><img class=tex src="../tex2png/cache/5520881d245b021e4b0fa529f9207c05.png" alt=" w(u,A_v) \le w(v,A_v), "></p><p>&mdash; это следует из того, что когда множество <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A"> было равно <img class=tex src="../tex2png/cache/776f7da54d74d7bda0ad0f5084d5e3c7.png" alt="A_v">, в него была добавлена именно вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, а не <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">, значит, она имела наибольшее значение <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">.<p>Далее, поскольку <img class=tex src="../tex2png/cache/9280e67466090b4af646ba3b87d56e18.png" alt="w(v,A_v) \le w(C_v)"> по предположению индукции, то получаем:<p><p class=formula><img class=tex src="../tex2png/cache/ccf2ccecfcb21fcbab62b0a56f40dd93.png" alt=" w(u,A_v) \le w(C_v), "></p><p>откуда имеем:<p><p class=formula><img class=tex src="../tex2png/cache/c278c7e2a78dd9591297e37b25fc16bb.png" alt=" w(u,A_u) \le w(C_v) + w(u,A_u \setminus A_v). "></p><p>Теперь заметим, что вершина <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> и все вершины <img class=tex src="../tex2png/cache/c5a0b72ae0fc7213fa805f459cc9eb6f.png" alt="A_u \setminus A_v"> находятся в разных частях разреза <img class=tex src="../tex2png/cache/5572481c8713abb69ad4011419e91fc7.png" alt="C">, поэтому эта величина <img class=tex src="../tex2png/cache/169453cc3c32741b464019f4619531a0.png" alt="w(u,A_u \setminus A_v)"> обозначает сумму весов рёбер, которые учтены в <img class=tex src="../tex2png/cache/e0b6d7348606bc84c9c51f6da6a6dfbe.png" alt="w(C_u)">, но ещё не были учтены в <img class=tex src="../tex2png/cache/88c72772241585c938d22e3fb8e6f460.png" alt="w(C_v)">, откуда получаем:<p><p class=formula><img class=tex src="../tex2png/cache/c97b34ff60cd33161c4b995782e1c556.png" alt=" w(u,A_u) \le w(C_v) + w(u,A_u \setminus A_v) \le [...]"></p><p>что и требовалось доказать.<p>Мы доказали соотношение <img class=tex src="../tex2png/cache/9280e67466090b4af646ba3b87d56e18.png" alt="w(v,A_v) \le w(C_v)">, а из него, как уже говорилось выше, следует и вся теорема.<p><p><h2 style="padding-top:40px;">Реализация</h2><p>Для наиболее простой и ясной реализации (с асимптотикой <img class=tex src="../tex2png/cache/5333bf52919bd2805f33a181851ebbf4.png" alt="O(n^3)">) было выбрано представление графа в виде матрицы смежности. Ответ хранится в переменных <img class=tex src="../tex2png/cache/34921f1268cb4934ca2305ad0ca39ac8.png" alt="\rm best\_cost"> и <img class=tex src="../tex2png/cache/353741d531720384c2757a1c508058ac.png" alt="\rm best\_cut"> (искомые стоимость минимального разреза и сами вершины, содержащиеся в нём).<p>Для каждой вершины в массиве <img class=tex src="../tex2png/cache/8bf6c79c7214c26224c5937ccba1f30e.png" alt="\rm exist"> хранится, существует ли она, или она была объединена с какой-то другой вершиной. В списке <img class=tex src="../tex2png/cache/5dd286cf9e6277ff4acc17799fdea591.png" alt="{\rm v}[i]"> для каждой сжатой вершины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> хранятся номера исходных вершин, которые были сжаты в эту вершину <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">.<p>Алгоритм состоит из <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> фазы (цикл по переменной <img class=tex src="../tex2png/cache/9f398fa4065bb4e5fb4238a132434404.png" alt="\rm ph">). На каждой фазе сначала все вершины находятся вне множества <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A">, для чего массив <img class=tex src="../tex2png/cache/7bbb74a211e10d43943800d3fd315041.png" alt="\rm in\_a"> заполняется нулями, и связности <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w"> всех вершин нулевые. На каждой из <img class=tex src="../tex2png/cache/310e5904c574e2ef92245d0125dcfbe2.png" alt="n-{\rm ph}"> итерации находится вершина <img class=tex src="../tex2png/cache/886efc043c8c843b12d3d0d4528f3efd.png" alt="\rm sel"> с наибольшей величиной <img class=tex src="../tex2png/cache/fee0bf4308e5ab449d0ff8518fb4207e.png" alt="w">. Если это итерация последняя, то ответ, если надо, обновляется, а предпоследняя <img class=tex src="../tex2png/cache/cfb5109d98b3e9afcb624379703102cc.png" alt="\rm prev"> и последняя <img class=tex src="../tex2png/cache/886efc043c8c843b12d3d0d4528f3efd.png" alt="\rm sel"> выбранные вершины объединяются в одну. Если итерация не последняя, то <img class=tex src="../tex2png/cache/886efc043c8c843b12d3d0d4528f3efd.png" alt="\rm sel"> добавляется в множество <img class=tex src="../tex2png/cache/b5f17df636a8bd667d2f5c3404ed82e7.png" alt="A">, после чего пересчитываются веса всех остальных вершин.<p>Следует заметить, что алгоритм в ходе своей работы "портит" граф <img class=tex src="../tex2png/cache/74b332862718f9b2b1fcdedaa034d947.png" alt="\rm g">, поэтому, если он ещё понадобится позже, надо сохранять его копию перед вызовом функции.<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> MAXN <span class="sy1">=</span> <span class="nu0">500</span><span class="sy4">;</span>
<span class="kw4">int</span> n, g<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">int</span> best_cost <span class="sy1">=</span> <span class="nu0">1000000000</span><span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> best_cut<span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> mincut<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		v<span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">assign</span> <span class="br0">&#40;</span><span class="nu0">1</span>, i<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw4">int</span> w<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw4">bool</span> exist<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, in_a<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="kw3">memset</span> <span class="br0">&#40;</span>exist, <span class="kw2">true</span>, <span class="kw3">sizeof</span> exist<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> ph<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> ph<span class="sy1">&lt;</span>n<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span> <span class="sy2">++</span>ph<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw3">memset</span> <span class="br0">&#40;</span>in_a, <span class="kw2">false</span>, <span class="kw3">sizeof</span> in_a<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw3">memset</span> <span class="br0">&#40;</span>w, <span class="nu0">0</span>, <span class="kw3">sizeof</span> w<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> it<span class="sy1">=</span><span class="nu0">0</span>, prev<span class="sy4">;</span> it<span class="sy1">&lt;</span>n<span class="sy2">-</span>ph<span class="sy4">;</span> <span class="sy2">++</span>it<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> sel <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
				<span class="kw1">if</span> <span class="br0">&#40;</span>exist<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy3">&amp;&amp;</span> <span class="sy3">!</span>in_a<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy3">&amp;&amp;</span> <span class="br0">&#40;</span>sel <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy3">||</span> w<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&gt;</span> w<span class="br0">&#91;</span>sel<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
					sel <span class="sy1">=</span> i<span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>it <span class="sy1">==</span> n<span class="sy2">-</span>ph<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				<span class="kw1">if</span> <span class="br0">&#40;</span>w<span class="br0">&#91;</span>sel<span class="br0">&#93;</span> <span class="sy1">&lt;</span> best_cost<span class="br0">&#41;</span>
					best_cost <span class="sy1">=</span> w<span class="br0">&#91;</span>sel<span class="br0">&#93;</span>,  best_cut <span class="sy1">=</span> v<span class="br0">&#91;</span>sel<span class="br0">&#93;</span><span class="sy4">;</span>
				v<span class="br0">&#91;</span>prev<span class="br0">&#93;</span>.<span class="me1">insert</span> <span class="br0">&#40;</span>v<span class="br0">&#91;</span>prev<span class="br0">&#93;</span>.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, v<span class="br0">&#91;</span>sel<span class="br0">&#93;</span>.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, v<span class="br0">&#91;</span>sel<span class="br0">&#93;</span>.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
				<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
					g<span class="br0">&#91;</span>prev<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> g<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>prev<span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> g<span class="br0">&#91;</span>sel<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
				exist<span class="br0">&#91;</span>sel<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
			<span class="kw1">else</span> <span class="br0">&#123;</span>
				in_a<span class="br0">&#91;</span>sel<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
				<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
					w<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> g<span class="br0">&#91;</span>sel<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
				prev <span class="sy1">=</span> sel<span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p><p><h2 style="padding-top:40px;">Литература</h2><p><ul><li><a href="../bookz/files/stoer_wagner_mincut.pdf">Mechthild Stoer, Frank Wagner. <b>A Simple Min-Cut Algorithm</b> [1997]</a><li><a href="../bookz/files/mehlhorn_mincut_stoer_wagner.pdf">Kurt Mehlhorn, Christian Uhrig. <b>The minimum cut algorithm of Stoer and Wagner</b> [1995]</a></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>