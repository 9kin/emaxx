<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Минимальное остовное дерево. Алгоритм Крускала</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 22:03<br>редактировано: 10 Jun 2008 22:05</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="mst_kruskal.html#" id="contents-hide">[скрыть]</a><a href="mst_kruskal.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Минимальное остовное дерево. Алгоритм Крускала</h1>

<p>Дан взвешенный неориентированный граф. Требуется найти такое поддерево этого графа, которое бы соединяло все его вершины, и при этом обладало наименьшим весом (т.е. суммой весов рёбер) из всех возможных. Такое поддерево называется минимальным остовным деревом или простом минимальным остовом.</p>
<p>Здесь будут рассмотрены несколько важных фактов, связанных с минимальными остовами, затем будет рассмотрен алгоритм Крускала в его простейшей реализации.</p>
<h3>Свойства минимального остова</h3>
<ul>
<li>Минимальный остов <b>уникален, если веса всех рёбер различны</b>. В противном случае, может существовать несколько минимальных остовов (конкретные алгоритмы обычно получают один из возможных остовов).</li>
<li>Минимальный остов является также и <b>остовом с минимальным произведением</b> весов рёбер.<br>(доказывается это легко, достаточно заменить веса всех рёбер на их логарифмы)</li>
<li>Минимальный остов является также и <b>остовом с минимальным весом самого тяжелого ребра</b>.<br>(это утверждение следует из справедливости алгоритма Крускала)</li>
<li><b>Остов максимального веса</b> ищется аналогично остову минимального веса, достаточно поменять знаки всех рёбер на противоположные и выполнить любой из алгоритм минимального остова.</li>
</ul>
<h3>Алгоритм Крускала</h3>
<p>Данный алгоритм был описан Крускалом (Kruskal) в 1956 г.</p>
<p>Алгоритм Крускала изначально помещает каждую вершину в своё дерево, а затем постепенно объединяет эти деревья, объединяя на каждой итерации два некоторых дерева некоторым ребром. Перед началом выполнения алгоритма, все рёбра сортируются по весу (в порядке неубывания). Затем начинается процесс объединения: перебираются все рёбра от первого до последнего (в порядке сортировки), и если у текущего ребра его концы принадлежат разным поддеревьям, то эти поддеревья объединяются, а ребро добавляется к ответу. По окончании перебора всех рёбер все вершины окажутся принадлежащими одному поддереву, и ответ найден.</p>
<h3>Простейшая реализация</h3>
<p>Этот код самым непосредственным образом реализует описанный выше алгоритм, и выполняется за <b>O (M log N + N<sup>2</sup>)</b>. Сортировка рёбер потребует O (M log N) операций. Принадлежность вершины тому или иному поддереву хранится просто с помощью массива tree_id - в нём для каждой вершины хранится номер дерева, которому она принадлежит. Для каждого ребра мы за O (1) определяем, принадлежат ли его концы разным деревьям. Наконец, объединение двух деревьев осуществляется за O (N) простым проходом по массиву tree_id. Учитывая, что всего операций объединения будет N-1, мы и получаем асимптотику <b>O (M log N + N<sup>2</sup>)</b>.</p>
<pre>int m;
vector &lt; pair &lt; int, pair&lt;int,int> > > g (m); // вес - вершина 1 - вершина 2

int cost = 0;
vector &lt; pair&lt;int,int> > res;

sort (g.begin(), g.end());
vector&lt;int> tree_id (n);
for (int i=0; i&lt;n; ++i)
	tree_id[i] = i;
for (int i=0; i&lt;m; ++i)
{
	int a = g[i].second.first,  b = g[i].second.second,  l = g[i].first;
	if (tree_id[a] != tree_id[b])
	{
		cost += l;
		res.push_back (make_pair (a, b));
		int old_id = tree_id[b],  new_id = tree_id[a];
		for (int j=0; j&lt;n; ++j)
			if (tree_id[j] == old_id)
				tree_id[j] = new_id;
	}
}</pre>
<h3>Улучшенная реализация</h3>
<p>С использованием структуры данных <a href="dsu.html">"Система непересекающихся множеств"</a> можно написать более быструю реализацию <a href="mst_kruskal_with_dsu.html">алгоритма Крускала с асимптотикой O (M log N)</a>.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>