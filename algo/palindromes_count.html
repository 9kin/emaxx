<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Нахождение всех подпалиндромов</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 23 Aug 2008 21:00<br>редактировано: 5 Apr 2012 23:14</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="palindromes_count.html#" id="contents-hide">[скрыть]</a><a href="palindromes_count.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Нахождение всех подпалиндромов </h1><p><p><h2 style="padding-top:40px;"> Постановка задачи </h2><p>Дана строка <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> длины <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Требуется найти все такие пары <img class=tex src="../tex2png/cache/df9c3aa69e88ca097b0e7196d6b2dfed.png" alt="(i,j)">, где <img class=tex src="../tex2png/cache/118d6fa21b7e03a54aadada264086399.png" alt="i<j">, что подстрока <img class=tex src="../tex2png/cache/1da9aede35685d45e082c44a363fe070.png" alt="s[i \ldots j]"> является палиндромом (т.е. читается одинаково слева направо и справа налево).<p><p><h3 style="padding-top:15px;"> Уточнение постановки </h3><p>Понятно, что в худшем случае таких подстрок-палиндромов может быть <img class=tex src="../tex2png/cache/712c5a4a9bec3c435e92314194c99f95.png" alt="O(n^2)">, и на первый взгляд кажется, что алгоритма с линейной асимптотикой существовать не может.<p>Однако информацию о найденных палиндромах можно возвращать более <b>компактно</b>: для каждой позиции <img class=tex src="../tex2png/cache/4c4774df26fa3ba9766d58b6c7474f71.png" alt="i=0 \ldots n-1"> найдём значения <img class=tex src="../tex2png/cache/fdea1519ac63ab740073938a912fec97.png" alt="d_1[i]"> и <img class=tex src="../tex2png/cache/7292b537dfd251d131ec04248fe622d6.png" alt="d_2[i]">, обозначающие количество палиндромов соответственно нечётной и чётной длины с центром в позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">.<p>Например, в строке <img class=tex src="../tex2png/cache/dbe2ae64b08c1371c96a076cceff186e.png" alt="s = abababc"> есть три палиндрома нечётной длины с центром в символе <img class=tex src="../tex2png/cache/061628e2319d702870ba4b5882ad3c43.png" alt="s[3]=b">, т.е. значение <img class=tex src="../tex2png/cache/6c387ad9532deecdafe800a7a21adbbf.png" alt="d_1[3]=3">:<p><p class=formula><img class=tex src="../tex2png/cache/5ea1a4671b52683481a189efd45518b2.png" alt=" a\ \overbrace{b\ a\ \underbrace{b}_{s_3}\ a\ b}^{[...]"></p><p>А в строке <img class=tex src="../tex2png/cache/1b58d72135c4b0897c4c64fc9eaf7cae.png" alt="s = cbaabd"> есть два палиндрома чётной длины с центром в символе <img class=tex src="../tex2png/cache/c1241003e23528adc38ba1161c34df38.png" alt="s[3]=a">, т.е. значение <img class=tex src="../tex2png/cache/debc66f1fb8ec9ff8b304cc983b4ec44.png" alt="d_2[3]=2">:<p><p class=formula><img class=tex src="../tex2png/cache/3dc8e6a87f45ef76f1444a9fee7ea788.png" alt=" c\ \overbrace{b\ a\ \underbrace{a}_{s_3}\ b}^{d_2[...]"></p><p>Т.е. идея &mdash; в том, что если есть подпалиндром длины <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> с центром в какой-то позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, то есть также подпалиндромы длины <img class=tex src="../tex2png/cache/40dc605af6b918a409fe4515e114e52b.png" alt="l-2">, <img class=tex src="../tex2png/cache/23c19c1c86159a9a748f7c26bddc766f.png" alt="l-4">, и т.д. с центрами в <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">. Поэтому двух таких массивов <img class=tex src="../tex2png/cache/fdea1519ac63ab740073938a912fec97.png" alt="d_1[i]"> и <img class=tex src="../tex2png/cache/7292b537dfd251d131ec04248fe622d6.png" alt="d_2[i]"> достаточно для хранения информации обо всех подпалиндромах этой строки.<p>Достаточно неожиданным фактом является то, что существует довольно простой алгоритм, который вычисляет эти "массивы палиндромностей" <img class=tex src="../tex2png/cache/8bf2230c909386a4c3d4559e56564b79.png" alt="d_1[]"> и <img class=tex src="../tex2png/cache/c163efcdd6d96d4a3bd8ee36eedf4277.png" alt="d_2[]"> за линейное время. Этот алгоритм и описывается в данной статье.<p><p><h2 style="padding-top:40px;"> Решение </h2><p>Вообще говоря, данная задача имеет несколько известных решений: с помощью <a href="string_hashes.html">техники хэширования</a> её можно решить за <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">, а с помощью <a href="ukkonen.html">суффиксных деревьев</a> и <a href="lca_linear.html">быстрого алгоритма LCA</a> эту задачу можно решить за <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)">.<p>Однако описываемый в данной статье метод значительно проще, и обладает меньшими скрытыми константами в асимптотике времени и памяти. Этот алгоритм был открыт <b>Гленном Манакером (Glenn Manacher)</b> в 1975 г.<p><p><h3 style="padding-top:15px;"> Тривиальный алгоритм </h3><p>Во избежание неоднозначностей при дальнейшем описании условимся, что же такое есть "тривиальный алгоритм".<p>Это алгоритм, который для поиска ответа в позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> раз за разом пробует увеличить ответ на единицу, каждый раз сравнивая пару соответствующих символов.<p>Такой алгоритм слишком медленен, весь ответ он может посчитать лишь за время <img class=tex src="../tex2png/cache/4cd2772b06262896a7cf8a9d3c989ea4.png" alt="O (n^2)">.<p>Приведём для наглядности его реализацию:<p><pre class="notranslate cpp">vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> d1 <span class="br0">&#40;</span>n<span class="br0">&#41;</span>,  d2 <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	d1<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>i<span class="sy2">-</span>d1<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&gt;=</span> <span class="nu0">0</span> <span class="sy3">&amp;&amp;</span> i<span class="sy2">+</span>d1<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&lt;</span> n <span class="sy3">&amp;&amp;</span> s<span class="br0">&#91;</span>i<span class="sy2">-</span>d1<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">==</span> s<span class="br0">&#91;</span>i<span class="sy2">+</span>d1<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#41;</span>
		<span class="sy2">++</span>d1<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
	d2<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>i<span class="sy2">-</span>d2<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy2">-</span><span class="nu0">1</span> <span class="sy1">&gt;=</span> <span class="nu0">0</span> <span class="sy3">&amp;&amp;</span> i<span class="sy2">+</span>d2<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">&lt;</span> n <span class="sy3">&amp;&amp;</span> s<span class="br0">&#91;</span>i<span class="sy2">-</span>d2<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy1">==</span> s<span class="br0">&#91;</span>i<span class="sy2">+</span>d2<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#41;</span>
		<span class="sy2">++</span>d2<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h3 style="padding-top:15px;"> Алгоритм Манакера </h3><p>Научимся сначала находить все подпалиндромы нечётной длины, т.е. вычислять массив <img class=tex src="../tex2png/cache/8bf2230c909386a4c3d4559e56564b79.png" alt="d_1[]">; решение для палиндромов чётной длины (т.е. нахождение массива <img class=tex src="../tex2png/cache/c163efcdd6d96d4a3bd8ee36eedf4277.png" alt="d_2[]">) получится небольшой модификацией этого.<p>Для быстрого вычисления будем поддерживать <b>границы <img class=tex src="../tex2png/cache/5da5090de09ee020bba6974c7d377e42.png" alt="(l,r)"></b> самого правого из обнаруженных подпалиндрома (т.е. подпалиндрома с наибольшим значением <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">). Изначально можно положить <img class=tex src="../tex2png/cache/f11ec16fe243115e280c86541f829469.png" alt="l=0, r=-1">.<p>Итак, пусть мы хотим вычислить значение <img class=tex src="../tex2png/cache/fdea1519ac63ab740073938a912fec97.png" alt="d_1[i]"> для очередного <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, при этом все предыдущие значения <img class=tex src="../tex2png/cache/8bf2230c909386a4c3d4559e56564b79.png" alt="d_1[]"> уже подсчитаны.<p><p><ul><p><li>Если <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> не находится в пределах текущего подпалиндрома, т.е. <img class=tex src="../tex2png/cache/6f0f72bd3c789e099a682350167fd333.png" alt="i > r">, то просто выполним тривиальный алгоритм.<p>Т.е. будем последовательно увеличивать значение <img class=tex src="../tex2png/cache/fdea1519ac63ab740073938a912fec97.png" alt="d_1[i]">, и проверять каждый раз &mdash; правда ли текущая подстрока <img class=tex src="../tex2png/cache/87f223f7929f3a606932f069e668d793.png" alt="[i-d_1[i]; i+d_1[i]]"> является палиндромом. Когда мы найдём первое расхождение, либо когда мы дойдём до границ строки <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> &mdash; останавливаемся: мы окончательно посчитали значение <img class=tex src="../tex2png/cache/fdea1519ac63ab740073938a912fec97.png" alt="d_1[i]">. После этого мы должны не забыть обновить значения <img class=tex src="../tex2png/cache/5da5090de09ee020bba6974c7d377e42.png" alt="(l,r)">.<p><li>Рассмотрим теперь случай, когда <img class=tex src="../tex2png/cache/57881cc557940d4267652ffd3cdaac9c.png" alt="i \le r">.<p>Попробуем извлечь часть информации из уже подсчитанных значений <img class=tex src="../tex2png/cache/8bf2230c909386a4c3d4559e56564b79.png" alt="d_1[]">. А именно, отразим позицию <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> внутри подпалиндрома <img class=tex src="../tex2png/cache/5da5090de09ee020bba6974c7d377e42.png" alt="(l,r)">, т.е. получим позицию <img class=tex src="../tex2png/cache/26eeaa95af50829e30e0bc130e417778.png" alt="j = l + (r - i)">, и рассмотрим значение <img class=tex src="../tex2png/cache/02e1917ca8a2f51d3032b4d9fd85d7ef.png" alt="d_1[j]">. Поскольку <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> &mdash; позиция, симметричная позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, то <b>почти всегда</b> мы можем просто присвоить <img class=tex src="../tex2png/cache/5ed64a8a448046984ace4e7bd918368e.png" alt="d_1[i] = d_1[j]">. Иллюстрация этого отражения (палиндром вокруг <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> фактически "копируется" в палиндром вокруг <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">):<p><p class=formula><img class=tex src="../tex2png/cache/48d444382153b592b92a017c9f046479.png" alt=" \ldots \overbrace{s_l\ \ldots\ \underbrace{s_{j-d[...]"></p><p>Однако здесь есть <b>тонкость</b>, которую надо обработать правильно: когда "внутренний палиндром" достигает границы внешнего или вылазит за неё, т.е. <img class=tex src="../tex2png/cache/5554f7ff5118454d74fc002c7ddb1977.png" alt="j-d_1[j]+1 \le l"> (или, что то же самое, <img class=tex src="../tex2png/cache/eb8968b6fda69be8e6a788849e470895.png" alt="i+d_1[j]-1 \ge r">). Поскольку за границами внешнего палиндрома никакой симметрии не гарантируется, то просто присвоить <img class=tex src="../tex2png/cache/5ed64a8a448046984ace4e7bd918368e.png" alt="d_1[i] = d_1[j]"> будет уже некорректно: у нас недостаточно сведений, чтобы утверждать, что в позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> подпалиндром имеет такую же длину.<p>На самом деле, чтобы правильно обрабатывать такие ситуации, надо "обрезать" длину подпалиндрома, т.е. присвоить <img class=tex src="../tex2png/cache/e7d13dbb3e35aaf06a14e9bd0a7facb7.png" alt="d_1[i] = r - i">. После этого следует пустить тривиальный алгоритм, который будет пытаться увеличить значение <img class=tex src="../tex2png/cache/fdea1519ac63ab740073938a912fec97.png" alt="d_1[i]">, пока это возможно.<p>Иллюстрация этого случая (на ней палиндром с центром в <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> изображён уже "обрезанным" до такой длины, что он впритык помещается во внешний палиндром):<p><p class=formula><img class=tex src="../tex2png/cache/8f4fc0dfca0358f580d1f5f0f8804f95.png" alt=" \ldots \overbrace{\underbrace{s_l\ \ldots\ s_j\ \[...]"></p><p>(На этой иллюстрации показано, что, хотя палиндром с центром в позиции <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> мог быть и более длинным, выходящим за пределы внешнего палиндрома, &mdash; но в позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> мы можем использовать только ту его часть, которая целиком помещается во внешний палиндром. Но ответ для позиции <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> может быть больше, чем эта часть, поэтому дальше мы должны запустить тривиальный поиск, который будет пытаться раздвинуть его за пределы внешнего палиндрома, т.е. в область "try moving here".)<p></ul><p>В завершение описания алгоритма сталось только напомнить, что надо не забывать обновлять значения <img class=tex src="../tex2png/cache/5da5090de09ee020bba6974c7d377e42.png" alt="(l,r)"> после вычисления очередного значения <img class=tex src="../tex2png/cache/fdea1519ac63ab740073938a912fec97.png" alt="d_1[i]">.<p>Также повторимся, что выше мы описали рассуждения для вычисления массива нечётных палиндромов <img class=tex src="../tex2png/cache/8bf2230c909386a4c3d4559e56564b79.png" alt="d_1[]">; для массива чётных палиндромов <img class=tex src="../tex2png/cache/c163efcdd6d96d4a3bd8ee36eedf4277.png" alt="d_2[]"> все рассуждения аналогичны.<p><p><h3 style="padding-top:15px;"> Оценка асимптотики алгоритма Манакера </h3><p>На первый взгляд не очевидно, что данный алгоритм имеет линейную асимптотику: при вычислении ответа для определённой позиции в нём нередко запускается тривиальный алгоритм поиска палиндромов.<p>Однако более внимательный анализ показывает, что алгоритм всё же линеен. (Стоит сослаться на известный <a href="z_function.html">алгоритм построения Z-функции строки</a>, который внутренне сильно напоминает данный алгоритм, и работает также за линейное время.)<p>В самом деле, легко проследить по алгоритму, что каждая итерация, производимая тривиальным поиском, приводит к увеличению на один границы <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">. При этом уменьшений <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> по ходу алгоритма происходить не может. Следовательно, тривиальный алгоритм в сумме совершит лишь <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> действий.<p>Учитывая, что, кроме тривиальных поисков, все остальные части алгоритма Манакера очевидно работают за линейное время, мы и получаем итоговую асимптотику: <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">.<p><p><h3 style="padding-top:15px;"> Реализация алгоритма Манакера </h3><p>Для случая подпалиндромов нечётной длины, т.е. для вычисления массива <img class=tex src="../tex2png/cache/8bf2230c909386a4c3d4559e56564b79.png" alt="d_1[]">, получаем такой код:<p><pre class="notranslate cpp">vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> d1 <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw4">int</span> l<span class="sy1">=</span><span class="nu0">0</span>, r<span class="sy1">=</span><span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> k <span class="sy1">=</span> <span class="br0">&#40;</span>i<span class="sy1">&gt;</span>r <span class="sy4">?</span> <span class="nu0">0</span> <span class="sy4">:</span> min <span class="br0">&#40;</span>d1<span class="br0">&#91;</span>l<span class="sy2">+</span>r<span class="sy2">-</span>i<span class="br0">&#93;</span>, r<span class="sy2">-</span>i<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>i<span class="sy2">+</span>k <span class="sy1">&lt;</span> n <span class="sy3">&amp;&amp;</span> i<span class="sy2">-</span>k <span class="sy1">&gt;=</span> <span class="nu0">0</span> <span class="sy3">&amp;&amp;</span> s<span class="br0">&#91;</span>i<span class="sy2">+</span>k<span class="br0">&#93;</span> <span class="sy1">==</span> s<span class="br0">&#91;</span>i<span class="sy2">-</span>k<span class="br0">&#93;</span><span class="br0">&#41;</span>  <span class="sy2">++</span>k<span class="sy4">;</span>
	d1<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> k<span class="sy2">--</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>i<span class="sy2">+</span>k <span class="sy1">&gt;</span> r<span class="br0">&#41;</span>
		l <span class="sy1">=</span> i<span class="sy2">-</span>k,  r <span class="sy1">=</span> i<span class="sy2">+</span>k<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Для подпалиндромов чётной длины, т.е. для вычисления массива <img class=tex src="../tex2png/cache/c163efcdd6d96d4a3bd8ee36eedf4277.png" alt="d_2[]">, лишь немного меняются арифметические выражения:<p><pre class="notranslate cpp">vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> d2 <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
l<span class="sy1">=</span><span class="nu0">0</span>, r<span class="sy1">=</span><span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> k <span class="sy1">=</span> <span class="br0">&#40;</span>i<span class="sy1">&gt;</span>r <span class="sy4">?</span> <span class="nu0">0</span> <span class="sy4">:</span> min <span class="br0">&#40;</span>d2<span class="br0">&#91;</span>l<span class="sy2">+</span>r<span class="sy2">-</span>i<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span>, r<span class="sy2">-</span>i<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>i<span class="sy2">+</span>k<span class="sy2">-</span><span class="nu0">1</span> <span class="sy1">&lt;</span> n <span class="sy3">&amp;&amp;</span> i<span class="sy2">-</span>k <span class="sy1">&gt;=</span> <span class="nu0">0</span> <span class="sy3">&amp;&amp;</span> s<span class="br0">&#91;</span>i<span class="sy2">+</span>k<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy1">==</span> s<span class="br0">&#91;</span>i<span class="sy2">-</span>k<span class="br0">&#93;</span><span class="br0">&#41;</span>  <span class="sy2">++</span>k<span class="sy4">;</span>
	d2<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="sy2">--</span>k<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>i<span class="sy2">+</span>k<span class="sy2">-</span><span class="nu0">1</span> <span class="sy1">&gt;</span> r<span class="br0">&#41;</span>
		l <span class="sy1">=</span> i<span class="sy2">-</span>k,  r <span class="sy1">=</span> i<span class="sy2">+</span>k<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Список задач, которые можно сдать с использованием этого алгоритма:<p><ul><p><li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2470">UVA #11475 <b>"Extend to Palindrome"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>