<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Задача Иосифа</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 11 Jun 2008 11:25<br>редактировано: 14 Oct 2011 0:05</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="joseph_problem.html#" id="contents-hide">[скрыть]</a><a href="joseph_problem.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Задача Иосифа</h1><p>Условие задачи. Даны натуральные <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> и <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">. По кругу выписывают все натуральные числа от 1 до <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">. Сначала отсчитывают <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ое число, начиная с первого, и удаляют его. Затем от него отсчитывают <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> чисел и <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ое удаляют, и т.д. Процесс останавливается, когда остаётся одно число. Требуется найти это число.<p>Задача была поставлена <b>Иосифом Флавием</b> (Flavius Josephus) ещё в 1 веке (правда, в несколько более узкой формулировке: при <img class=tex src="../tex2png/cache/4eee04dc9a729aa9a9562138e64d6a9d.png" alt="k = 2">).<p>Решать эту задачу можно моделированием. Простейшее моделирование будет работать <img class=tex src="../tex2png/cache/4cd2772b06262896a7cf8a9d3c989ea4.png" alt="O (n^2)">. Используя <a href="segment_tree.html">Дерево отрезков</a>, можно произвести моделирование за <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">.<p><h2 style="padding-top:40px;">Решение за <img class=tex src="../tex2png/cache/654ea86093c7e0ad5670201fa452da08.png" alt="O(n)"></h2><p>Попытаемся найти закономерность, выражающую ответ для задачи <img class=tex src="../tex2png/cache/65357636f57e4b250c114bbb9006a5a8.png" alt="J_{n,k}"> через решение предыдущих задач.<p>С помощью моделирования построим таблицу значений, например, такую:<p><p class=formula><img class=tex src="../tex2png/cache/7c22e1659a058076cce91fcb77486072.png" alt=" \bordermatrix {
n \setminus k&1&2&3&4&5&6&7&8&9&[...]"></p><p>И здесь достаточно отчётливо видна следующая <b>закономерность</b>:<p class=formula><img class=tex src="../tex2png/cache/80f20fb43ce2018e670d4afbcbaa1287.png" alt=" J_{n,k} = \left( J_{(n-1),k} + k - 1 \right)\ \%\[...]"><br><img class=tex src="../tex2png/cache/a6781eae028f84e178b2bfbed03e0dd1.png" alt=" J_{1,k} = 1 "></p><p>Здесь 1-индексация несколько портит элегантность формулы, если нумеровать позиции с нуля, то получится очень наглядная формула:<p><p class=formula><img class=tex src="../tex2png/cache/e31a6a8b1c05ac13b5d741e210236b2a.png" alt=" J_{n,k} = \left( J_{(n-1),k} + k \right)\ \%\ n =[...]"></p><p>Итак, мы нашли решение задачи Иосифа, работающее за <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"> операций.<p>Простая <b>рекурсивная реализация</b> (в 1-индексации):<pre class="notranslate cpp"><span class="kw4">int</span> joseph <span class="br0">&#40;</span><span class="kw4">int</span> n, <span class="kw4">int</span> k<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">return</span> n<span class="sy1">&gt;</span><span class="nu0">1</span> <span class="sy4">?</span> <span class="br0">&#40;</span>joseph <span class="br0">&#40;</span>n<span class="sy2">-</span><span class="nu0">1</span>, k<span class="br0">&#41;</span> <span class="sy2">+</span> k <span class="sy2">-</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy2">%</span> n <span class="sy2">+</span> <span class="nu0">1</span> <span class="sy4">:</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><b>Нерекурсивная форма</b>:<pre class="notranslate cpp"><span class="kw4">int</span> joseph <span class="br0">&#40;</span><span class="kw4">int</span> n, <span class="kw4">int</span> k<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> res <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;=</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		res <span class="sy1">=</span> <span class="br0">&#40;</span>res <span class="sy2">+</span> k<span class="br0">&#41;</span> <span class="sy2">%</span> i<span class="sy4">;</span>
	<span class="kw1">return</span> res <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><h2 style="padding-top:40px;">Решение за <img class=tex src="../tex2png/cache/542bcb8b7110bbc01b9e7ba0591f4937.png" alt="O(k \log n)"></h2><p>Для сравнительно небольших <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> можно придумать более оптимальное решение, чем рассмотренное выше рекурсивное решение за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">. Если <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> небольшое, то даже интуитивно понятно, что тот алгоритм делает много лишних действий: серьёзные изменения происходят, только когда происходит взятие по модулю <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, а до этого момента алгоритм просто несколько раз прибавляет к ответу число <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">. Соответственно, можно избавиться от этих ненужных шагов, <p>Небольшая возникающая при этом сложность заключается в том, что после удаления этих чисел у нас получится задача с меньшим <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, но стартовой позицией не в первом числе, а где-то в другом месте. Поэтому, вызвав рекурсивно себя от задачи с новым <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, мы затем должны аккуратно перевести результат в нашу систему нумерации из его собственной.<p>Также отдельно надо разбирать случай, когда <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> станет меньше <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> &mdash; в этом случае вышеописанная оптимизация выродится в бесконечный цикл.<p><b>Реализация</b> (для удобства в 0-индексации):<pre class="notranslate cpp"><span class="kw4">int</span> joseph <span class="br0">&#40;</span><span class="kw4">int</span> n, <span class="kw4">int</span> k<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>n <span class="sy1">==</span> <span class="nu0">1</span><span class="br0">&#41;</span>  <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>k <span class="sy1">==</span> <span class="nu0">1</span><span class="br0">&#41;</span>  <span class="kw1">return</span> n<span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>k <span class="sy1">&gt;</span> n<span class="br0">&#41;</span>  <span class="kw1">return</span> <span class="br0">&#40;</span>joseph <span class="br0">&#40;</span>n<span class="sy2">-</span><span class="nu0">1</span>, k<span class="br0">&#41;</span> <span class="sy2">+</span> k<span class="br0">&#41;</span> <span class="sy2">%</span> n<span class="sy4">;</span>
	<span class="kw4">int</span> cnt <span class="sy1">=</span> n <span class="sy2">/</span> k<span class="sy4">;</span>
	<span class="kw4">int</span> res <span class="sy1">=</span> joseph <span class="br0">&#40;</span>n <span class="sy2">-</span> cnt, k<span class="br0">&#41;</span><span class="sy4">;</span>
	res <span class="sy2">-</span><span class="sy1">=</span> n <span class="sy2">%</span> k<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>res <span class="sy1">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span>  res <span class="sy2">+</span><span class="sy1">=</span> n<span class="sy4">;</span>
	<span class="kw1">else</span>  res <span class="sy2">+</span><span class="sy1">=</span> res <span class="sy2">/</span> <span class="br0">&#40;</span>k <span class="sy2">-</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">return</span> res<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Оценим <b>асимптотику</b> этого алгоритма. Сразу заметим, что случай <img class=tex src="../tex2png/cache/001df123136ce140f4392caea2aaf899.png" alt="n < k"> разбирается у нас старым решением, которое отработает в данном случае за <img class=tex src="../tex2png/cache/ac686865eeed9866e9f70fcbc1e9b6e5.png" alt="O(k)">. Теперь рассмотрим сам алгоритм. Фактически, на каждой его итерации вместо <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> чисел мы получаем примерно <img class=tex src="../tex2png/cache/e6216a6b57a8d8a0557ac5648f4062eb.png" alt="n \left( 1 - \frac{1}{k} \right)"> чисел, поэтому общее число <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> итераций алгоритма примерно можно найти из уравнения:<p class=formula><img class=tex src="../tex2png/cache/f1d722326438adda0a9e2fbfb3d1544c.png" alt=" n \left( 1 - \frac{1}{k} \right) ^ x = 1, "></p>логарифмируя его, получаем:<p class=formula><img class=tex src="../tex2png/cache/f57e1efa9a9e8052c80af1215ad953f8.png" alt=" \ln n + x \ln \left( 1 - \frac{1}{k} \right) = 0,[...]"><br><img class=tex src="../tex2png/cache/e06de24bbc9d5de1a2c44554f7b48093.png" alt=" x = - \frac{ \ln n }{ \ln \left( 1 - \frac{1}{k} [...]"></p>пользуясь разложением логарифма в ряд Тейлора, получаем приблизительную оценку:<p class=formula><img class=tex src="../tex2png/cache/6130494ae114f43ea9015078a6ea291c.png" alt=" x \approx k \ln n "></p><p>Таким образом, асимптотика алгоритма действительно <img class=tex src="../tex2png/cache/ce0e7969d23f57fd9cffc40f419d6fc3.png" alt="O(k \log n)">.<p><h2 style="padding-top:40px;">Аналитическое решение для <img class=tex src="../tex2png/cache/d448ed3d1b80bfe49d6e50c7aa15f241.png" alt="k=2"></h2><p>В этом частном случае (в котором и была поставлена эта задача Иосифом Флавием) задача решается значительно проще.<p>В случае чётного <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> получаем, что будут вычеркнуты все чётные числа, а потом останется задача для <img class=tex src="../tex2png/cache/27264be5a86a5582a09f5125b65c7c36.png" alt="\frac{n}{2}">, тогда ответ для <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> будет получаться из ответа для <img class=tex src="../tex2png/cache/27264be5a86a5582a09f5125b65c7c36.png" alt="\frac{n}{2}"> умножением на два и вычитанием единицы (за счёт сдвига позиций):<p><p class=formula><img class=tex src="../tex2png/cache/9fd76074dd107d148fdc942395ed639d.png" alt=" J_{2n,2} = 2 J_{n,2} - 1 "></p><p>Аналогично, в случае нечётного <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> будут вычеркнуты все чётные числа, затем первое число, и останется задача для <img class=tex src="../tex2png/cache/04520bbd022e4a6b2ce6a559928a7a05.png" alt="\frac{n-1}{2}">, и с учётом сдвига позиций получаем вторую формулу:<p><p class=formula><img class=tex src="../tex2png/cache/04983b887b4ce752d4e337ad70b9e5f8.png" alt=" J_{2n+1,2} = 2 J_{n,2} + 1 "></p><p>При реализации можно непосредственно использовать эту рекуррентную зависимость. Можно эту закономерность перевести в другую форму: <img class=tex src="../tex2png/cache/14d34192cab97108371268c54ee6d8d1.png" alt="J_{n,2}"> представляют собой последовательность всех нечётных чисел, "перезапускающуюся" с единицы всякий раз, когда <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> оказывается степенью двойки. Это можно записать и в виде одной формулы:<p><p class=formula><img class=tex src="../tex2png/cache/a262aa4ea1e0e2967300fe22a307981c.png" alt=" J_{n,2} = 1 + 2 \left( n - 2^{\lfloor \log_2 n \r[...]"></p><p><h2 style="padding-top:40px;">Аналитическое решение для <img class=tex src="../tex2png/cache/43edb7016c3d3dcf04cb72080394855c.png" alt="k>2"></h2><p>Несмотря на простой вид задачи и большое количество статей по этой и смежным задачам, простого аналитического представления решения задачи Иосифа до сих пор не найдено. Для небольших <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> выведены некоторые формулы, но, по-видимому, все они трудноприменимы на практике (например, см. Halbeisen, Hungerbuhler "The Josephus Problem" и Odlyzko, Wilf "Functional iteration and the Josephus problem").<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>