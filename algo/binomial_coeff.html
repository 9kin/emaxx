<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Биномиальные коэффициенты</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 11 Jun 2008 11:15<br>редактировано: 17 Sep 2010 22:19</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="binomial_coeff.html#" id="contents-hide">[скрыть]</a><a href="binomial_coeff.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Биномиальные коэффициенты</h1><p>Биномиальным коэффициентом <img class=tex src="../tex2png/cache/c9a0f1213ba475c08fdecd5df29a7fdd.png" alt="C_n^k"> называется количество способов выбрать набор <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> предметов из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> различных предметов без учёта порядка расположения этих элементов (т.е. количество неупорядоченных наборов).<p>Также биномиальные коэффициенты - это коффициенты в разложении <img class=tex src="../tex2png/cache/2b79fe963c51eb8691c990b12eff6aee.png" alt="(a+b)^n"> (т.н. бином Ньютона):<p><p class=formula><img class=tex src="../tex2png/cache/0357c5f721640a5a6e34c2315df4923f.png" alt=" (a+b)^n = C_n^0 a^n + C_n^1 a^{n-1} b + C_n^2 a^{[...]"></p><p>Считается, что эту формулу, как и треугольник, позволяющий эффективно находить коэффициенты, открыл Блез Паскаль (Blaise Pascal), живший в 17 в. Тем не менее, она была известна ещё китайскому математику Яну Хуэю (Yang Hui), жившему в 13 в. Возможно, её открыл персидский учёный Омар Хайям (Omar Khayyam). Более того, индийский математик Пингала (Pingala), живший ещё в 3 в. до н.э., получил близкие результаты. Заслуга же Ньютона заключается в том, что он обобщил эту формулу для степеней, не являющихся натуральными.<p><h2 style="padding-top:40px;">Вычисление</h2><p><b>Аналитическая формула</b> для вычисления:<p><p class=formula><img class=tex src="../tex2png/cache/c3c165b11abfcc9c21ae4b1bb7df43b2.png" alt=" C_n^k = \frac{n!}{k! (n-k)!} "></p><p>Эту формулу легко вывести из задачи о неупорядоченной выборке (количество способов неупорядоченно выбрать <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> элементов из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> элементов). Сначала посчитаем количество упорядоченных выборок. Выбрать первый элемент есть <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> способов, второй &mdash; <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">, третий &mdash; <img class=tex src="../tex2png/cache/3c24e4e1066ea76ff7ba0fb29a761758.png" alt="n-2">, и так далее. В результате для числа упорядоченных выборок получаем формулу: <img class=tex src="../tex2png/cache/1724c2980d20ce6be5d6bf43a3f3a85f.png" alt=" n (n-1) (n-2) \ldots (n-k+1) = \frac{n!}{(n-k)!} ">. К неупорядоченным выборкам легко перейти, если заметить, что каждой неупорядоченной выборке соответствует ровно <img class=tex src="../tex2png/cache/d116f26bdeb8727b7a0e4166338608cd.png" alt="k!"> упорядоченных (т.к. это количество всевозможных перестановок <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> элементов). В результате, деля <img class=tex src="../tex2png/cache/a1f785b773a1d252ec9281ab14ac0041.png" alt="\frac{n!}{(n-k)!}"> на <img class=tex src="../tex2png/cache/d116f26bdeb8727b7a0e4166338608cd.png" alt="k!">, мы и получаем искомую формулу.<p><b>Рекуррентная формула</b> (с которой связан знаменитый "треугольник Паскаля"):<p><p class=formula><img class=tex src="../tex2png/cache/ea852aab5fda4c83b24f90a04474383e.png" alt=" C_n^k = C_{n-1}^{k-1} + C_{n-1}^k "></p><p>Её легко вывести через предыдущую формулу.<p>Стоит заметить особо, при <img class=tex src="../tex2png/cache/8047ac438c83cadf4b6d4ff02917dc82.png" alt="n<k"> значение <img class=tex src="../tex2png/cache/c9a0f1213ba475c08fdecd5df29a7fdd.png" alt="C_n^k"> всегда полагается равным нулю.<p><h2 style="padding-top:40px;">Свойства</h2><p>Биномиальные коэффициенты обладают множеством различных свойств, приведём наиболее простые из них:<p><ul><li>Правило симметрии:<p class=formula><img class=tex src="../tex2png/cache/366347a902f6de3a2ce58cace1a68d71.png" alt=" C_n^k = C_n^{n-k} "></p><li>Внесение-вынесение:<p class=formula><img class=tex src="../tex2png/cache/b489d57e64375d2665bc809786e27543.png" alt=" C_n^k = \frac{n}{k} C_{n-1}^{k-1} "></p><li>Суммирование по <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">:<p class=formula><img class=tex src="../tex2png/cache/b94a861b2ee7782d52d7574d82f459db.png" alt=" \sum_{k=0}^n C_n^k = 2^n "></p><li>Суммирование по <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">:<p class=formula><img class=tex src="../tex2png/cache/774a4b2f484df43ab4882b5534c5fb7f.png" alt=" \sum_{m=0}^n C_m^k = C_{n+1}^{k+1} "></p><li>Суммирование по <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> и <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">:<p class=formula><img class=tex src="../tex2png/cache/143097e64c4f9b9fa41b3a44baa3d221.png" alt=" \sum_{k=0}^{m} C_{n+k}^k = C_{n+m+1}^m "></p><li>Суммирование квадратов:<p class=formula><img class=tex src="../tex2png/cache/66764f3a0a279f3bfddfebd551a5e6ab.png" alt=" (C_n^0)^2 + (C_n^1)^2 + \ldots + (C_n^n)^2 = C_{2[...]"></p><li>Взвешенное суммирование:<p class=formula><img class=tex src="../tex2png/cache/63bf7979cef5aab6847d67efe78b8ec0.png" alt=" 1 C_n^1 + 2 C_n^2 + \ldots + n C_n^n = n 2^{n-1} "></p><li>Cвязь с <a href="fibonacci_numbers.html">числами Фибоначчи</a>:<p class=formula><img class=tex src="../tex2png/cache/afc8fdf3e346c7094fae8da74bbe4e4c.png" alt=" C_n^0 + C_{n-1}^1 + \ldots + C_{n-k}^k + \ldots +[...]"></p></ul><p><p><h2 style="padding-top:40px;"> Вычисления в программе </h2><p><h3 style="padding-top:15px;"> Непосредственные вычисления по аналитической формуле </h3><p>Вычисления по первой, непосредственной формуле, очень легко программировать, однако этот способ подвержен переполнениям даже при сравнительно небольших значениях <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> и <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> (даже если ответ вполне помещается в какой-нибудь тип данных, вычисление промежуточных факториалов может привести к переполнению). Поэтому очень часто этот способ можно применять только вместе с [[Длинная арифметика|Длинной арифметикой]]:<p><pre class="notranslate cpp">&nbsp;
<span class="kw4">int</span> C <span class="br0">&#40;</span><span class="kw4">int</span> n, <span class="kw4">int</span> k<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> res <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>n<span class="sy2">-</span>k<span class="sy2">+</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;=</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		res <span class="sy2">*</span><span class="sy1">=</span> i<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> i<span class="sy1">&lt;=</span>k<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		res <span class="sy2">/</span><span class="sy1">=</span> i<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><h3 style="padding-top:15px;"> Улучшенная реализация </h3><p>Можно заметить, что в приведённой выше реализации в числителе и знаменателе стоит одинаковое количество сомножителей (<img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">), каждый из которых не меньше единицы. Поэтому можно заменить нашу дробь на произведение <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> дробей, каждая из которых является вещественнозначной. Однако, можно заметить, что после домножения текущего ответа на каждую очередную дробь всё равно будет получаться целое число (это, например, следует из свойства "внесения-вынесения"). Таким образом, получаем такую реализацию:<p><pre class="notranslate cpp">&nbsp;
<span class="kw4">int</span> C <span class="br0">&#40;</span><span class="kw4">int</span> n, <span class="kw4">int</span> k<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">double</span> res <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> i<span class="sy1">&lt;=</span>k<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		res <span class="sy1">=</span> res <span class="sy2">*</span> <span class="br0">&#40;</span>n<span class="sy2">-</span>k<span class="sy2">+</span>i<span class="br0">&#41;</span> <span class="sy2">/</span> i<span class="sy4">;</span>
	<span class="kw1">return</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> <span class="br0">&#40;</span>res <span class="sy2">+</span> <span class="nu16">0.01</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Здесь мы аккуратно приводим дробное число к целому, учитывая, что из-за накапливающихся погрешностей оно может оказаться чуть меньше истинного значения (например, <img class=tex src="../tex2png/cache/78c1426c5dd5c422ba7493f42ef4b342.png" alt="2.99999"> вместо трёх).<p><h3 style="padding-top:15px;"> Треугольник Паскаля </h3><p>С использованием же рекуррентного соотношения можно построить таблицу биномиальных коэффициентов (фактически, треугольник Паскаля), и из неё брать результат. Преимущество этого метода в том, что промежуточные результаты никогда не превосходят ответа, и для вычисления каждого нового элемента таблицы надо всего лишь одно сложение. Недостатком является медленная работа для больших N и K, если на самом деле таблица не нужна, а нужно единственное значение (потому что для вычисления <img class=tex src="../tex2png/cache/c9a0f1213ba475c08fdecd5df29a7fdd.png" alt="C_n^k"> понадобится строить таблицу для всех <img class=tex src="../tex2png/cache/7942e614ee910ff1ed33f5f1df674f45.png" alt="C_i^j,\ \ 1 \le i \le n,\ \ 1 \le j \le n">, или хотя бы до <img class=tex src="../tex2png/cache/5fb3faa79969dd22313f1c5c77e3bfe9.png" alt="1 \le j \le \min(i,2k)">).<p><pre class="notranslate cpp">&nbsp;
<span class="kw4">const</span> <span class="kw4">int</span> maxn <span class="sy1">=</span> ...<span class="sy4">;</span>
<span class="kw4">int</span> C<span class="br0">&#91;</span>maxn<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#91;</span>maxn<span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> n<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> n<span class="sy1">&lt;=</span>maxn<span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	C<span class="br0">&#91;</span>n<span class="br0">&#93;</span><span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy1">=</span> C<span class="br0">&#91;</span>n<span class="br0">&#93;</span><span class="br0">&#91;</span>n<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> k<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span> k<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>k<span class="br0">&#41;</span>
		C<span class="br0">&#91;</span>n<span class="br0">&#93;</span><span class="br0">&#91;</span>k<span class="br0">&#93;</span> <span class="sy1">=</span> C<span class="br0">&#91;</span>n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#91;</span>k<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy2">+</span> C<span class="br0">&#91;</span>n<span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Если вся таблица значений не нужна, то, как нетрудно заметить, достаточно хранить от неё только две строки (текущую &mdash; <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">-ую строку и предыдущую &mdash; <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">-ую).<p><h3 style="padding-top:15px;"> Вычисление за O(1) </h3><p>Наконец, в некоторых ситуациях оказывается выгодно предпосчитать заранее значения всех факториалов, с тем, чтобы впоследствии считать любой необходимый биномиальный коэффициент, производя лишь два деления. Это может быть выгодно при использовании <a href="big_integer.html">Длинной арифметики</a>, когда память не позволяет предпосчитать весь треугольник Паскаля, или же когда требуется производить расчёты по некоторому простому модулю (если модуль не простой, то возникают сложности при делении числителя дроби на знаменатель; их можно преодолеть, если факторизовать модуль и хранить все числа в виде векторов из степеней этих простых; см <a href="big_integer.html">раздел "Длинная арифметика в факторизованном виде"</a>).<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>