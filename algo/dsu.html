<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Система непересекающихся множеств</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 11 Jun 2008 10:56<br>редактировано: 24 Jan 2013 12:47</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="dsu.html#" id="contents-hide">[скрыть]</a><a href="dsu.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Система непересекающихся множеств </h1><p><p>В данной статье рассматривается структура данных <b>"система непересекающихся множеств"</b> (на английском "disjoint-set-union", или просто "DSU").<p>Эта структура данных предоставляет следующие возможности. Изначально имеется несколько элементов, каждый из которых находится в отдельном (своём собственном) множестве. За одну операцию можно <b>объединить два каких-либо множества</b>, а также можно <b>запросить, в каком множестве</b> сейчас находится указанный элемент. Также, в классическом варианте, вводится ещё одна операция &mdash; создание нового элемента, который помещается в отдельное множество.<p>Таким образом, базовый интерфейс данной структуры данных состоит всего из трёх операций:<p><ul><p><li><img class=tex src="../tex2png/cache/446ce5f212a1654db44566a93dc12560.png" alt="{\rm make\_set}(x)"> &mdash; <b>добавляет</b> новый элемент <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">, помещая его в новое множество, состоящее из одного него.<p><li><img class=tex src="../tex2png/cache/b43e5ec57a0f9456676044ffca51a30b.png" alt="{\rm union\_sets}(x,y)"> &mdash; <b>объединяет</b> два указанных множества (множество, в котором находится элемент <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">, и множество, в котором находится элемент <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">).<p><li><img class=tex src="../tex2png/cache/1c76cff3d1010105a64f15ffbc57c6ad.png" alt="{\rm find\_set}(x)"> &mdash; <b>возвращает, в каком множестве</b> находится указанный элемент <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x">. На самом деле при этом возвращается один из элементов множества (называемый <b>представителем</b> или <b>лидером</b> (в англоязычной литературе "leader")). Этот представитель выбирается в каждом множестве самой структурой данных (и может меняться с течением времени, а именно, после вызовов <img class=tex src="../tex2png/cache/4fe1c9be777a1e222002a923a344c5c3.png" alt="{\rm union\_sets}()">).<p>Например, если вызов <img class=tex src="../tex2png/cache/da60ca2b48ed3d72dbad15929c7c30e4.png" alt="{\rm find\_set}()"> для каких-то двух элементов вернул одно и то же значение, то это означает, что эти элементы находятся в одном и том же множестве, а в противном случае &mdash; в разных множествах.<p></ul><p>Описываемая ниже структура данных позволяет делать каждую из этих операций почти за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> в среднем (более подробно об асимптотике см. ниже после описания алгоритма).<p>Также в одном из подразделов статьи описан альтернативный вариант реализации DSU, позволяющий добиться асимптотики <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)"> в среднем на один запрос при <img class=tex src="../tex2png/cache/02c60534e1ff29f0111a3b6a8875758d.png" alt="m \ge n">; а при <img class=tex src="../tex2png/cache/7c19d9bfa16bd258f23d98ab42a8e3fa.png" alt="m >> n"> (т.е. <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> значительно больше <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">) &mdash; и вовсе времени <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> в среднем на запрос (см. "Хранение DSU в виде явного списка множеств").<p><p><p><p><h2 style="padding-top:40px;"> Построение эффективной структуры данных </h2><p>Определимся сначала, в каком виде мы будем хранить всю информацию.<p>Множества элементов мы будем хранить в виде <b>деревьев</b>: одно дерево соответствует одному множеству. Корень дерева &mdash; это представитель (лидер) множества.<p>При реализации это означает, что мы заводим массив <img class=tex src="../tex2png/cache/ba422da6e60dc0dcb7d51c22c96f594a.png" alt="{\rm parent}">, в котором для каждого элемента мы храним ссылку на его предка в дерева. Для корней деревьев будем считать, что их предок &mdash; они сами (т.е. ссылка зацикливается в этом месте).<p><p><p><h3 style="padding-top:15px;"> Наивная реализация </h3><p>Мы уже можем написать первую реализацию системы непересекающихся множеств. Она будет довольно неэффективной, но затем мы улучшим её с помощью двух приёмов, получив в итоге почти константное время работы.<p>Итак, вся информация о множествах элементов хранится у нас с помощью массива <img class=tex src="../tex2png/cache/ba422da6e60dc0dcb7d51c22c96f594a.png" alt="{\rm parent}">.<p>Чтобы создать новый элемент (операция <img class=tex src="../tex2png/cache/fe613b816046fe4b631c216d9c65bd98.png" alt="{\rm make\_set}(v)">), мы просто создаём дерево с корнем в вершине <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, отмечая, что её предок &mdash; это она сама.<p>Чтобы объединить два множества (операция <img class=tex src="../tex2png/cache/2ae37a69e0849179f9a9b432e44dc2fb.png" alt="{\rm union\_sets}(a,b)">), мы сначала найдём лидеров множества, в котором находится <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, и множества, в котором находится <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">. Если лидеры совпали, то ничего не делаем &mdash; это значит, что множества и так уже были объединены. В противном случае можно просто указать, что предок вершины <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> равен <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> (или наоборот) &mdash; тем самым присоединив одно дерево к другому.<p>Наконец, реализация операции поиска лидера (<img class=tex src="../tex2png/cache/9644a52f7306231c6cbd5f08bd31105a.png" alt="{\rm find\_set}(v)">) проста: мы поднимаемся по предкам от вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, пока не дойдём до корня, т.е. пока ссылка на предка не ведёт в себя. Эту операцию удобнее реализовать рекурсивно (особенно это будет удобно позже, в связи с добавляемыми оптимизациями).<p><pre class="notranslate cpp"><span class="kw4">void</span> make_set <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> find_set <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>v <span class="sy1">==</span> parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> v<span class="sy4">;</span>
	<span class="kw1">return</span> find_set <span class="br0">&#40;</span>parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> union_sets <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	a <span class="sy1">=</span> find_set <span class="br0">&#40;</span>a<span class="br0">&#41;</span><span class="sy4">;</span>
	b <span class="sy1">=</span> find_set <span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="sy3">!</span><span class="sy1">=</span> b<span class="br0">&#41;</span>
		parent<span class="br0">&#91;</span>b<span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Впрочем, такая реализация системы непересекающихся множеств весьма <b>неэффективна</b>. Легко построить пример, когда после нескольких объединений множеств получится ситуация, что множество &mdash; это дерево, выродившееся в длинную цепочку. В результате каждый вызов <img class=tex src="../tex2png/cache/da60ca2b48ed3d72dbad15929c7c30e4.png" alt="{\rm find\_set}()"> будет работать на таком тесте за время порядка глубины дерева, т.е. за <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">.<p>Это весьма далеко от той асимптотики, которую мы собирались получить (константное время работы). Поэтому рассмотрим две оптимизации, которые позволят (даже применённые по отдельности) значительно ускорить работу.<p><p><p><h3 style="padding-top:15px;"> Эвристика сжатия пути </h3><p>Эта эвристика предназначена для ускорения работы <img class=tex src="../tex2png/cache/da60ca2b48ed3d72dbad15929c7c30e4.png" alt="{\rm find\_set}()">.<p>Она заключается в том, что когда после вызова <img class=tex src="../tex2png/cache/9644a52f7306231c6cbd5f08bd31105a.png" alt="{\rm find\_set}(v)"> мы найдём искомого лидера <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> множества, то запомним, что у вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> и всех пройденных по пути вершин &mdash; именно этот лидер <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">. Проще всего это сделать, перенаправив их <img class=tex src="../tex2png/cache/21f4cb56d8989f2b1c2ec5bce1983210.png" alt="{\rm parent}[]"> на эту вершину <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">.<p>Таким образом, у массива предков <img class=tex src="../tex2png/cache/21f4cb56d8989f2b1c2ec5bce1983210.png" alt="{\rm parent}[]"> смысл несколько меняется: теперь это <b>сжатый массив предков</b>, т.е. для каждой вершины там может храниться не непосредственный предок, а предок предка, предок предка предка, и т.д.<p>С другой стороны, понятно, что нельзя сделать, чтобы эти указатели <img class=tex src="../tex2png/cache/ba422da6e60dc0dcb7d51c22c96f594a.png" alt="{\rm parent}"> всегда указывали на лидера: иначе при выполнении операции <img class=tex src="../tex2png/cache/4fe1c9be777a1e222002a923a344c5c3.png" alt="{\rm union\_sets}()"> пришлось бы обновлять лидеров у <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> элементов.<p>Таким образом, к массиву <img class=tex src="../tex2png/cache/21f4cb56d8989f2b1c2ec5bce1983210.png" alt="{\rm parent}[]"> следует подходить именно как к массиву предков, возможно, частично сжатому.<p>Новая реализация операции <img class=tex src="../tex2png/cache/da60ca2b48ed3d72dbad15929c7c30e4.png" alt="{\rm find\_set}()"> выглядит следующим образом:<p><pre class="notranslate cpp"><span class="kw4">int</span> find_set <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>v <span class="sy1">==</span> parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> v<span class="sy4">;</span>
	<span class="kw1">return</span> parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> find_set <span class="br0">&#40;</span>parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Такая простая реализация делает всё, что задумывалось: сначала путём рекурсивных вызовов находится лидера множества, а затем, в процессе раскрутки стека, этот лидер присваивается ссылкам <img class=tex src="../tex2png/cache/ba422da6e60dc0dcb7d51c22c96f594a.png" alt="{\rm parent}"> для всех пройденных элементов.<p>Реализовать эту операцию можно и нерекурсивно, но тогда придётся осуществлять два прохода по дереву: первый найдёт искомого лидера, второй &mdash; проставит его всем вершинам пути. Впрочем, на практике нерекурсивная реализация не даёт существенного выигрыша.<p><p><h4> Оценка асимптотики при применении эвристики сжатия пути </h4><p>Покажем, что применение одной эвристики сжатия пути <b>позволяет достичь логарифмическую асимптотику</b>: <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)"> на один запрос в среднем.<p>Заметим, что, поскольку операция <img class=tex src="../tex2png/cache/4fe1c9be777a1e222002a923a344c5c3.png" alt="{\rm union\_sets}()"> представляет из себя два вызова операции <img class=tex src="../tex2png/cache/da60ca2b48ed3d72dbad15929c7c30e4.png" alt="{\rm find\_set}()"> и ещё <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> операций, то мы можем сосредоточиться в доказательстве только на оценку времени работы <img class=tex src="../tex2png/cache/baa7e0765a2f4f8991346c62c1279993.png" alt="O(m)"> операций <img class=tex src="../tex2png/cache/da60ca2b48ed3d72dbad15929c7c30e4.png" alt="{\rm find\_set}()">.<p>Назовём <b>весом</b> <img class=tex src="../tex2png/cache/037a5a80c288b70567ab5a71619b41e3.png" alt="w[v]"> вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> число потомков этой вершины (включая её саму). Веса вершин, очевидно, могут только увеличиваться в процессе работы алгоритма.<p>Назовём <b>размахом ребра</b> <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> разность весов концов этого ребра: <img class=tex src="../tex2png/cache/535462d50ca6cb481cab97fed13c7a2b.png" alt="|w[a] - w[b]|"> (очевидно, у вершины-предка вес всегда больше, чем у вершины-потомка). Можно заметить, что размах какого-либо фиксированного ребра <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> может только увеличиваться в процессе работы алгоритма.<p>Кроме того, разобьём рёбра на <b>классы</b>: будем говорить, что ребро имеет класс <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, если его размах принадлежит отрезку <img class=tex src="../tex2png/cache/d81fb201323af43e8664bcdbb5c6ba36.png" alt="[2^k; 2^{k+1}-1]">. Таким образом, класс ребра &mdash; это число от <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0"> до <img class=tex src="../tex2png/cache/03effa12c104c5aeccb4b45e5f5d249a.png" alt="\lceil \log n \rceil">.<p>Зафиксируем теперь произвольную вершину <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> и будем следить, как меняется ребро в её предка: сначала оно отсутствует (пока вершина <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> является лидером), затем проводится ребро из <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> в какую-то вершину (когда множество с вершиной <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> присоединяется к другому множеству), и затем может меняться при сжатии путей в процессе вызовов <img class=tex src="../tex2png/cache/e5c48d33e3985e9dfa5643deeebb2583.png" alt="{\rm find\_path}">. Понятно, что нас интересует асимптотика только последнего случая (при сжатии путей): все остальные случаи требуют <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> времени на один запрос.<p>Рассмотрим работу некоторого вызова операции <img class=tex src="../tex2png/cache/d7e9791ddce6ab8de82bdfb216dbcd0b.png" alt="{\rm find\_set}">: он проходит в дереве вдоль некоторого <b>пути</b>, стирая все рёбра этого пути и перенаправляя их в лидера.<p>Рассмотрим этот путь и <b>исключим</b> из рассмотрения последнее ребро каждого класса (т.е. не более чем по одному ребру из класса <img class=tex src="../tex2png/cache/5e905bc790866a0903bb44b94bfdff29.png" alt="0, 1, \ldots \lceil \log n \rceil">). Тем самым мы исключили <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)"> рёбер из каждого запроса.<p>Рассмотрим теперь все <b>остальные</b> рёбра этого пути. Для каждого такого ребра, если оно имеет класс <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, получается, что в этом пути есть ещё одно ребро класса <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> (иначе мы были бы обязаны исключить текущее ребро, как единственного представителя класса <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">). Таким образом, после сжатия пути это ребро заменится на ребро класса как минимум <img class=tex src="../tex2png/cache/b7e1992873e6c485f926be57173a6d22.png" alt="k+1">. Учитывая, что уменьшаться вес ребра не может, мы получаем, что для каждой вершины, затронутой запросом <img class=tex src="../tex2png/cache/88edf909b7d2508f742afa0108b43d8d.png" alt="\rm find\_path">, ребро в её предка либо было исключено, либо строго увеличило свой класс.<p>Отсюда мы окончательно получаем асимптотику работы <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> запросов: <img class=tex src="../tex2png/cache/2708b05f818f01f57827756a57ea34dc.png" alt="O((n+m) \log n)">, что (при <img class=tex src="../tex2png/cache/02c60534e1ff29f0111a3b6a8875758d.png" alt="m \ge n">) означает логарифмическое время работы на один запрос в среднем.<p><p><p><h3 style="padding-top:15px;"> Эвристика объединения по рангу </h3><p>Рассмотрим здесь другую эвристику, которая сама по себе способна ускорить время работы алгоритма, а в сочетании с эвристикой сжатия путей и вовсе способна достигнуть практически константного времени работы на один запрос в среднем.<p>Эта эвристика заключается в небольшом изменении работы <img class=tex src="../tex2png/cache/514f0f6f91b8be753928d0d067b44350.png" alt="{\rm union\_sets}">: если в наивной реализации то, какое дерево будет присоединено к какому, определяется случайно, то теперь мы будем это делать на основе <b>рангов</b>.<p>Есть два варианта ранговой эвристики: в одном варианте рангом дерева называется <b>количество вершин</b> в нём, в другом &mdash; <b>глубина дерева</b> (точнее, верхняя граница на глубину дерева, поскольку при совместном применении эвристики сжатия путей реальная глубина дерева может уменьшаться).<p>В обоих вариантах суть эвристики одна и та же: при выполнении <img class=tex src="../tex2png/cache/4fc7167fbc332f82c01647aa25678754.png" alt="\rm union\_sets"> будем присоединять дерево с меньшим рангом к дереву с большим рангом.<p>Приведём реализацию <b>ранговой эвристики на основе размеров деревьев</b>:<p><pre class="notranslate cpp"><span class="kw4">void</span> make_set <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
	size<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> union_sets <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	a <span class="sy1">=</span> find_set <span class="br0">&#40;</span>a<span class="br0">&#41;</span><span class="sy4">;</span>
	b <span class="sy1">=</span> find_set <span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="sy3">!</span><span class="sy1">=</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>size<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">&lt;</span> size<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="br0">&#41;</span>
			swap <span class="br0">&#40;</span>a, b<span class="br0">&#41;</span><span class="sy4">;</span>
		parent<span class="br0">&#91;</span>b<span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="sy4">;</span>
		size<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> size<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Приведём реализацию <b>ранговой эвристики на основе глубины деревьев</b>:<p><pre class="notranslate cpp"><span class="kw4">void</span> make_set <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
	rank<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> union_sets <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	a <span class="sy1">=</span> find_set <span class="br0">&#40;</span>a<span class="br0">&#41;</span><span class="sy4">;</span>
	b <span class="sy1">=</span> find_set <span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="sy3">!</span><span class="sy1">=</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>rank<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">&lt;</span> rank<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="br0">&#41;</span>
			swap <span class="br0">&#40;</span>a, b<span class="br0">&#41;</span><span class="sy4">;</span>
		parent<span class="br0">&#91;</span>b<span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>rank<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">==</span> rank<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="br0">&#41;</span>
			<span class="sy2">++</span>rank<span class="br0">&#91;</span>a<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Оба варианта ранговой эвристики являются эквивалентными с точки зрения асимптотики, поэтому на практике можно применять любую из них.<p><p><h4> Оценка асимптотики при применении ранговой эвристики </h4><p>Покажем, что асимптотика работы системы непересекающихся множеств при использовании только ранговой эвристики, без эвристики сжатия путей, будет <b>логарифмической</b> на один запрос в среднем: <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">.<p>Здесь мы покажем, что при любом из двух вариантов ранговой эвристики глубина каждого дерева будет величиной <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">, что автоматически будет означать логарифмическую асимптотику для запроса <img class=tex src="../tex2png/cache/27535b0bc8ee57c82b7fcba6bdd94279.png" alt="\rm find\_set">, и, следовательно, запроса <img class=tex src="../tex2png/cache/4fc7167fbc332f82c01647aa25678754.png" alt="\rm union\_sets">.<p>Рассмотрим <b>ранговую эвристику по глубине дерева</b>. Покажем, что если ранг дерева равен <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, то это дерево содержит как минимум <img class=tex src="../tex2png/cache/a631b6ee74bdfc6711813da7ca95a648.png" alt="2^k"> вершин (отсюда будет автоматически следовать, что ранг, а, значит, и глубина дерева, есть величина <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)">). Доказывать будем по индукции: для <img class=tex src="../tex2png/cache/0fd8a863224a724a8f912068af8771a3.png" alt="k=0"> это очевидно. При сжатии путей глубина может только уменьшиться. Ранг дерева увеличивается с <img class=tex src="../tex2png/cache/658627816b5be3d0859b8d0d52d03fd5.png" alt="k-1"> до <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, когда к нему присоединяется дерево ранга <img class=tex src="../tex2png/cache/658627816b5be3d0859b8d0d52d03fd5.png" alt="k-1">; применяя к этим двум деревьям размера <img class=tex src="../tex2png/cache/658627816b5be3d0859b8d0d52d03fd5.png" alt="k-1"> предположение индукции, получаем, что новое дерево ранга <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> действительно будет иметь как минимум <img class=tex src="../tex2png/cache/a631b6ee74bdfc6711813da7ca95a648.png" alt="2^k"> вершин, что и требовалось доказать.<p>Рассмотрим теперь <b>ранговую эвристику по размерам деревьев</b>. Покажем, что если размер дерева равен <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">, то его высота не более <img class=tex src="../tex2png/cache/4369b8e69524039a300fb08edd2f2762.png" alt="\lfloor \log k \rfloor">. Доказывать будем по индукции: для <img class=tex src="../tex2png/cache/c52bf046f58b7dd5434e50c9358055d3.png" alt="k=1"> утверждение верно. При сжатии путей глубина может только уменьшиться, поэтому сжатие путей ничего не нарушает. Пусть теперь объединяются два дерева размеров <img class=tex src="../tex2png/cache/2b3831d7d2edca0658a067b684887d60.png" alt="k_1"> и <img class=tex src="../tex2png/cache/daa41655761beb69365ffeafd21fc329.png" alt="k_2">; тогда по предположению индукции их высоты меньше либо равны, соответственно, <img class=tex src="../tex2png/cache/700f0e6a288efb10f44c17037d40dac3.png" alt="\lfloor \log k_1 \rfloor"> и <img class=tex src="../tex2png/cache/9b146f303eec3e80f503e802fa963956.png" alt="\lfloor \log k_2 \rfloor">. Не теряя общности, считаем, что первое дерево &mdash; большее (<img class=tex src="../tex2png/cache/5fb69dc51785e632cda0f0b8efb23ae1.png" alt="k_1 \ge k_2">), поэтому после объединения глубина получившегося дерева из <img class=tex src="../tex2png/cache/1daaedfd2aac52d22434105f36defd94.png" alt="k_1+k_2"> вершин станет равна:<p><p class=formula><img class=tex src="../tex2png/cache/313f05c20a10998025aecd44f88de465.png" alt=" h = \max ( \lfloor \log k_1 \rfloor, 1 + \lfloor [...]"></p><p>Чтобы завершить доказательство, надо показать, что:<p><p class=formula><img class=tex src="../tex2png/cache/c1947a313ad0a57f821bcbbda7c376fe.png" alt=" h ~ \stackrel{?}{\le} ~ \lfloor \log (k_1+k_2) \r[...]"><br><img class=tex src="../tex2png/cache/0fc0ea2e7d0c6a74aaa63dee25719e2d.png" alt=" 2^h = \max ( 2 ^ {\lfloor \log k_1 \rfloor}, 2 ^ [...]"></p><p>что есть почти очевидное неравенство, поскольку <img class=tex src="../tex2png/cache/9f187a3aa160f2ca8d88ec8999c8e105.png" alt="k_1 \le k_1+k_2"> и <img class=tex src="../tex2png/cache/3276a3f0a0647106b03ea8805a08c648.png" alt="2 k_2 \le k_1+k_2">.<p><p><p><h3 style="padding-top:15px;"> Объединение эвристик: сжатие пути плюс ранговая эвристика </h3><p>Как уже упоминалось выше, совместное применение этих эвристик даёт особенно наилучший результат, в итоге достигая практически константного времени работы.<p>Мы не будем приводить здесь доказательства асимптотики, поскольку оно весьма объёмно (см., например, Кормен, Лейзерсон, Ривест, Штайн "Алгоритмы. Построение и анализ"). Впервые это доказательство было проведено Тарьяном (1975 г.).<p>Окончательный результат таков: при совместном применении эвристик сжатия пути и объединения по рангу время работы на один запрос получается <img class=tex src="../tex2png/cache/967bddc42a8a96400b937c827c411040.png" alt="O (\alpha(n))"> в среднем, где <img class=tex src="../tex2png/cache/f317baca6e7e1fcb3f862ca6a546f515.png" alt="\alpha(n)"> &mdash; <b>обратная функция Аккермана</b>, которая растёт очень медленно, настолько медленно, что для всех разумных ограничений <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> она <b>не превосходит 4</b> (примерно для <img class=tex src="../tex2png/cache/92b302d0a5c07a982d0d87fca9686583.png" alt="n \le 10^{600}">).<p>Именно поэтому про асимптотику работы системы непересекающихся множеств уместно говорить "почти константное время работы".<p>Приведём здесь <b>итоговую реализацию системы непересекающихся множеств</b>, реализующую обе указанные эвристики (используется ранговая эвристика относительно глубин деревьев):<p><pre class="notranslate cpp"><span class="kw4">void</span> make_set <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
	rank<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> find_set <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>v <span class="sy1">==</span> parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span>
		<span class="kw1">return</span> v<span class="sy4">;</span>
	<span class="kw1">return</span> parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> find_set <span class="br0">&#40;</span>parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> union_sets <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	a <span class="sy1">=</span> find_set <span class="br0">&#40;</span>a<span class="br0">&#41;</span><span class="sy4">;</span>
	b <span class="sy1">=</span> find_set <span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="sy3">!</span><span class="sy1">=</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>rank<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">&lt;</span> rank<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="br0">&#41;</span>
			swap <span class="br0">&#40;</span>a, b<span class="br0">&#41;</span><span class="sy4">;</span>
		parent<span class="br0">&#91;</span>b<span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>rank<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">==</span> rank<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="br0">&#41;</span>
			<span class="sy2">++</span>rank<span class="br0">&#91;</span>a<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p><p><p><p><h2 style="padding-top:40px;"> Применения в задачах и различных улучшения </h2><p>В этом разделе мы рассмотрим несколько применений структуры данных "система непересекающихся множеств", как тривиальных, так и использующих некоторые улучшения структуры данных.<p><p><p><h3 style="padding-top:15px;"> Поддержка компонент связности графа </h3><p>Это одно из очевидных приложений структуры данных "система непересекающихся множеств", которое, по всей видимости, и стимулировало изучение этой структуры.<p><b>Формально</b> задачу можно сформулировать таким образом: изначально дан пустой граф, постепенно в этот граф могут добавляться вершины и неориентированные рёбра, а также поступают запросы <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> &mdash; "в одинаковых ли компонентах связности лежат вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">?".<p>Непосредственно применяя здесь описанную выше структуру данных, мы получаем решение, которое обрабатывает один запрос на добавление вершины/ребра или запрос на проверку двух вершин &mdash; за почти константное время в среднем.<p>Учитывая, что практически в точности такая же задача ставится при использовании <a href="mst_kruskal.html"><b>алгоритма Крускала нахождения минимального остовного дерева</b></a>, мы сразу же получаем <a href="mst_kruskal_with_dsu.html">улучшенную версию этого алгоритма</a>, работающую практически за линейное время.<p>Иногда на практике встречается <b>инвертированная версия этой задачи</b>: изначально есть граф с какими-то вершинами и рёбрами, и поступают запросы на удаление рёбер. Если задача дана в оффлайн, т.е. мы заранее можем узнать все запросы, то решать эту задачу можно следующим образом: перевернём задачу задом наперёд: будем считать, что у нас есть пустой граф, в который могут добавляться рёбра (сначала добавим ребро последнего запроса, затем предпоследнего, и т.д.). Тем самым в результате инвертирования этой задачи мы пришли к обычной задаче, решение которой описывалось выше.<p><p><p><h3 style="padding-top:15px;"> Поиск компонент связности на изображении </h3><p>Одно из лежащих на поверхности применений DSU заключается в решении следующей задачи: имеется изображение <img class=tex src="../tex2png/cache/ed0e13f7024ff254a4fccd689fe21ad3.png" alt="n \times m"> пикселей. Изначально всё изображение белое, но затем на нём рисуется несколько чёрных пикселей. Требуется определить размер каждой "белой" компоненты связности на итоговом изображении.<p>Для решения мы просто перебираем все белые клетки изображения, для каждой клетки перебираем её четырёх соседей, и если сосед тоже белый &mdash; то вызываем <img class=tex src="../tex2png/cache/4fe1c9be777a1e222002a923a344c5c3.png" alt="{\rm union\_sets}()"> от этих двух вершин. Таким образом, у нас будет DSU с <img class=tex src="../tex2png/cache/da6a3c203fe9675ff64fb3a0442c3714.png" alt="nm"> вершинами, соответствующими пикселям изображения. Получившиеся в итоге деревья DSU &mdash; и есть искомые компоненты связности.<p>Данную задачу можно решить проще с использованием <a href="dfs.html">обхода в глубину</a> (или <a href="bfs.html">обхода в ширину</a>), однако у описанного здесь метода есть определённое преимущество: оно может обрабатывать матрицу построчно (оперируя только с текущей строкой, предыдущей строкой и системой непересекающихся множеств, построенной для элементов одной строки), т.е. используя порядка <img class=tex src="../tex2png/cache/d6ba32ed69b10d8ea8684f038e8e70a4.png" alt="O(\min (n, m))"> памяти.<p><p><p><h3 style="padding-top:15px;"> Поддержка дополнительной информации для каждого множества </h3><p>"Система непересекающихся множеств" позволяет легко хранить любую дополнительную информацию, относящуюся ко множествам.<p>Простой пример &mdash; это <b>размеры множеств</b>: как их хранить, было описано при описании ранговой эвристики (информация там записывалась для текущего лидера множества).<p>Таким образом, вместе с лидером каждого множества можно хранить любую дополнительную требуемую в конкретной задаче информацию.<p><p><p><h3 style="padding-top:15px;"> Применение DSU для сжатия "прыжков" по отрезку. Задача о покраске подотрезков в оффлайне </h3><p>Одно из распространённых применений DSU заключается в том, что если есть набор элементов, и из каждого элемента выходит по одному ребру, то мы можем быстро (за почти константное время) находить конечную точку, в которую мы попадём, если будем двигаться вдоль рёбер из заданной начальной точки.<p>Наглядным примером этого применения является <b>задача о покраске подотрезков</b>: есть отрезок длины <img class=tex src="../tex2png/cache/88e54f90480ef3aeba329562335471f9.png" alt="L">, каждая клетка которого (т.е. каждый кусочек длины <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1">) имеет нулевой цвет. Поступают запросы вида <img class=tex src="../tex2png/cache/27771045d9bcd3cc9507dacbda74eeb8.png" alt="(l,r,c)"> &mdash; перекрасить отрезок <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> в цвет <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">. Требуется найти итоговый цвет каждой клетки. Запросы считаются известными заранее, т.е. задача &mdash; в оффлайне.<p>Для решения мы можем завести DSU-структуру, которая для каждой клетки будет хранить ссылку на ближайшую справа непокрашенную клетку. Таким образом, изначально каждая клетка указывает на саму себя, а после покраски первого подотрезка &mdash; клетка перед началом подотрезка будет указывать на клетку после конца подотрезка.<p>Теперь, чтобы решить задачу, мы рассматриваем запросы перекраски <b>в обратном порядке</b>: от последнего к первому. Для выполнения запроса мы просто каждый раз с помощью нашего DSU находим самую левую непокрашенную клетку внутри отрезка, перекрашиваем её, и перебрасываем указатель из неё на следующую справа пустую клетку.<p>Таким образом, мы здесь фактически используем DSU с эвристикой сжатия путей, но без ранговой эвристики (т.к. нам важно, кто станет лидером после объединения). Следовательно, итоговая асимптотика составит <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)"> на запрос (впрочем, с маленькой по сравнению с другими структурами данных константой).<p>Реализация:<p><pre class="notranslate cpp"><span class="kw4">void</span> init<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>L<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		make_set <span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> process_query <span class="br0">&#40;</span><span class="kw4">int</span> l, <span class="kw4">int</span> r, <span class="kw4">int</span> c<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="sy1">=</span>l<span class="sy4">;</span> <span class="sy4">;</span> <span class="br0">&#41;</span> <span class="br0">&#123;</span>
		v <span class="sy1">=</span> find_set <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>v <span class="sy1">&gt;=</span> r<span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
		answer<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> c<span class="sy4">;</span>
		parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy2">+</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Впрочем, можно реализовать это решение <b>с ранговой эвристикой</b>: будем хранить для каждого множества в некотором массиве <img class=tex src="../tex2png/cache/a2ca258a437f8aa5be9aac85333e252d.png" alt="{\rm end}[]">, где это множество заканчивается (т.е. самую правую точку). Тогда можно будет объединять два множества в одно по их ранговой эвристике, проставляя потом получившемуся множеству новую правую границу. Тем самым мы получим решение за <img class=tex src="../tex2png/cache/f21599ffb1f047cc1ade4701a260ce91.png" alt="O(\alpha(n))">.<p><p><p><h3 style="padding-top:15px;"> Поддержка расстояний до лидера </h3><p>Иногда в конкретных приложениях системы непересекающихся множеств всплывает требование поддерживать расстояние до лидера (т.е. длину пути в рёбрах в дереве от текущей вершины до корня дерева).<p>Если бы не было эвристики сжатия путей, то никаких сложностей бы не возникало &mdash; расстояние до корня просто равнялось бы числу рекурсивных вызовов, которые сделала функция <img class=tex src="../tex2png/cache/27535b0bc8ee57c82b7fcba6bdd94279.png" alt="\rm find\_set">.<p>Однако в результате сжатия путей несколько рёбер пути могли сжаться в одно ребро. Таким образом, вместе с каждой вершиной придётся хранить дополнительную информацию: <b>длину текущего ребра из вершины в предка</b>.<p>При реализации удобно представлять, что массив <img class=tex src="../tex2png/cache/21f4cb56d8989f2b1c2ec5bce1983210.png" alt="{\rm parent}[]"> и функция <img class=tex src="../tex2png/cache/27535b0bc8ee57c82b7fcba6bdd94279.png" alt="\rm find\_set"> теперь возвращают не одно число, а пару чисел: вершину-лидера и расстояние до неё:<p><pre class="notranslate cpp"><span class="kw4">void</span> make_set <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> make_pair <span class="br0">&#40;</span>v, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
	rank<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> find_set <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>v <span class="sy3">!</span><span class="sy1">=</span> parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">first</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> len <span class="sy1">=</span> parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">second</span><span class="sy4">;</span>
		parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> find_set <span class="br0">&#40;</span>parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">first</span><span class="br0">&#41;</span><span class="sy4">;</span>
		parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">second</span> <span class="sy2">+</span><span class="sy1">=</span> len<span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> union_sets <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	a <span class="sy1">=</span> find_set <span class="br0">&#40;</span>a<span class="br0">&#41;</span> .<span class="me1">first</span><span class="sy4">;</span>
	b <span class="sy1">=</span> find_set <span class="br0">&#40;</span>b<span class="br0">&#41;</span> .<span class="me1">first</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="sy3">!</span><span class="sy1">=</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>rank<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">&lt;</span> rank<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="br0">&#41;</span>
			swap <span class="br0">&#40;</span>a, b<span class="br0">&#41;</span><span class="sy4">;</span>
		parent<span class="br0">&#91;</span>b<span class="br0">&#93;</span> <span class="sy1">=</span> make_pair <span class="br0">&#40;</span>a, <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>rank<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">==</span> rank<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="br0">&#41;</span>
			<span class="sy2">++</span>rank<span class="br0">&#91;</span>a<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p><p><p><h3 style="padding-top:15px;"> Поддержка чётности длины пути и задача о проверке двудольности графа в онлайн </h3><p>По аналогии с длиной пути до лидера, так же можно поддерживать чётность длины пути до него. Почему же это применение было выделено в отдельный пункт?<p>Дело в том, что обычно требование хранение чётности пути всплывает в связи со следующей <b>задачей</b>: изначально дан пустой граф, в него могут добавляться рёбра, а также поступать запросы вида "является ли компонента связности, содержащая данную вершину, <b>двудольной</b>?".<p>Для решения этой задачи мы можем завести систему непересекающихся множеств для хранения компонент связности, и хранить у каждой вершины чётность длины пути до её лидера. Тем самым, мы можем быстро проверять, приведёт ли добавление указанного ребра к нарушению двудольности графа или нет: а именно, если концы ребра лежат в одной и той же компоненте связности, и при этом имеют одинаковые чётности длины пути до лидера, то добавление этого ребра приведёт к образованию цикла нечётной длины и превращению текущей компоненты в недвудольную.<p>Главная <b>сложность</b>, с которой мы сталкиваемся при этом, &mdash; это то, что мы должны аккуратно, с учётом чётностей, производить объединение двух деревьев в функции <img class=tex src="../tex2png/cache/4fc7167fbc332f82c01647aa25678754.png" alt="\rm union\_sets">.<p>Если мы добавляем ребро <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)">, связывающее две компоненты связности в одну, то при присоединении одного дерева к другому мы должны указать ему такую чётность, чтобы в результате у вершин <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> получались бы разные чётности длины пути.<p>Выведём <b>формулу</b>, по которой должна получаться эта чётность, выставляемая лидеру одного множества при присоединении его к лидеру другого множества. Обозначим через <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> чётность длины пути от вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> до лидера её множества, через <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y"> &mdash; чётность длины пути от вершины <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> до лидера её множества, а через <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> &mdash; искомую чётность, которую мы должны поставить присоединяемому лидеру. Если множество с вершиной <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> присоединяется к множеству с вершиной <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">, становясь поддеревом, то после присоединения у вершины <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> её чётность не изменится и останется равной <img class=tex src="../tex2png/cache/e1fbf2db960f0155bd590871a486e78c.png" alt="y">, а у вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> чётность станет равной <img class=tex src="../tex2png/cache/05085bf89443a91cd9b4fc36c5e7b0f2.png" alt="x \oplus t"> (символом <img class=tex src="../tex2png/cache/e5f199ca03ee10d0e24361cf7a5b2a6b.png" alt="\oplus"> здесь обозначена операция XOR (симметрическая разность)). Нам требуется, чтобы эти две чётности различались, т.е. их XOR был равен единице. Т.е. получаем уравнение на <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">:<p><p class=formula><img class=tex src="../tex2png/cache/f68cb7c3e06d8ddb5bc837452bdb24da.png" alt=" x \oplus t \oplus y = 1, "></p><p>решая которое, находим:<p><p class=formula><img class=tex src="../tex2png/cache/5fc703be5ad6326468fcf5d1e65471f2.png" alt=" t = x \oplus y \oplus 1. "></p><p>Таким образом, независимо от того, какое множество присоединяется к какому, надо использовать указанную формулу для задания чётности ребра, проводимого из одного лидера к другому.<p>Приведём <b>реализацию</b> DSU с поддержкой чётностей. Как и в предыдущем пункте, в целях удобства мы используем пары для хранения предков и результата операции <img class=tex src="../tex2png/cache/27535b0bc8ee57c82b7fcba6bdd94279.png" alt="\rm find\_set">. Кроме того, для каждого множества мы храним в массиве <img class=tex src="../tex2png/cache/e457bc116fa51d9f5c6a8a4281fc6543.png" alt="{\rm bipartite}[]">, является ли оно всё ещё двудольным или нет.<p><pre class="notranslate cpp"><span class="kw4">void</span> make_set <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> make_pair <span class="br0">&#40;</span>v, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
	rank<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	bipartite<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> find_set <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>v <span class="sy3">!</span><span class="sy1">=</span> parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">first</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> parity <span class="sy1">=</span> parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">second</span><span class="sy4">;</span>
		parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> find_set <span class="br0">&#40;</span>parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">first</span><span class="br0">&#41;</span><span class="sy4">;</span>
		parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">second</span> <span class="sy3">^</span><span class="sy1">=</span> parity<span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> add_edge <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> pa <span class="sy1">=</span> find_set <span class="br0">&#40;</span>a<span class="br0">&#41;</span><span class="sy4">;</span>
	a <span class="sy1">=</span> pa.<span class="me1">first</span><span class="sy4">;</span>
	<span class="kw4">int</span> x <span class="sy1">=</span> pa.<span class="me1">second</span><span class="sy4">;</span>
&nbsp;
	pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> pb <span class="sy1">=</span> find_set <span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="sy4">;</span>
	b <span class="sy1">=</span> pb.<span class="me1">first</span><span class="sy4">;</span>
	<span class="kw4">int</span> y <span class="sy1">=</span> pb.<span class="me1">second</span><span class="sy4">;</span>
&nbsp;
	<span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="sy1">==</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>x <span class="sy1">==</span> y<span class="br0">&#41;</span>
			bipartite<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">else</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>rank<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">&lt;</span> rank<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="br0">&#41;</span>
			swap <span class="br0">&#40;</span>a, b<span class="br0">&#41;</span><span class="sy4">;</span>
		parent<span class="br0">&#91;</span>b<span class="br0">&#93;</span> <span class="sy1">=</span> make_pair <span class="br0">&#40;</span>a, x <span class="sy3">^</span> y <span class="sy3">^</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
		bipartite<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy3">&amp;</span><span class="sy1">=</span> bipartite<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>rank<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">==</span> rank<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="br0">&#41;</span>
			<span class="sy2">++</span>rank<span class="br0">&#91;</span>a<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">bool</span> is_bipartite <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">return</span> bipartite<span class="br0">&#91;</span> find_set<span class="br0">&#40;</span>v<span class="br0">&#41;</span> .<span class="me1">first</span> <span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p><p><h3 style="padding-top:15px;"> Алгоритм нахождения RMQ (минимум на отрезке) за <img class=tex src="../tex2png/cache/ba165c749e00da0fada912a368303f64.png" alt="O(\alpha(n))"> в среднем в оффлайне </h3><p><b>Формально</b> задача ставится следующим образом: нужно реализовать структуру данных, которая поддерживает два вида запросов: добавление указанного числа <img class=tex src="../tex2png/cache/a20386243a5a320d9b0192264554110c.png" alt="{\rm insert}(i)"> (<img class=tex src="../tex2png/cache/1cf0d52047c38a1a3bbeab42c2de96a3.png" alt="i = 1 \ldots n">) и поиск и извлечение текущего минимального числа <img class=tex src="../tex2png/cache/15d8c7f4455c8a50b5fe59ea10227208.png" alt="{\rm extract\_min}()">. Будем считать, что каждое число добавляется ровно один раз.<p>Кроме того, считаем, что вся последовательность запросов известна нам заранее, т.е. задача &mdash; в оффлайне.<p><b>Идея решения</b> следующая. Вместо того, чтобы по очереди отвечать на каждый запрос, переберём число <img class=tex src="../tex2png/cache/1cf0d52047c38a1a3bbeab42c2de96a3.png" alt="i = 1 \ldots n">, и определим, ответом на какой запрос это число должно быть. Для этого нам надо найти первый неотвеченный запрос, идущий после  добавления <img class=tex src="../tex2png/cache/a20386243a5a320d9b0192264554110c.png" alt="{\rm insert}(i)"> этого числа &mdash; легко понять, что это и есть тот запрос, ответом на который является число <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">.<p>Таким образом, здесь получается идея, похожая на <b>задачу о покраске отрезков</b>.<p>Можно получить решение за <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)"> в среднем на запрос, если мы откажемся от ранговой эвристики и будем просто хранить в каждом элементе ссылку на ближайший справа запрос <img class=tex src="../tex2png/cache/15d8c7f4455c8a50b5fe59ea10227208.png" alt="{\rm extract\_min}()">, и использовать сжатие пути для поддержания этих ссылок после объединений.<p>Также можно получить решение и за <img class=tex src="../tex2png/cache/f21599ffb1f047cc1ade4701a260ce91.png" alt="O(\alpha(n))">, если мы будем использовать ранговую эвристику и будем хранить в каждом множестве номер позиции, где оно заканчивается (то, что в предыдущем варианте решения достигалось автоматически за счёт того, что ссылки всегда шли только вправо, &mdash; теперь надо будет хранить явно).<p><p><p><h3 style="padding-top:15px;"> Алгоритм нахождения LCA (наименьшего общего предка в дереве) за <img class=tex src="../tex2png/cache/ba165c749e00da0fada912a368303f64.png" alt="O(\alpha(n))"> в среднем в оффлайне </h3><p>Алгоритм Тарьяна нахождения LCA за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> в среднем в режиме онлайн описан в <a href="lca_linear_offline.html">соответствующей статье</a>. Этот алгоритм выгодно отличается от других алгоритмов поиска LCA своей простотой (особенно по сравнению с <a href="lca_linear.html">оптимальным алгоритмом Фарах-Колтона-Бендера</a>).<p><p><p><h3 style="padding-top:15px;"> Хранение DSU в виде явного списка множеств. Применение этой идеи при слиянии различных структур данных </h3><p>Одним из альтернативных способов хранения DSU является сохранение каждого множества в виде <b>явно хранящегося списка его элементов</b>. При этом, у каждого элемента также сохраняется ссылка на представителя (лидера) его множества.<p>На первый взгляд кажется, что это неэффективная структура данных: при объединении двух множеств мы должны будем добавить один список в конец другого, а также обновить лидера у всех элементов одного из двух списков.<p>Однако, как оказывается, применение <b>весовой эвристики</b>, аналогичной описанной выше, позволяет существенно снизить асимптотику работы: до <img class=tex src="../tex2png/cache/22ea2b3171db52cd31096159dede5ad5.png" alt="O(m + n \log n)"> для выполнения <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> запросов над <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> элементами.<p>Под весовой эвристикой подразумевается, что мы всегда <b>будем добавлять меньшее из двух множеств в большее</b>. Добавление <img class=tex src="../tex2png/cache/4fe1c9be777a1e222002a923a344c5c3.png" alt="{\rm union\_sets}()"> одного множества в другое легко реализовать за время порядка размера добавляемого множества, а поиск лидера <img class=tex src="../tex2png/cache/da60ca2b48ed3d72dbad15929c7c30e4.png" alt="{\rm find\_set}()"> &mdash; за время <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> при таком способе хранения.<p>Докажем <b>асимптотику</b> <img class=tex src="../tex2png/cache/22ea2b3171db52cd31096159dede5ad5.png" alt="O(m + n \log n)"> для выполнения <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> запросов. Зафиксируем произвольный элемент <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> и проследим, как на него воздействовали операции объединения <img class=tex src="../tex2png/cache/514f0f6f91b8be753928d0d067b44350.png" alt="{\rm union\_sets}">. Когда на элемент <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> воздействовали первый раз, мы можем утверждать, что размер его нового множества будет как минимум <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2">. Когда на <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> воздействовали второй раз &mdash; можно утверждать, что он попадёт в множество размера не менее <img class=tex src="../tex2png/cache/540ccd7efd169a4313503b565bb0ce55.png" alt="4"> (т.к. мы добавляем меньшее множество в большее). И так далее &mdash; получаем, что на элемент <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> могло воздействовать максимум <img class=tex src="../tex2png/cache/03effa12c104c5aeccb4b45e5f5d249a.png" alt="\lceil \log n \rceil"> операций объединения. Таким образом, в сумме по всем вершинам это составляет <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)">, плюс по <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> на каждый запрос &mdash; что и требовалось доказать.<p>Приведём пример <b>реализации</b>:<p><pre class="notranslate cpp">vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> lst<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">int</span> parent<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> make_set <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	lst<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="br0">&#40;</span><span class="nu0">1</span>, v<span class="br0">&#41;</span><span class="sy4">;</span>
	parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> find_set <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">return</span> parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> union_sets <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	a <span class="sy1">=</span> find_set <span class="br0">&#40;</span>a<span class="br0">&#41;</span><span class="sy4">;</span>
	b <span class="sy1">=</span> find_set <span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="sy3">!</span><span class="sy1">=</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>lst<span class="br0">&#91;</span>a<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">&lt;</span> lst<span class="br0">&#91;</span>b<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
			swap <span class="br0">&#40;</span>a, b<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy3">!</span>lst<span class="br0">&#91;</span>b<span class="br0">&#93;</span>.<span class="me1">empty</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> v <span class="sy1">=</span> lst<span class="br0">&#91;</span>b<span class="br0">&#93;</span>.<span class="me1">back</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
			lst<span class="br0">&#91;</span>b<span class="br0">&#93;</span>.<span class="me1">pop_back</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
			parent<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> a<span class="sy4">;</span>
			lst<span class="br0">&#91;</span>a<span class="br0">&#93;</span>.<span class="me1">push_back</span> <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Также эту идею добавления элементов меньшего множества в большее можно использовать и вне рамок DSU, при решении других задач.<p>Например, рассмотрим следующую <b>задачу</b>: дано дерево, каждому листу которого приписано какое-либо число (одно и то же число может встречаться несколько раз у разных листьев). Требуется для каждой вершины дерева узнать количество различных чисел в её поддереве.<p>Применив в этой задаче эту же идею, можно получить такое решение: пустим <a href="dfs.html">обход в глубину</a> по дереву, который будет возвращать указатель на <img class=tex src="../tex2png/cache/7ede2edf0170b04cbd85bb62e29617a8.png" alt="{\rm set}"> чисел &mdash; список всех чисел в поддереве этой вершины. Тогда, чтобы получить ответ для текущей вершины (если, конечно, она не лист) &mdash; надо вызвать обход в глубину от всех детей этой вершины, и объединить все полученные <img class=tex src="../tex2png/cache/7ede2edf0170b04cbd85bb62e29617a8.png" alt="{\rm set}"> в один, размер которого и будет ответом для текущей вершины. Для эффективного объединения нескольких <img class=tex src="../tex2png/cache/7ede2edf0170b04cbd85bb62e29617a8.png" alt="{\rm set}"> в один как раз применим описанный выше приём: будем объединять два множества, просто добавляя по одному элементы меньшего множества в большее. В итоге мы получим решение за <img class=tex src="../tex2png/cache/3a93f38cead247d383679647b6ce1537.png" alt="O (n \log^2 n)">, поскольку добавление одного элемента в <img class=tex src="../tex2png/cache/7ede2edf0170b04cbd85bb62e29617a8.png" alt="{\rm set}"> производится за <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">.<p><p><p><h3 style="padding-top:15px;"> Хранение DSU с сохранением явной структуры деревьев. Переподвешивание. Алгоритм поиска мостов в графе за <img class=tex src="../tex2png/cache/ba165c749e00da0fada912a368303f64.png" alt="O(\alpha(n))"> в среднем в онлайне </h3><p>Одно из мощных применений структуры данных "системы непересекающихся множеств" заключается в том, что она позволяет хранить одновременно <b>как сжатую, так и несжатую структуру деревьев</b>. Сжатая структура может использоваться для быстрого объединения деревьев и проверки на принадлежность двух вершин одному дереву, а несжатая &mdash; например, для поиска пути между двумя заданными вершинами, или прочих обходов структуры дерева.<p>При реализации это означает, что помимо обычного для DSU массива сжатых предков <img class=tex src="../tex2png/cache/21f4cb56d8989f2b1c2ec5bce1983210.png" alt="{\rm parent}[]"> мы заведём массив обычных, несжатых, предков <img class=tex src="../tex2png/cache/75cee40f8ae8df680b9cbdf86459344a.png" alt="{\rm real\_parent}[]">. Понятно, что поддержание такого массива никак не ухудшает асимптотику: изменения в нём происходят только при объединении двух деревьев, и лишь в одном элементе.<p>С другой стороны, при применении на практике нередко требуется научиться соединять два дерева указанным ребром, не обязательно выходящим из их корней. Это означает, что у нас нет другого выхода, кроме как <b>переподвесить</b> одно из деревьев за указанную вершину, чтобы затем мы смогли присоединить это дерево к другому, сделав корень этого дерева дочерней вершиной ко второму концу добавляемого ребра.<p>На первый взгляд кажется, что операция переподвешивания &mdash; очень затратна и сильно ухудшит асимптотику. Действительно, для переподвешивания дерева за вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> мы должны пройтись от этой вершины до корня дерева, обновляя везде указатели <img class=tex src="../tex2png/cache/21f4cb56d8989f2b1c2ec5bce1983210.png" alt="{\rm parent}[]"> и <img class=tex src="../tex2png/cache/75cee40f8ae8df680b9cbdf86459344a.png" alt="{\rm real\_parent}[]">.<p>Однако на самом деле всё не так плохо: достаточно лишь переподвешивать то из двух деревьев, которое меньше, чтобы получить асимпотику одного объединения, равную <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> в среднем.<p>Более подробно (включая доказательства асимптотики) см. <a href="bridge_searching_online.html">алгоритм поиска мостов в графе за <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)"> в среднем в онлайне</a>.<p><p><p><p><h2 style="padding-top:40px;"> Историческая ретроспектива </h2><p>Структура данных "система непересекающихся множеств" была известна сравнительно давно.<p>Способ хранения этой структуры в виде <b>леса деревьев</b> был, по всей видимости, впервые описан Галлером и Фишером в 1964 г. (Galler, Fisher "An Improved Equivalence Algorithm"), однако полный анализ асимптотики был проведён гораздо позже.<p><b>Эвристики</b> сжатия путей и объединения по рангу, по-видимому, разработали МакИлрой (McIlroy) и Моррис (Morris), и, независимо от них, Триттер (Tritter).<p>Некоторое время была известна лишь оценка <img class=tex src="../tex2png/cache/9ed67c9723a7f3f9054f9d826df5da6c.png" alt="O(\log^* n)"> на одну операцию в среднем, данная Хопкрофтом и Ульманом в 1973 г. (Hopcroft, Ullman "Set-merging algomthms") &mdash; здесь <img class=tex src="../tex2png/cache/3f421757ccd2c26fde6d1fc8dddf1ca9.png" alt="\log^* n"> &mdash; <b>итерированный логарифм</b> (это медленно растущая функция, но всё же не настолько медленно, как обратная функция Аккермана).<p>Впервые оценку <img class=tex src="../tex2png/cache/967bddc42a8a96400b937c827c411040.png" alt="O (\alpha(n))">, где <img class=tex src="../tex2png/cache/f317baca6e7e1fcb3f862ca6a546f515.png" alt="\alpha(n)"> &mdash; <b>обратная функция Аккермана</b> &mdash; получил Тарьян в своей статье 1975 г. (Tarjan "Efficiency of a Good But Not Linear Set Union Algorithm"). Позже в 1985 г. он вместе с Льювеном получил эту временную оценку для нескольких различных ранговых эвристик и способов сжатия пути (Tarjan, Leeuwen "Worst-Case Analysis of Set Union Algorithms").<p>Наконец, Фредман и Сакс в 1989 г. доказали, что в принятой модели вычислений <b>любой</b> алгоритм для системы непересекающихся множеств должен работать как минимум за <img class=tex src="../tex2png/cache/f21599ffb1f047cc1ade4701a260ce91.png" alt="O(\alpha(n))"> в среднем (Fredman, Saks "The cell probe complexity of dynamic data structures").<p>Впрочем, следует также отметить, что есть несколько статей, <b>оспаривающих</b> эту временную оценку и утверждающих, что система непересекающихся множеств с эвристиками сжатия пути и объединения по рангу работает за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> в среднем: Zhang "The Union-Find Problem Is Linear", Wu, Otoo "A Simpler Proof of the Average Case Complexity of Union-Find with Path Compression".<p><p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Список задач, которые можно решить с помощью системы непересекающихся множеств:<p><ul><li><a href="http://acm.timus.ru/problem.aspx?space=1&num=1671">TIMUS #1671 <b>"Паутина Ананси"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><li><a href="http://codeforces.ru/contest/25/problem/D">CODEFORCES 25D <b>"Дороги не только в Берляндии"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><li><a href="http://acm.timus.ru/problem.aspx?space=1&num=1003">TIMUS #1003 <b>"Чётность"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><li><a href="http://www.spoj.pl/problems/CHAIN/">SPOJ #1442 <b>"Chain"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a></ul><p><p><p><p><h2 style="padding-top:40px;"> Литература </h2><p><ul><li><a href="http://www.e-maxx-ru.1gb.ru/bookz/files/cormen.djvu">Томас Кормен, Чарльз Лейзерсон, Рональд Ривест, Клиффорд Штайн. <b>Алгоритмы: Построение и анализ</b> [2005]</a><li><a href="../bookz/files/algorithms_toolbox_mehlhorn.pdf">Kurt Mehlhorn, Peter Sanders. <b>Algorithms and Data Structures: The Basic Toolbox</b> [2008]</a><li><a href="../bookz/files/dsu/Efficiency&#32;of&#32;a&#32;Good&#32;But&#32;Not&#32;Linear&#32;Set&#32;Union&#32;Algorithm.&#32;Tarjan.pdf">Robert Endre Tarjan. <b>Efficiency of a Good But Not Linear Set Union Algorithm</b> [1975]</a><li><a href="../bookz/files/dsu/Worst-Case&#32;Analysis&#32;of&#32;Set&#32;Union&#32;Algorithms.&#32;Tarjan,&#32;Leeuwen.pdf">Robert Endre Tarjan, Jan van Leeuwen. <b>Worst-Case Analysis of Set Union Algorithms</b> [1985]</a></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>