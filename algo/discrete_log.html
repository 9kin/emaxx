<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Дискретное логарифмирование алгоритмом baby-step-giant-step Шэнкса</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 18:08<br>редактировано: 23 Mar 2012 3:50</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="discrete_log.html#" id="contents-hide">[скрыть]</a><a href="discrete_log.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Дискретное логарифмирование </h1><p>Задача дискретного логарифмирования заключается в том, чтобы по данным целым <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">, <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> решить уравнение:<p><p class=formula><img class=tex src="../tex2png/cache/ec29644c2af45bb21098ab656df32dee.png" alt=" a^x = b \pmod m, "></p><p>где <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> &mdash; <b>взаимно просты</b> (примечание: если они не взаимно просты, то описанный ниже алгоритм является некорректным; хотя, предположительно, его можно модифицировать, чтобы он по-прежнему работал).<p>Здесь описан алгоритм, известный как <b>"baby-step-giant-step algorithm"</b>, предложенный <b>Шэнксом (Shanks)</b> в 1971 г., работающий за время за <img class=tex src="../tex2png/cache/f5f57882bcd88aff2a7b5a4473ec791f.png" alt="O (\sqrt{m} \log m)">. Часто этот алгоритм просто называют алгоритмом <b>"meet-in-the-middle"</b> (потому что это одно из классических применений техники "meet-in-the-middle": "разделение задачи пополам").<p><p><h2 style="padding-top:40px;"> Алгоритм </h2><p>Итак, мы имеем уравнение:<p><p class=formula><img class=tex src="../tex2png/cache/ec29644c2af45bb21098ab656df32dee.png" alt=" a^x = b \pmod m, "></p><p>где <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> взаимно просты.<p>Преобразуем уравнение. Положим<p><p class=formula><img class=tex src="../tex2png/cache/9b1e0fc7ff0c645fa2fc2c93b8a52520.png" alt=" x = np - q, "></p><p>где <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> &mdash; это заранее выбранная константа (как её выбирать в зависимости от <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m">, мы поймём чуть позже). Иногда <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> называют "giant step" (поскольку увеличение его на единицу увеличивает <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> сразу на <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">), а в противоположность ему <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> &mdash; "baby step".<p>Очевидно, что любое <img class=tex src="../tex2png/cache/4a9252cee23f1a80a4e03256ef62d733.png" alt="x"> (из промежутка <img class=tex src="../tex2png/cache/b9c52bebb9074ce17c4acc08da79e109.png" alt="[0;m)"> &mdash; понятно, что такого диапазона значений будет достаточно) можно представить в такой форме, причём для этого будет достаточно значений:<p><p class=formula><img class=tex src="../tex2png/cache/59f2eee2550cd21bd170d718b4c635d4.png" alt=" p \in \left[ 1; \left\lceil \frac{m}{n} \right\rc[...]"></p><p>Тогда уравнение принимает вид:<p><p class=formula><img class=tex src="../tex2png/cache/afadfd8887b71b19b3eb107abe2cb243.png" alt=" a^{np-q} = b \pmod m, "></p><p>откуда, пользуясь тем, что <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> взаимно просты, получаем:<p><p class=formula><img class=tex src="../tex2png/cache/367f93119a37224f1147f830235f7aa4.png" alt=" a^{np} = b a^q \pmod m. "></p><p>Чтобы решить исходное уравнение, нужно найти соответствующие значения <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> и <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q">, чтобы значения левой и правой частей совпали. Иначе говоря, надо решить уравнение:<p><p class=formula><img class=tex src="../tex2png/cache/7333815c4d91ee00e04f8fcf55b23530.png" alt=" f_1(p) = f_2(q). "></p><p>Эта задача решается с помощью метода meet-in-the-middle следующим образом.  Первая фаза алгоритма: посчитаем значения функции <img class=tex src="../tex2png/cache/1f61c75bc3066dabd9982f029dd1da3b.png" alt="f_1"> для всех значений аргумента <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">, и отсортируем эти значения. Вторая фаза алгоритма: будем перебирать значение второй переменной <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q">, вычислять вторую функцию <img class=tex src="../tex2png/cache/703ea045144a19504640b199daf295fe.png" alt="f_2">, и искать это значение среди предвычисленных значений первой функции с помощью бинарного поиска.<p><p><h2 style="padding-top:40px;"> Асимптотика </h2><p>Сначала оценим время вычисления каждой из функций <img class=tex src="../tex2png/cache/4fae602430f9c03d000e58a8078d842b.png" alt="f_1(p)"> и <img class=tex src="../tex2png/cache/3f9bea716fa5c5fe6e9c3db297517ab1.png" alt="f_2(q)">. И та, и другая содержит возведение в степень, которое можно выполнять с помощью <a href="binary_pow.html">алгоритма бинарного возведения в степень</a>. Тогда обе этих функции мы можем вычислять за время <img class=tex src="../tex2png/cache/af4db54e6b1659adbfeec2c133ae45e2.png" alt="O(\log m)">.<p>Сам алгоритм в первой фазе содержит вычисление функции <img class=tex src="../tex2png/cache/4fae602430f9c03d000e58a8078d842b.png" alt="f_1(p)"> для каждого возможного значения <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> и дальнейшую сортировку значений, что даёт нам асимптотику:<p><p class=formula><img class=tex src="../tex2png/cache/0f5ea5425deac7b911f45c2d067826d4.png" alt=" O\left( \left\lceil \frac{m}{n} \right\rceil \lef[...]"></p><p>Во второй фазе алгоритма происходит вычисление функции <img class=tex src="../tex2png/cache/3f9bea716fa5c5fe6e9c3db297517ab1.png" alt="f_2(q)"> для каждого возможного значения <img class=tex src="../tex2png/cache/733a381de525580104aa275afe299ec1.png" alt="q"> и бинарный поиск по массиву значений <img class=tex src="../tex2png/cache/1f61c75bc3066dabd9982f029dd1da3b.png" alt="f_1">, что даёт нам асимптотику:<p><p class=formula><img class=tex src="../tex2png/cache/3b5c3083bb1a126316e54f1d00f94787.png" alt=" O\left( n \left( \log m + \log \left\lceil \frac{[...]"></p><p>Теперь, когда мы сложим эти две асимптотики, у нас получится <img class=tex src="../tex2png/cache/a70b4ea8ab5cf32a31cb2ecac114f464.png" alt="\log m">, умноженный на сумму <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> и <img class=tex src="../tex2png/cache/b2e352062c4d7e8b922845d22951d1c3.png" alt="m/n">, и практически очевидно, что минимум достигается, когда <img class=tex src="../tex2png/cache/807027172f9b52a2b51325594fb043e1.png" alt="n \approx m/n">, т.е. для оптимальной работы алгоритма константу <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> следует выбирать так:<p><p class=formula><img class=tex src="../tex2png/cache/c4ddef8e3c2ebd1e3261a0d6fb805c46.png" alt=" n \approx \sqrt{m}. "></p><p>Тогда асимптотика алгоритма принимает вид:<p><p class=formula><img class=tex src="../tex2png/cache/0a8e81ea414b4cefe3107a69bf866ecd.png" alt=" O\left( \sqrt{m} ~ \log m \right). "></p><p>Примечание. Мы могли бы обменять ролями <img class=tex src="../tex2png/cache/1f61c75bc3066dabd9982f029dd1da3b.png" alt="f_1"> и <img class=tex src="../tex2png/cache/703ea045144a19504640b199daf295fe.png" alt="f_2"> (т.е. на первой фазе вычислять значения функции <img class=tex src="../tex2png/cache/703ea045144a19504640b199daf295fe.png" alt="f_2">, а а второй &mdash; <img class=tex src="../tex2png/cache/1f61c75bc3066dabd9982f029dd1da3b.png" alt="f_1">), однако легко понять, что результат от этого не изменится, и асимптотику этим мы никак не улучшим.<p><p><h2 style="padding-top:40px;"> Реализация </h2><p><p><h3 style="padding-top:15px;"> Простейшая реализация </h3><p>Функция <img class=tex src="../tex2png/cache/edb4d5ee4f676cce34b534852d94f9c9.png" alt="\rm powmod"> выполняет бинарное возведение числа <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> в степень <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> по модулю <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m">, см. <a href="binary_pow.html">Бинарное возведение в степень</a>.<p>Функция <img class=tex src="../tex2png/cache/501b00642e11bd93d6073e0b23cce761.png" alt="\rm solve"> производит собственно решение задачи. Эта функция возвращает ответ (число в промежутке <img class=tex src="../tex2png/cache/b9c52bebb9074ce17c4acc08da79e109.png" alt="[0;m)">), точнее говоря, один из ответов. Функция вернёт <img class=tex src="../tex2png/cache/fc5f9135f75a6da19325dc3822484bbd.png" alt="-1">, если решения не существует.<p><pre class="notranslate cpp"><span class="kw4">int</span> powmod <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b, <span class="kw4">int</span> m<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> res <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>b <span class="sy1">&gt;</span> <span class="nu0">0</span><span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>b <span class="sy3">&amp;</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			res <span class="sy1">=</span> <span class="br0">&#40;</span>res <span class="sy2">*</span> a<span class="br0">&#41;</span> <span class="sy2">%</span> m<span class="sy4">;</span>
			<span class="sy2">--</span>b<span class="sy4">;</span>
		<span class="br0">&#125;</span>
		<span class="kw1">else</span> <span class="br0">&#123;</span>
			a <span class="sy1">=</span> <span class="br0">&#40;</span>a <span class="sy2">*</span> a<span class="br0">&#41;</span> <span class="sy2">%</span> m<span class="sy4">;</span>
			b <span class="sy1">&gt;&gt;=</span> <span class="nu0">1</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="kw1">return</span> res <span class="sy2">%</span> m<span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> solve <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b, <span class="kw4">int</span> m<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> <span class="kw3">sqrt</span> <span class="br0">&#40;</span>m <span class="sy2">+</span> <span class="nu18">.0</span><span class="br0">&#41;</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
	map<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> vals<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span>n<span class="sy4">;</span> i<span class="sy1">&gt;=</span><span class="nu0">1</span><span class="sy4">;</span> <span class="sy2">--</span>i<span class="br0">&#41;</span>
		vals<span class="br0">&#91;</span> powmod <span class="br0">&#40;</span>a, i <span class="sy2">*</span> n, m<span class="br0">&#41;</span> <span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;=</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> cur <span class="sy1">=</span> <span class="br0">&#40;</span>powmod <span class="br0">&#40;</span>a, i, m<span class="br0">&#41;</span> <span class="sy2">*</span> b<span class="br0">&#41;</span> <span class="sy2">%</span> m<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>vals.<span class="me1">count</span><span class="br0">&#40;</span>cur<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> ans <span class="sy1">=</span> vals<span class="br0">&#91;</span>cur<span class="br0">&#93;</span> <span class="sy2">*</span> n <span class="sy2">-</span> i<span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>ans <span class="sy1">&lt;</span> m<span class="br0">&#41;</span>
				<span class="kw1">return</span> ans<span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Здесь мы для удобства при реализации первой фазы алгоритма воспользовались структурой данных "map" (красно-чёрным деревом), которая для каждого значения функции <img class=tex src="../tex2png/cache/f6abb8233dca2e3a0fd8e4b3b7f810a5.png" alt="f_1(i)"> хранит аргумент <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, при котором это значение достигалось. При этом если одно и то же значение достигалось несколько раз, записывается наименьший из всех аргументов. Это сделано для того, чтобы впоследствии, на второй фазе алгоритма, нашёлся ответ в промежутке <img class=tex src="../tex2png/cache/b9c52bebb9074ce17c4acc08da79e109.png" alt="[0;m)">.<p>Учитывая, что аргумент функции <img class=tex src="../tex2png/cache/0ddaab584cf83af67ef84807dcead3ab.png" alt="f_1()"> на первой фазе у нас перебирался от единицы и до <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, а аргумент функции <img class=tex src="../tex2png/cache/69d7b2909ce4e42304249f9d2eaa3218.png" alt="f_2()"> на второй фазе перебирается от нуля до <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, то в итоге мы покрываем всё множество возможных ответов, т.к. отрезок <img class=tex src="../tex2png/cache/a66b1d6b145ff0b7153fc91ca3538944.png" alt="[0; n^2]"> содержит в себе промежуток <img class=tex src="../tex2png/cache/b9c52bebb9074ce17c4acc08da79e109.png" alt="[0;m)">. При этом отрицательным ответ получиться не мог, а ответы, большие либо равные <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> мы можем игнорировать &mdash; всё равно должны находиться соответствующие им ответы из промежутка <img class=tex src="../tex2png/cache/b9c52bebb9074ce17c4acc08da79e109.png" alt="[0;m)">.<p>Эту функцию можно изменить на тот случай, если требуется находить <b>все решения</b> задачи дискретного логарифма. Для этого надо заменить "map" на какую-либо другую структуру данных, позволяющую хранить для одного аргумента сразу несколько значений (например, "multimap"), и соответствующим образом изменить код второй фазы.<p><p><h3 style="padding-top:15px;"> Улучшенная реализация </h3><p>При <b>оптимизации по скорости</b> можно поступить следующим образом.<p>Во-первых, сразу бросается в глаза ненужность бинарного возведения в степень на второй фазе алгоритма. Вместо этого можно просто завести переменную и домножать её каждый раз на <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">.<p>Во-вторых, таким же образом можно избавиться от бинарного возведения в степень и на первой фазе: в самом деле, достаточно один раз посчитать величину <img class=tex src="../tex2png/cache/b666399b7062b6e8fbf046b598a2b9a7.png" alt="a^n">, и потом просто домножать на неё.<p>Таким образом, логарифм в асимптотике по-прежнему останется, но это будет только логарифм, связанный со структурой данных <img class=tex src="../tex2png/cache/5e68247e44b416c56ee0a1b3f85bedb5.png" alt="map<>"> (т.е., в терминах алгоритма, с сортировкой и бинарным поиском значений) &mdash; т.е. это будет логарифм от <img class=tex src="../tex2png/cache/e04accd41225fc6a693f8554729890f6.png" alt="\sqrt{m}">, что на практике даёт заметное ускорение.<p><pre class="notranslate cpp"><span class="kw4">int</span> solve <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b, <span class="kw4">int</span> m<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> <span class="kw3">sqrt</span> <span class="br0">&#40;</span>m <span class="sy2">+</span> <span class="nu18">.0</span><span class="br0">&#41;</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
&nbsp;
	<span class="kw4">int</span> an <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		an <span class="sy1">=</span> <span class="br0">&#40;</span>an <span class="sy2">*</span> a<span class="br0">&#41;</span> <span class="sy2">%</span> m<span class="sy4">;</span>
&nbsp;
	map<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> vals<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">1</span>, cur<span class="sy1">=</span>an<span class="sy4">;</span> i<span class="sy1">&lt;=</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>vals.<span class="me1">count</span><span class="br0">&#40;</span>cur<span class="br0">&#41;</span><span class="br0">&#41;</span>
			vals<span class="br0">&#91;</span>cur<span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
		cur <span class="sy1">=</span> <span class="br0">&#40;</span>cur <span class="sy2">*</span> an<span class="br0">&#41;</span> <span class="sy2">%</span> m<span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span>, cur<span class="sy1">=</span>b<span class="sy4">;</span> i<span class="sy1">&lt;=</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>vals.<span class="me1">count</span><span class="br0">&#40;</span>cur<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> ans <span class="sy1">=</span> vals<span class="br0">&#91;</span>cur<span class="br0">&#93;</span> <span class="sy2">*</span> n <span class="sy2">-</span> i<span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>ans <span class="sy1">&lt;</span> m<span class="br0">&#41;</span>
				<span class="kw1">return</span> ans<span class="sy4">;</span>
		<span class="br0">&#125;</span>
		cur <span class="sy1">=</span> <span class="br0">&#40;</span>cur <span class="sy2">*</span> a<span class="br0">&#41;</span> <span class="sy2">%</span> m<span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Наконец, если модуль <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> достаточно мал, то можно и вовсе избавиться от логарифма в асимптотике &mdash; просто заведя вместо <img class=tex src="../tex2png/cache/5e68247e44b416c56ee0a1b3f85bedb5.png" alt="map<>"> обычный массив.<p>Также можно вспомнить про хеш-таблицы: в среднем они работают также за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)">, что в целом даёт асимптотику <img class=tex src="../tex2png/cache/d8f415f2f813965af9d8d39834ad68a8.png" alt="O (\sqrt{m})">.<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>