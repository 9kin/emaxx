<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Наименьший общий предок. Нахождение за O (1) в режиме оффлайн (алгоритм Тарьяна)</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 2 Mar 2009 17:45<br>редактировано: 2 Mar 2009 17:45</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="lca_linear_offline.html#" id="contents-hide">[скрыть]</a><a href="lca_linear_offline.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Наименьший общий предок. Нахождение за <img class=tex src="../tex2png/cache/c87ec97cf67d6be659ec0e5df125fdf9.png" alt="O(1)"> в оффлайн (алгоритм Тарьяна)</h1><p>Дано дерево <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами и дано <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> запросов вида <img class=tex src="../tex2png/cache/c9825f52ae4d8dc6c5f1e0645c8185d5.png" alt="(a_i, b_i)">. Для каждого запроса <img class=tex src="../tex2png/cache/c9825f52ae4d8dc6c5f1e0645c8185d5.png" alt="(a_i, b_i)"> требуется найти наименьшего общего предка вершин <img class=tex src="../tex2png/cache/ef875bf5bad8370d4f3bbe3c740d3dd3.png" alt="a_i"> и <img class=tex src="../tex2png/cache/0993821d823b5b792321f13c90efa683.png" alt="b_i">, т.е. такую вершину <img class=tex src="../tex2png/cache/b09688ad845c76c741e11e3c6d492a95.png" alt="c_i">, которая наиболее удалена от корня дерева, и при этом является предком обеих вершин <img class=tex src="../tex2png/cache/ef875bf5bad8370d4f3bbe3c740d3dd3.png" alt="a_i"> и <img class=tex src="../tex2png/cache/0993821d823b5b792321f13c90efa683.png" alt="b_i">.<p>Мы рассматриваем задачу в режиме оффлайн, т.е. считая, что все запросы известны заранее. Описываемый ниже алгоритм позволяет ответить на все <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> запросов за суммарное время <img class=tex src="../tex2png/cache/d20d4ea468976eeb83adea753c1fd674.png" alt="O(n+m)">, т.е. при достаточно большом <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> на запрос.<p><h2 style="padding-top:40px;">Алгоритм Тарьяна</h2><p>Основой для алгоритма является структура данных <a href="dsu.html">"Система непересекающихся множеств"</a>, которая и была изобретена Тарьяном (Tarjan).<p>Алгоритм фактически представляет собой обход в глубину из корня дерева, в процессе которого постепенно находятся ответы на запросы. А именно, ответ на запрос <img class=tex src="../tex2png/cache/fae7fc7228760232ded84ec7bb795757.png" alt="(v,u)"> находится, когда обход в глубину находится в вершине <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">, а вершина <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> уже была посещена, или наоборот.<p>Итак, пусть обход в глубину находится в вершине <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> (и уже были выполнены переходы в её сыновей), и оказалось, что для какого-то запроса <img class=tex src="../tex2png/cache/fae7fc7228760232ded84ec7bb795757.png" alt="(v,u)"> вершина <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> уже была посещена обходом в глубину. Научимся тогда находить <img class=tex src="../tex2png/cache/5ec07a68ece2281bf933f3ea070168b0.png" alt="\rm LCA"> этих двух вершин.<p>Заметим, что <img class=tex src="../tex2png/cache/9ff92b6826d0692eb3ac771203a975fb.png" alt="{\rm LCA}(v,u)"> является либо самой вершиной <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, либо одним из её предков. Получается, нам надо найти самую нижнюю вершину среди предков <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> (включая её саму), для которой вершина <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> является потомком. Заметим, что при фиксированном <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> по такому признаку (т.е. какой наименьший предок <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> является и предком какой-то вершины) вершины дерева дерева распадаются на совокупность непересекающихся классов. Для каждого предка <img class=tex src="../tex2png/cache/d772c5635ae21a530a80070d635758bb.png" alt="p \not= v"> вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> её класс содержит саму эту вершину, а также все поддеревья с корнями в тех её сыновьях, которые лежат "слева" от пути до <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> (т.е. которые были обработаны ранее, чем была достигнута <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">).<p>Нам надо научиться эффективно поддерживать все эти классы, для чего мы и применим структуру данных "Система непересекающихся множеств". Каждому классу будет соответствовать в этой структуре множество, причём для представителя этого множества мы определим величину <img class=tex src="../tex2png/cache/3d267a7ce2cb7c429a874ea252a8d22d.png" alt="\rm ANCESTOR"> &mdash; ту вершину <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p">, которая и образует этот класс.<p>Рассмотрим подробно реализацию обхода в глубину. Пусть мы стоим в некоторой вершине <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Поместим её в отдельный класс в структуре непересекающихся множеств, <img class=tex src="../tex2png/cache/d01d7f78dd15d5ae85577fe57dcb597c.png" alt="{\rm ANCESTOR}[v] = v">. Как обычно в обходе в глубину, перебираем все исходящие рёбра <img class=tex src="../tex2png/cache/dca0fc215fd057cc0b0d328e204940b7.png" alt="(v, to)">. Для каждого такого <img class=tex src="../tex2png/cache/7be3c5a08d7b05904e6766911551f4e5.png" alt="to"> мы сначала должны вызвать обход в глубину из этой вершины, а потом добавить эту вершину со всем её поддеревом в класс вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Это реализуется операцией <img class=tex src="../tex2png/cache/bf3ada1e57f1699d95da6903db86ed0b.png" alt="\rm Union"> структуры данных "система непересекающихся множеств", с последующей установкой <img class=tex src="../tex2png/cache/0cbf4e406decb2f1d94259d8a5517bc6.png" alt="{\rm ANCESTOR} = v"> для представителя множества (т.к. после объединения представитель класса мог измениться). Наконец, после обработки всех рёбер мы перебираем все запросы вида <img class=tex src="../tex2png/cache/fae7fc7228760232ded84ec7bb795757.png" alt="(v,u)">, и если <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u"> была помечена как посещённая обходом в глубину, то ответом на этот запрос будет вершина <img class=tex src="../tex2png/cache/e7cead551b3901be32877d07ae8e478a.png" alt="{\rm LCA}(v,u) = {\rm ANCESTOR}[{\rm FindSet}(u)]">. Нетрудно заметить, что для каждого запроса это условие (что одна вершина запроса является текущей, а другая была посещена ранее) выполнится ровно один раз.<p>Оценим <b>асимптотику</b>. Она складывается из нескольких частей. Во-первых, это асимптотика обхода в глубину, которая в данном случае составляет <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">. Во-вторых, это операции по объединению множеств, которые в сумме для всех разумных <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> затрачивают <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> операций. В-третьих, это для каждого запроса проверка условия (два раза на запрос) и определение результата (один раз на запрос), каждое, опять же, для всех разумных <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> выполняется за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)">. Итоговая асимптотика получается <img class=tex src="../tex2png/cache/d20d4ea468976eeb83adea753c1fd674.png" alt="O(n+m)">, что означает для достаточно больших <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> (<img class=tex src="../tex2png/cache/ef4048dd110b9a5cbe37798677eb2948.png" alt="n = O(m)">) ответ за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> на один запрос.<p><h2 style="padding-top:40px;">Реализация</h2><p>Приведём полную реализацию данного алгоритма, включая слегка изменённую (с поддержкой <img class=tex src="../tex2png/cache/3d267a7ce2cb7c429a874ea252a8d22d.png" alt="\rm ANCESTOR">) реализацию системы пересекающихся множеств (рандомизированный варианта).<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> MAXN <span class="sy1">=</span> максимальное число вершин в графе<span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> g<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, q<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span> <span class="co1">// граф и все запросы</span>
<span class="kw4">int</span> dsu<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, ancestor<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">bool</span> u<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> dsu_get <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">return</span> v <span class="sy1">==</span> dsu<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy4">?</span> v <span class="sy4">:</span> dsu<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> dsu_get <span class="br0">&#40;</span>dsu<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> dsu_unite <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b, <span class="kw4">int</span> new_ancestor<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	a <span class="sy1">=</span> dsu_get <span class="br0">&#40;</span>a<span class="br0">&#41;</span>,  b <span class="sy1">=</span> dsu_get <span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw3">rand</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy3">&amp;</span> <span class="nu0">1</span><span class="br0">&#41;</span>  swap <span class="br0">&#40;</span>a, b<span class="br0">&#41;</span><span class="sy4">;</span>
	dsu<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">=</span> b,  ancestor<span class="br0">&#91;</span>b<span class="br0">&#93;</span> <span class="sy1">=</span> new_ancestor<span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> dfs <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	dsu<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> v,  ancestor<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
	u<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>u<span class="br0">&#91;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			dfs <span class="br0">&#40;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
			dsu_unite <span class="br0">&#40;</span>v, g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span>, v<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>q<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>u<span class="br0">&#91;</span>q<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw3">printf</span> <span class="br0">&#40;</span><span class="st0">&quot;%d %d -&gt; %d<span class="es1">\n</span>&quot;</span>, v<span class="sy2">+</span><span class="nu0">1</span>, q<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy2">+</span><span class="nu0">1</span>,
				ancestor<span class="br0">&#91;</span> dsu_get<span class="br0">&#40;</span>q<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#93;</span><span class="sy2">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	... чтение графа ...
&nbsp;
	<span class="co1">// чтение запросов</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> a, b <span class="sy1">=</span> ...<span class="sy4">;</span> <span class="co1">// очередной запрос</span>
		<span class="sy2">--</span>a, <span class="sy2">--</span>b<span class="sy4">;</span>
		q<span class="br0">&#91;</span>a<span class="br0">&#93;</span>.<span class="me1">push_back</span> <span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="sy4">;</span>
		q<span class="br0">&#91;</span>b<span class="br0">&#93;</span>.<span class="me1">push_back</span> <span class="br0">&#40;</span>a<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="co1">// обход в глубину и ответ на запросы</span>
	dfs <span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>