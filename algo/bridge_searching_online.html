<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Поиск мостов в режиме онлайн</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 5 Aug 2011 1:55<br>редактировано: 5 Aug 2011 1:55</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="bridge_searching_online.html#" id="contents-hide">[скрыть]</a><a href="bridge_searching_online.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Поиск мостов в режиме онлайн</h1><p>Пусть дан неориентированный граф. Мостом называется такое ребро, удаление которого делает граф несвязным (или, точнее, увеличивает число компонент связности). Требуется найти все мосты в заданном графе.<p>Неформально эта задача ставится следующим образом: требуется найти на заданной карте дорог все "важные" дороги, т.е. такие дороги, что удаление любой из них приведёт к исчезновению пути между какой-то парой городов.<p>Описываемый здесь алгоритм является <b>онлайновым</b>, что означает, что входной граф не является известным заранее, а рёбра в него добавляются по одному, и после каждого такого добавления алгоритм пересчитывает все мосты в текущем графе. Иными словами, алгоритм предназначен для эффективной работы на динамическом, изменяющемся графе.<p>Более строго, <b>постановка задачи</b> следующая. Изначально граф пустой и состоит из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершин. Затем поступают запросы, каждый из которых &mdash; это пара вершин <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)">, которые обозначают ребро, добавляемое в граф. Требуется после каждого запроса, т.е. после добавления каждого ребра, выводить текущее количество мостов в графе. (При желании можно поддерживать и список всех рёбер-мостов, а также явно поддерживать компоненты рёберной двусвязности.)<p>Описываемый ниже алгоритм работает за время <img class=tex src="../tex2png/cache/b5bcc3457b4a7a1f7c4d64c504689eae.png" alt="O (n \log n + m)">, где <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> &mdash; число запросов. Алгоритм основан на <a href="dsu.html">структуре данных "система непересекающихся множеств"</a>.<p>Приведённая реализация алгоритма, впрочем, работает за время <img class=tex src="../tex2png/cache/03ed306f07b7c6e18a4ea690c39553e5.png" alt="O (n \log n + m \log n)">, поскольку использует в одном месте упрощённую версию <a href="dsu.html">системы непересекающихся множеств</a> без ранговой эвристики.<p><p><h2 style="padding-top:40px;">Алгоритм</h2><p>Известно, что рёбра-мосты разбивают вершины графа на компоненты, называемые компонентами рёберной двусвязности. Если каждую компоненту рёберной двусвязности сжать в одну вершину, и оставить только рёбра-мосты между этими компонентами, то получится ациклический граф, т.е. лес.<p>Описываемый ниже алгоритм поддерживает в явном виде этот <b>лес компонент рёберной двусвязности</b>.<p>Понятно, что изначально, когда граф пустой, он содержит <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> компонент рёберной двусвязности, не связанных никак между собой.<p>При добавлении очередного ребра <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> может возникнуть три ситуации:<p><ul><p><li>Оба конца <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> находятся в одной и той же компоненте рёберной двусвязности &mdash; тогда это ребро не является мостом, и ничего не меняет в структуре леса, поэтому просто пропускаем это ребро.<p>Таким образом, в этом случае число мостов не меняется.<p><li>Вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> находятся в разных компонентах связности, т.е. соединяют два дерева. В этом случае ребро <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> становится новым мостом, а эти два дерева объединяются в одно (а все старые мосты остаются).<p>Таким образом, в этом случае число мостов увеличивается на единицу.<p><li>Вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> находятся в одной компоненте связности, но в разных компонентах рёберной двусвязности. В этом случае это ребро образует цикл вместе с некоторыми из старых мостов. Все эти мосты перестают быть мостами, а образовавшийся цикл надо объединить в новую компоненту рёберной двусвязности.<p>Таким образом, в этом случае число мостов уменьшается на два или более.<p></ul><p>Следовательно, вся задача сводится к эффективной реализации всех этих операций над лесом компонент.<p><h3 style="padding-top:15px;">Структуры данных для хранения леса</h3><p>Всё, что нам понадобится из структур данных, &mdash; это <a href="dsu.html">система непересекающихся множеств</a>. На самом деле, нам понадобится делать два экземпляра этой структуры: одна будет для поддержания <b>компонент связности</b>, другая &mdash; для поддержания <b>компонент рёберной двусвязности</b>.<p>Кроме того, для хранения структуры деревьев в лесу компонент двусвязности для каждой вершины будем хранить указатель <img class=tex src="../tex2png/cache/5160c5f320870a07c6c55e127617f569.png" alt="{\rm par}[]"> на её предка в дереве.<p>Будем теперь последовательно разбирать каждую операцию, которую нам надо научиться реализовывать:<p><ul><p><li><b>Проверка, лежат ли две указанные вершины в одной компоненте связности/двусвязности</b>. Делается обычным запросом к структуре "система непересекающихся множеств".<p><li><b>Соединение двух деревьев в одно</b> по некоторому ребру <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)">. Поскольку могло получиться, что ни вершина <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, ни вершина <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> не являются корнями своих деревьев, то единственный способ соединить эти два дерева &mdash; <b>переподвесить</b> одно из них. Например, можно переподвесить одно дерево за вершину <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, и затем присоединить это к другому дереву, сделав вершину <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> дочерней к <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">.<p>Однако встаёт вопрос об эффективности операции переподвешивания: чтобы переподвесить дерево с корнем в <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r"> за вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, надо пройти по пути из <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> в <img class=tex src="../tex2png/cache/d51b82f01bc38fe0d2e4a69ebec7c641.png" alt="r">, перенаправляя указатели <img class=tex src="../tex2png/cache/5160c5f320870a07c6c55e127617f569.png" alt="{\rm par}[]"> в обратную сторону, а также меняя ссылки на предка в системе непересекающихся множеств, отвечающей за компоненты связности.<p>Таким образом, стоимость операции переподвешивания есть <img class=tex src="../tex2png/cache/2eaee2dcb904b1b311bc2642ee17db4b.png" alt="O(h)">, где <img class=tex src="../tex2png/cache/0f2a144dc82bc6974b98d1a4d3972640.png" alt="h"> &mdash; высота дерева. Можно оценить её ещё выше, сказав, что это есть величина <img class=tex src="../tex2png/cache/35b74bd28b3f5d5adb92732d64e58ec6.png" alt="O({\rm size})">, где <img class=tex src="../tex2png/cache/5c841c4b1f0ffa15ac2c97244c2b16df.png" alt="\rm size"> &mdash; число вершин в дереве.<p>Применим теперь такой стандартный приём: скажем, что из двух деревьев <b>переподвешивать будем то, в котором меньше вершин</b>. Тогда интуитивно понятно, что худший случай &mdash; когда объединяются два дерева примерно равного размера, но тогда в результате получается дерево вдвое большего размера, что не позволяет такой ситуации происходить много раз. Формально это можно записать в виде рекуррентного соотношения:<p><p class=formula><img class=tex src="../tex2png/cache/19ef47bec2eee1c0c6bac354dd4a8599.png" alt=" T(n) = \max_{k = 1 \ldots n-1} \left\{ ~ T(k) + T[...]"></p><p>где через <img class=tex src="../tex2png/cache/d6fc6b4d622783678ffe9beb4007b66d.png" alt="T(n)"> мы обозначили число операций, необходимое для получения дерева из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершин с помощью операций переподвешивания и объединения деревьев. Это известное рекуррентное соотношение, и оно имеет решение <img class=tex src="../tex2png/cache/f02478bd1fd7c06f3388a8b01c9ab1ec.png" alt="T(n) = O(n \log n)">.<p>Таким образом, суммарное время, затрачиваемое на всех переподвешивания, составит <img class=tex src="../tex2png/cache/527d68b29319f540bf910dd5bb881008.png" alt="O(n \log n)">, если мы всегда будем переподвешивать меньшее из двух дерево.<p>Нам придётся поддерживать размеры каждой компоненты связности, но структура данных "система непересекающихся множеств" позволяет делать это без труда.<p><li><b>Поиск цикла</b>, образуемого добавлением нового ребра <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> в какое-то дерево. Фактически это означает, что нам надо найти наименьшего общего предка (LCA) вершин <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">.<p>Заметим, что потом мы сожмём все вершины обнаруженного цикла в одну вершину, поэтому нас устроит любой алгоритма поиска LCA, работающий за время порядка его длины.<p>Поскольку вся информация о структуре дерева, которая у нас есть, &mdash; это ссылки <img class=tex src="../tex2png/cache/40b08b6e899113d9fbf47faa1f31be5c.png" alt="par[]"> на предков, то единственно возможным представляется следующий алгоритм поиска LCA: помечаем вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> как посещённые, затем переходим к их предкам <img class=tex src="../tex2png/cache/10c3b682735568fea4597f0a06b7d0c8.png" alt="{\rm par}[a]"> и <img class=tex src="../tex2png/cache/481254477d8bdef8af4bf26ea5bf8744.png" alt="{\rm par}[b]"> и помечаем их, потом к их предкам, и так далее, пока не случится, что хотя бы одна из двух текущих вершин уже помечена. Это будет означать, что текущая вершина &mdash; и есть искомый LCA, и надо будет заново повторить путь до неё от вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и от вершины <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> &mdash; тем самым мы найдём искомый цикл.<p>Очевидно, что этот алгоритм работает за время порядка длины искомого цикла, поскольку каждый из двух указателей не мог пройти расстояние, большее этой длины.<p><li><b>Сжатие цикла</b>, образуемого добавлением нового ребра <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> в какое-то дерево.<p>Нам требуется создать новую компоненту рёберной двусвязности, которая будет состоять из всех вершин обнаруженного цикла (понятно, что обнаруженный цикл сам мог состоять из каких-то компонент двусвязности, но это ничего не меняет). Кроме того, надо произвести сжатие таким образом, чтобы не нарушилась структура дерева, и все указатели <img class=tex src="../tex2png/cache/5160c5f320870a07c6c55e127617f569.png" alt="{\rm par}[]"> и две системы непересекающихся множеств были корректными.<p>Самый простой способ добиться этого &mdash; <b>сжать все вершины найденного цикла в их LCA</b>. В самом деле, вершина-LCA &mdash; это самая высокая из сжимаемых вершин, т.е. её <img class=tex src="../tex2png/cache/3f569528232748e2e53141bb91d60eeb.png" alt="{\rm par}"> остаётся без изменений. Для всех остальных сжимаемых вершин обновлять тоже ничего не надо, поскольку эти вершины просто перестают существовать &mdash; в системе непересекающихся множеств для компонент двусвязности все эти вершины будут просто указывать на вершину-LCA.<p>Но тогда получится, что система непересекающихся множеств для компонент двусвязности работает без эвристики объединения по рангу: если мы всегда присоединяем вершины цикла к их LCA, то этой эвристике нет места. В этом случае в асимптотике возникнет <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)">, поскольку без эвристики по рангу любая операция с системой непересекающихся множеств работает именно за такое время.<p><b>Для достижения асимптотики <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"></b> на один запрос необходимо объединять вершины цикла согласно ранговой эвристике, а затем присвоить <img class=tex src="../tex2png/cache/3f569528232748e2e53141bb91d60eeb.png" alt="{\rm par}"> нового лидера в <img class=tex src="../tex2png/cache/0a5161557c7b514e2c55307ec332c1f0.png" alt="{\rm par}[{\rm LCA}]">.<p></ul><p><p><p><h2 style="padding-top:40px;">Реализация</h2><p>Приведём здесь итоговую реализацию всего алгоритма.<p>В целях простоты система непересекающихся множеств для компонент двусвязности написана <b>без ранговой эвристики</b>, поэтому итоговая асимптотика составит <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)"> на запрос в среднем. (О том, как достичь асимптотики <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)">, написано выше в пункте "Сжатие цикла".)<p>Также в данной реализации не хранятся сами рёбра-мосты, а хранится только их количество &mdash; см. переменная <img class=tex src="../tex2png/cache/6f523681bb7e921ee776c90919188fbd.png" alt="\rm bridges">. Впрочем, при желании не составит никакого труда завести <img class=tex src="../tex2png/cache/7ede2edf0170b04cbd85bb62e29617a8.png" alt="{\rm set}"> из всех мостов.<p>Изначально следует вызвать функцию <img class=tex src="../tex2png/cache/acd6c5c0d81215fc523386149b46ab90.png" alt="{\rm init}()">, которая инициализирует две системы непересекающихся множеств (выделяя каждую вершину в отдельное множество, и проставляя размер, равный единице), проставляет предков <img class=tex src="../tex2png/cache/3f569528232748e2e53141bb91d60eeb.png" alt="{\rm par}">.<p>Основная функция &mdash; это <img class=tex src="../tex2png/cache/16349b7d489be34a1b56edc4468f9f57.png" alt="{\rm add\_edge}(a,b)">, которая обрабатывает запрос на добавление нового ребра.<p>Константе <img class=tex src="../tex2png/cache/f60813472f21f2839a771339816c6804.png" alt="\rm MAXN"> следует задать значение, равное максимально возможному количеству вершин во входном графе.<p>Более подробные пояснения к данной реализации см. ниже.<p><p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> MAXN <span class="sy1">=</span> ...<span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> n, bridges, par<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, bl<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, comp<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, size<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
&nbsp;
<span class="kw4">void</span> init<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		bl<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> comp<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
		size<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
		par<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	bridges <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
&nbsp;
<span class="kw4">int</span> get <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>v<span class="sy1">==</span><span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span>  <span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">return</span> bl<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy1">==</span>v <span class="sy4">?</span> v <span class="sy4">:</span> bl<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy1">=</span>get<span class="br0">&#40;</span>bl<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> get_comp <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	v <span class="sy1">=</span> get<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">return</span> comp<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy1">==</span>v <span class="sy4">?</span> v <span class="sy4">:</span> comp<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy1">=</span>get_comp<span class="br0">&#40;</span>comp<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> make_root <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	v <span class="sy1">=</span> get<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw4">int</span> root <span class="sy1">=</span> v,
		child <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>v <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> p <span class="sy1">=</span> get<span class="br0">&#40;</span>par<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		par<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> child<span class="sy4">;</span>
		comp<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> root<span class="sy4">;</span>
		child<span class="sy1">=</span>v<span class="sy4">;</span>  v<span class="sy1">=</span>p<span class="sy4">;</span>
	<span class="br0">&#125;</span>
	size<span class="br0">&#91;</span>root<span class="br0">&#93;</span> <span class="sy1">=</span> size<span class="br0">&#91;</span>child<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
&nbsp;
<span class="kw4">int</span> cu, u<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> merge_path <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="sy2">++</span>cu<span class="sy4">;</span>
&nbsp;
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> va, vb<span class="sy4">;</span>
	<span class="kw4">int</span> lca <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
	<span class="kw1">for</span><span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			a <span class="sy1">=</span> get<span class="br0">&#40;</span>a<span class="br0">&#41;</span><span class="sy4">;</span>
			va.<span class="me1">pb</span> <span class="br0">&#40;</span>a<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
			<span class="kw1">if</span> <span class="br0">&#40;</span>u<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">==</span> cu<span class="br0">&#41;</span> <span class="br0">&#123;</span>
				lca <span class="sy1">=</span> a<span class="sy4">;</span>
				<span class="kw1">break</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
			u<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">=</span> cu<span class="sy4">;</span>
&nbsp;
			a <span class="sy1">=</span> par<span class="br0">&#91;</span>a<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
&nbsp;
		<span class="kw1">if</span> <span class="br0">&#40;</span>b <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			b <span class="sy1">=</span> get<span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="sy4">;</span>
			vb.<span class="me1">pb</span> <span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
			<span class="kw1">if</span> <span class="br0">&#40;</span>u<span class="br0">&#91;</span>b<span class="br0">&#93;</span> <span class="sy1">==</span> cu<span class="br0">&#41;</span> <span class="br0">&#123;</span>
				lca <span class="sy1">=</span> b<span class="sy4">;</span>
				<span class="kw1">break</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
			u<span class="br0">&#91;</span>b<span class="br0">&#93;</span> <span class="sy1">=</span> cu<span class="sy4">;</span>
&nbsp;
			b <span class="sy1">=</span> par<span class="br0">&#91;</span>b<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>va.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		bl<span class="br0">&#91;</span>va<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> lca<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>va<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">==</span> lca<span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
		<span class="sy2">--</span>bridges<span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>vb.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		bl<span class="br0">&#91;</span>vb<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy1">=</span> lca<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>vb<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">==</span> lca<span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
		<span class="sy2">--</span>bridges<span class="sy4">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
&nbsp;
<span class="kw4">void</span> add_edge <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	a <span class="sy1">=</span> get<span class="br0">&#40;</span>a<span class="br0">&#41;</span><span class="sy4">;</span>   b <span class="sy1">=</span> get<span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="sy1">==</span> b<span class="br0">&#41;</span>  <span class="kw1">return</span><span class="sy4">;</span>
&nbsp;
	<span class="kw4">int</span> ca <span class="sy1">=</span> get_comp<span class="br0">&#40;</span>a<span class="br0">&#41;</span>,
		cb <span class="sy1">=</span> get_comp<span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>ca <span class="sy3">!</span><span class="sy1">=</span> cb<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="sy2">++</span>bridges<span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>size<span class="br0">&#91;</span>ca<span class="br0">&#93;</span> <span class="sy1">&gt;</span> size<span class="br0">&#91;</span>cb<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			swap <span class="br0">&#40;</span>a, b<span class="br0">&#41;</span><span class="sy4">;</span>
			swap <span class="br0">&#40;</span>ca, cb<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
		make_root <span class="br0">&#40;</span>a<span class="br0">&#41;</span><span class="sy4">;</span>
		par<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">=</span> comp<span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy1">=</span> b<span class="sy4">;</span>
		size<span class="br0">&#91;</span>cb<span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> size<span class="br0">&#91;</span>a<span class="br0">&#93;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">else</span>
		merge_path <span class="br0">&#40;</span>a, b<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p><p>Прокомментируем код более подробно.<p><b>Система непересекающихся множеств для компонент двусвязности</b> хранится в массиве <img class=tex src="../tex2png/cache/45cca8798b06dc1402330ae39fb8e470.png" alt="{\rm bl}[]">, а функция, возвращающая лидера компоненты двусвязности &mdash; это <img class=tex src="../tex2png/cache/0f5153ddf4c0b22a8feffcbb3a4c8d2a.png" alt="{\rm get}(v)">. Эту функцию используется много раз в остальном коде, поскольку нужно помнить о том, что после сжатия нескольких вершин в одну все эти вершины перестают существовать, а вместо них существует только их лидер, у которого и хранятся корректные данные (предок <img class=tex src="../tex2png/cache/3f569528232748e2e53141bb91d60eeb.png" alt="{\rm par}">, предок в системе непересекающихся множеств для компонент связности, и т.д.).<p><b>Система непересекающихся множеств для компонент связности</b> хранится в массиве <img class=tex src="../tex2png/cache/4f443d01db0f1bcb9c234f0d30742c92.png" alt="{\rm comp}[]">, также есть дополнительный массив <img class=tex src="../tex2png/cache/3c79c18a2d7da7a8b9219c9a5dafbffd.png" alt="{\rm size}[]"> для хранения размеров компонент. Функция <img class=tex src="../tex2png/cache/21b29d0f524b9279032e334d4420d149.png" alt="{\rm get\_comp}(v)"> возвращает лидера компоненты связности (который на самом деле является корнем дерева).<p><b>Функция переподвешивания дерева</b> <img class=tex src="../tex2png/cache/719b809fce92f84bf1ad0fc9b14934f7.png" alt="{\rm make\_root}(v)"> работает, как и было описано выше: она идёт от вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> по предкам до корня, каждый раз перенаправляя предка <img class=tex src="../tex2png/cache/3908147da516fa5e9e2af7bd0817739b.png" alt="\rm par"> в обратную сторону (вниз, по направлению к вершине <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">). Также обновляется указатель <img class=tex src="../tex2png/cache/ece3d8dca48ad248f1243cfbc61caa94.png" alt="{\rm comp}"> в системе непересекающихся множеств для компонент связности, чтобы он указывал на новый корень. После переподвешивания у нового корня проставляется размер <img class=tex src="../tex2png/cache/5a7374cd48909bb5894fda6b8a04e99f.png" alt="{\rm size}"> компоненты связности. Обратим внимание, что при реализации мы каждый раз вызываем функцию <img class=tex src="../tex2png/cache/82f3e128e56f2fd7d759cd0e1cd90146.png" alt="{\rm get}()">, чтобы получить доступ именно к лидеру компоненты сильной связности, а не к какой-то вершине, которая возможно уже была сжата.<p><b>Функция обнаружения и сжатия пути</b> <img class=tex src="../tex2png/cache/76f5d171dc04cb0f4297f8576bb74189.png" alt="{\rm merge\_path}(a,b)">, как и было описано выше, ищет LCA вершин <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">, для чего поднимается от них параллельно вверх, пока какая-то вершина не встретится во второй раз. В целях эффективности пройденные вершины помечаются с помощью техники "числового used", что работает за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> вместо применения <img class=tex src="../tex2png/cache/69ee37dcc56b08d150f58c59e467f874.png" alt="\rm set">. Пройденные пути сохраняются в векторах <img class=tex src="../tex2png/cache/67276187dd7d68853dc9c061bf1e1053.png" alt="\rm va"> и <img class=tex src="../tex2png/cache/c652e3461e70e3b294c77d64afa247a5.png" alt="\rm vb">, чтобы потом пройтись по ним второй раз до LCA, получив тем самым все вершины цикла. Все вершины цикла сжимаются, путём присоединения их к LCA (здесь возникает асимптотика <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)">, поскольку при сжатии мы не используем ранговую эвристику). Попутно считается число пройденных рёбер, которое равно количеству мостов в обнаруженном цикле (это количество отнимается от <img class=tex src="../tex2png/cache/6f523681bb7e921ee776c90919188fbd.png" alt="\rm bridges">).<p>Наконец, <b>функция обработки запросов</b> <img class=tex src="../tex2png/cache/16349b7d489be34a1b56edc4468f9f57.png" alt="{\rm add\_edge}(a,b)"> определяет компоненты связности, в которых лежат вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">, и если они лежат в разных компонентах связности, то меньшее дерево переподвешивается за новый корень и затем присоединяется к большему дереву. Иначе же, если вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> лежат в одном дереве, но в разных компонентах двусвязности, то вызывается функция <img class=tex src="../tex2png/cache/76f5d171dc04cb0f4297f8576bb74189.png" alt="{\rm merge\_path}(a,b)">, которая обнаружит цикл и сожмёт его в одну компоненту двусвязности.<p><p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>