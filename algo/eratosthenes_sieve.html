<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Решето Эратосфена</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 17:57<br>редактировано: 23 Mar 2012 3:53</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="eratosthenes_sieve.html#" id="contents-hide">[скрыть]</a><a href="eratosthenes_sieve.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Решето Эратосфена </h1><p>Решето Эратосфена &mdash; это алгоритм, позволяющий найти все простые числа в отрезке <img class=tex src="../tex2png/cache/69cc1de918936aa552092962896df9f8.png" alt="[1; n]"> за <img class=tex src="../tex2png/cache/cd1c612f470525c506db4c632096a9d0.png" alt="O (n \log \log n)"> операций.<p>Идея проста &mdash; запишем ряд чисел <img class=tex src="../tex2png/cache/703638b38b37c914ea52b0b834b8fb1a.png" alt="1 \ldots n">, и будем вычеркивать сначала все числа, делящиеся на <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2">, кроме самого числа <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2">, затем деляющиеся на <img class=tex src="../tex2png/cache/0e96f2a3dff7da2f31d78c5306207a14.png" alt="3">, кроме самого числа <img class=tex src="../tex2png/cache/0e96f2a3dff7da2f31d78c5306207a14.png" alt="3">, затем на <img class=tex src="../tex2png/cache/ffd5c7a480888cf433d3b57d36bd7c52.png" alt="5">, затем на <img class=tex src="../tex2png/cache/5c705587512261d7061e23ba54f595f3.png" alt="7">, <img class=tex src="../tex2png/cache/365bc3dbe476f24e0e317bd59836a7a7.png" alt="11">, и все остальные простые до <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">.<p><p><h2 style="padding-top:40px;"> Реализация </h2><p>Сразу приведём реализацию алгоритма:<p><pre class="notranslate cpp"><span class="kw4">int</span> n<span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span> prime <span class="br0">&#40;</span>n<span class="sy2">+</span><span class="nu0">1</span>, <span class="kw2">true</span><span class="br0">&#41;</span><span class="sy4">;</span>
prime<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy1">=</span> prime<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> i<span class="sy1">&lt;=</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>prime<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy2">*</span> 1ll <span class="sy2">*</span> i <span class="sy1">&lt;=</span> n<span class="br0">&#41;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span>i<span class="sy2">*</span>i<span class="sy4">;</span> j<span class="sy1">&lt;=</span>n<span class="sy4">;</span> j<span class="sy2">+</span><span class="sy1">=</span>i<span class="br0">&#41;</span>
				prime<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span></pre><p>Этот код сначала помечает все числа, кроме нуля и единицы, как простые, а затем начинает процесс отсеивания составных чисел. Для этого мы перебираем в цикле все числа от <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2"> до <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, и, если текущее число <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> простое, то помечаем все числа, кратные ему, как составные.<p>При этом мы начинаем идти от <img class=tex src="../tex2png/cache/95d8d8375d41df456c1e7eb63730c13d.png" alt="i^2">, поскольку все меньшие числа, кратные <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, обязательно имеют простой делитель меньше <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">, а значит, все они уже были отсеяны раньше. (Но поскольку <img class=tex src="../tex2png/cache/95d8d8375d41df456c1e7eb63730c13d.png" alt="i^2"> легко может переполнить тип <img class=tex src="../tex2png/cache/23ebdff93fb4e6a6fa0e0151a362318d.png" alt="int">, в коде перед вторым вложенным циклом делается дополнительная проверка с использованием типа <img class=tex src="../tex2png/cache/53672e20bd3ab8112ee8976158703060.png" alt="long~long">.)<p>При такой реализации алгоритм потребляет <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"> памяти (что очевидно) и выполняет <img class=tex src="../tex2png/cache/cd1c612f470525c506db4c632096a9d0.png" alt="O (n \log \log n)"> действий (это доказывается в следующем разделе).<p><p><h2 style="padding-top:40px;"> Асимптотика </h2><p>Докажем, что асимптотика алгоритма равна <img class=tex src="../tex2png/cache/cd1c612f470525c506db4c632096a9d0.png" alt="O (n \log \log n)">.<p>Итак, для каждого простого <img class=tex src="../tex2png/cache/0ecca9514f6d4a375609b37599cbcbd9.png" alt="p \le n"> будет выполняться внутренний цикл, который совершит <img class=tex src="../tex2png/cache/cabfd1da6484c996e84fb902e704246e.png" alt="\frac{n}{p}"> действий. Следовательно, нам нужно оценить следующую величину:<p><p class=formula><img class=tex src="../tex2png/cache/2f0d82a4e4ccd7ac3995adfb3c91069c.png" alt=" \sum_{ \scriptstyle p \le n, \atop\scriptstyle p~[...]"></p><p>Вспомним здесь два известных факта: что число простых, меньше либо равных <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, приблизительно равно <img class=tex src="../tex2png/cache/72fb22b97f8b33edf7dccc92562adcc7.png" alt="\frac{n}{\ln n}">, и что <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ое простое число приблизительно равно <img class=tex src="../tex2png/cache/d7a1aa47c042d2aab7772e7d85e434a8.png" alt="k \ln k"> (это следует из первого утверждения). Тогда сумму можно записать таким образом:<p><p class=formula><img class=tex src="../tex2png/cache/a39960e098a59335f793b23086367d24.png" alt=" \sum_{ \scriptstyle p \le n, \atop\scriptstyle p~[...]"></p><p>Здесь мы выделили первое простое из суммы, поскольку при <img class=tex src="../tex2png/cache/dfb92ad404ed30f10e0945d770a761aa.png" alt="k = 1"> согласно приближению <img class=tex src="../tex2png/cache/d7a1aa47c042d2aab7772e7d85e434a8.png" alt="k \ln k"> получится <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0">, что приведёт к делению на нуль.<p>Теперь оценим такую сумму с помощью интеграла от той же функции по <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> от <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2"> до <img class=tex src="../tex2png/cache/72fb22b97f8b33edf7dccc92562adcc7.png" alt="\frac{n}{\ln n}"> (мы можем производить такое приближение, поскольку, фактически, сумма относится к интегралу как его приближение по формуле прямоугольников):<p><p class=formula><img class=tex src="../tex2png/cache/33ccf9f03da499befc7379c5b230c2f1.png" alt=" \sum_{k=2}^{\frac{n}{\ln n}} \frac{1}{k \ln k} \a[...]"></p><p>Первообразная для подынтегральной функции есть <img class=tex src="../tex2png/cache/3c1ae1195f332cfc03c6533a9cbfbf55.png" alt="\ln \ln k">. Выполняя подстановку и убирая члены меньшего порядка, получаем:<p><p class=formula><img class=tex src="../tex2png/cache/743816943e2f10ba7cd5a22bec0c19a4.png" alt=" \int\limits_2^{\frac{n}{\ln n}} \frac{1}{k \ln k}[...]"></p><p>Теперь, возвращаясь к первоначальной сумме, получаем её приближённую оценку:<p><p class=formula><img class=tex src="../tex2png/cache/5fed5f2538b972a06d28dbef8f8b7b47.png" alt=" \sum_{ \scriptstyle p \le n, \atop\scriptstyle p~[...]"></p><p>что и требовалось доказать.<p>Более строгое доказательство (и дающее более точную оценку с точностью до константных множителей) можно найти в книге Hardy и Wright "An Introduction to the Theory of Numbers" (стр. 349).<p><p><h2 style="padding-top:40px;"> Различные оптимизации решета Эратосфена </h2><p>Самый большой недостаток алгоритма &mdash; то, что он "гуляет" по памяти, постоянно выходя за пределы кэш-памяти, из-за чего константа, скрытая в  <img class=tex src="../tex2png/cache/cd1c612f470525c506db4c632096a9d0.png" alt="O (n \log \log n)">, сравнительно велика.<p>Кроме того, для достаточно больших <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> узким местом становится объём потребляемой памяти.<p>Ниже рассмотрены методы, позволяющие как уменьшить число выполняемых операций, так и значительно сократить потребление памяти.<p><p><h3 style="padding-top:15px;"> Просеивание простыми до корня </h3><p>Самый очевидный момент &mdash; что для того, чтобы найти все простые до <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, достаточно выполнить просеивание только простыми, не превосходящими корня из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">.<p>Таким образом, изменится внешний цикл алгоритма:<p><pre class="notranslate cpp"><span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> i<span class="sy2">*</span>i<span class="sy1">&lt;=</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span></pre><p>На асимптотику такая оптимизация не влияет (действительно, повторив приведённое выше доказательство, мы получим оценку <img class=tex src="../tex2png/cache/68f5e392dba59f3585cf630140992f2d.png" alt="n \ln \ln \sqrt{n} + o(n)">, что, по свойствам логарифма, асимптотически есть то же самое), хотя число операций заметно уменьшится.<p><p><h3 style="padding-top:15px;"> Решето только по нечётным числам </h3><p>Поскольку все чётные числа, кроме <img class=tex src="../tex2png/cache/1f68ec6d6ed94148fc6fb5efafc8a688.png" alt="2">, &mdash; составные, то можно вообще не обрабатывать никак чётные числа, а оперировать только нечётными числами.<p>Во-первых, это позволит вдвое сократить объём требуемой памяти. Во-вторых, это уменьшит число делаемых алгоритмом операций примерно вдвое.<p><p><h3 style="padding-top:15px;"> Уменьшение объёма потребляемой памяти </h3><p>Заметим, что алгоритм Эратосфена фактически оперирует с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> битами памяти. Следовательно, можно существенно сэкономить потребление памяти, храня не <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> байт &mdash; переменных булевского типа, а <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> бит, т.е. <img class=tex src="../tex2png/cache/8d4f0fa2f4bf5b32b0532b7a44d4f430.png" alt="n/8"> байт памяти.<p>Однако такой подход &mdash; <b>"битовое сжатие"</b> &mdash; существенно усложнит оперирование этими битами. Любое чтение или запись бита будут представлять из себя несколько арифметических операций, что в итоге приведёт к замедлению алгоритма.<p>Таким образом, этот подход оправдан, только если <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> настолько большое, что <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> байт памяти выделить уже нельзя. Сэкономив память (в <img class=tex src="../tex2png/cache/fa6a7da1482cae770cdfc2108255c1b8.png" alt="8"> раз), мы заплатим за это существенным замедлением алгоритма.<p>В завершение стоит отметить, что в языке C++ уже реализованы контейнеры, автоматически осуществляющие битовое сжатие: vector&lt;bool> и bitset&lt;>. Впрочем, если скорость работы очень важна, то лучше реализовать битовое сжатие вручную, с помощью битовых операций &mdash; на сегодняшний день компиляторы всё же не в состоянии генерировать достаточно быстрый код.<p><p><h3 style="padding-top:15px;"> Блочное решето </h3><p>Из оптимизации "просеивание простыми до корня" следует, что нет необходимости хранить всё время весь массив <img class=tex src="../tex2png/cache/e64f77696e64368dbc68a833f1219cb5.png" alt="prime[1 \ldots n]">. Для выполнения просеивания достаточно хранить только простые до корня из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, т.е. <img class=tex src="../tex2png/cache/d0e7d88f5a418420f8e03c749a2581d3.png" alt="prime[1 \ldots \sqrt{n}]">, а остальную часть массива <img class=tex src="../tex2png/cache/0d6422c2d480651d7f0864d2b897cd2c.png" alt="prime"> строить поблочно, храня в текущий момент времени только один блок.<p>Пусть <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> &mdash; константа, определяющая размер блока, тогда всего будет <img class=tex src="../tex2png/cache/ef10f8de54aabdcf82ca008a3da82b70.png" alt="\left\lceil \frac{n}{s} \right\rceil"> блоков, <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ый блок (<img class=tex src="../tex2png/cache/4de6c65e13c596eeb60454b32c196123.png" alt="k = 0 \ldots \left\lfloor \frac{n}{s} \right\rfloor">) содержит числа в отрезке <img class=tex src="../tex2png/cache/a9cca130aa60f35094f0189129060a23.png" alt="[ks; ks+s-1]">. Будем обрабатывать блоки по очереди, т.е. для каждого <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-го блока будем перебирать все простые (от <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"> до <img class=tex src="../tex2png/cache/59924d89d7dd54098a99b85b4e3cda4b.png" alt="\sqrt{n}">) и выполнять ими просеивание только внутри текущего блока. Аккуратно стоит обрабатывать первый блок &mdash; во-первых, простые из <img class=tex src="../tex2png/cache/f1a4b2931c132ac680dcfaa22feab892.png" alt="[1; \sqrt{n}]"> не должны удалить сами себя, а во-вторых, числа <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0"> и <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"> должны особо помечаться как не простые. При обработке последнего блока также следует не забывать о том, что последнее нужное число <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> не обязательно находится в конце блока.<p>Приведём реализацию блочного решета. Программа считывает число <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> и находит количество простых от <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"> до <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">:<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> SQRT_MAXN <span class="sy1">=</span> <span class="nu0">100000</span><span class="sy4">;</span> <span class="co1">// корень из максимального значения N</span>
<span class="kw4">const</span> <span class="kw4">int</span> S <span class="sy1">=</span> <span class="nu0">10000</span><span class="sy4">;</span>
<span class="kw4">bool</span> nprime<span class="br0">&#91;</span>SQRT_MAXN<span class="br0">&#93;</span>, bl<span class="br0">&#91;</span>S<span class="br0">&#93;</span><span class="sy4">;</span>
<span class="kw4">int</span> primes<span class="br0">&#91;</span>SQRT_MAXN<span class="br0">&#93;</span>, cnt<span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp;
	<span class="kw4">int</span> n<span class="sy4">;</span>
	<span class="kw3">cin</span> <span class="sy1">&gt;&gt;</span> n<span class="sy4">;</span>
	<span class="kw4">int</span> nsqrt <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> <span class="kw3">sqrt</span> <span class="br0">&#40;</span>n <span class="sy2">+</span> <span class="nu18">.0</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">2</span><span class="sy4">;</span> i<span class="sy1">&lt;=</span>nsqrt<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>nprime<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
			primes<span class="br0">&#91;</span>cnt<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> i<span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy2">*</span> 1ll <span class="sy2">*</span> i <span class="sy1">&lt;=</span> nsqrt<span class="br0">&#41;</span>
				<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span>i<span class="sy2">*</span>i<span class="sy4">;</span> j<span class="sy1">&lt;=</span>nsqrt<span class="sy4">;</span> j<span class="sy2">+</span><span class="sy1">=</span>i<span class="br0">&#41;</span>
					nprime<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
&nbsp;
	<span class="kw4">int</span> result <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> k<span class="sy1">=</span><span class="nu0">0</span>, maxk<span class="sy1">=</span>n<span class="sy2">/</span>S<span class="sy4">;</span> k<span class="sy1">&lt;=</span>maxk<span class="sy4">;</span> <span class="sy2">++</span>k<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw3">memset</span> <span class="br0">&#40;</span>bl, <span class="nu0">0</span>, <span class="kw3">sizeof</span> bl<span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw4">int</span> start <span class="sy1">=</span> k <span class="sy2">*</span> S<span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>cnt<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> start_idx <span class="sy1">=</span> <span class="br0">&#40;</span>start <span class="sy2">+</span> primes<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">-</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy2">/</span> primes<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
			<span class="kw4">int</span> j <span class="sy1">=</span> max<span class="br0">&#40;</span>start_idx,<span class="nu0">2</span><span class="br0">&#41;</span> <span class="sy2">*</span> primes<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy2">-</span> start<span class="sy4">;</span>
			<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>S<span class="sy4">;</span> j<span class="sy2">+</span><span class="sy1">=</span>primes<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>
				bl<span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
		<span class="br0">&#125;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>k <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
			bl<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy1">=</span> bl<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>S <span class="sy3">&amp;&amp;</span> start<span class="sy2">+</span>i<span class="sy1">&lt;=</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>bl<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>
				<span class="sy2">++</span>result<span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> result<span class="sy4">;</span>
&nbsp;
<span class="br0">&#125;</span></pre><p>Асимптотика блочного решета такая же, как и обычного решета Эратосфена (если, конечно, размер <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> блоков не будет совсем маленьким), зато объём используемой памяти сократится до <img class=tex src="../tex2png/cache/b2f8651732ad3eca007db24d46de88bd.png" alt="O(\sqrt{n} + s)"> и уменьшится "блуждание" по памяти. Но, с другой стороны, для каждого блока для каждого простого из <img class=tex src="../tex2png/cache/f1a4b2931c132ac680dcfaa22feab892.png" alt="[1; \sqrt{n}]"> будет выполняться деление, что будет сильно сказываться при меньших размерах блока. Следовательно, при выборе константы <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> необходимо соблюсти баланс.<p>Как показывают эксперименты, наилучшая скорость работы достигается, когда <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> имеет значение приблизительно от <img class=tex src="../tex2png/cache/781e070557b5914b2fe00760900d79eb.png" alt="10^4"> до <img class=tex src="../tex2png/cache/8ac6f0c86d21aff9779dc8f80bbf9f64.png" alt="10^5">.<p><p><h3 style="padding-top:15px;"> Улучшение до линейного времени работы </h3><p>Алгоритм Эратосфена можно преобразовать в другой алгоритм, который уже будет работать за линейное время &mdash; см. статью <a href="prime_sieve_linear.html">"Решето Эратосфена с линейным временем работы"</a>. (Впрочем, этот алгоритм имеет и недостатки.)<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>