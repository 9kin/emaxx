<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Топологическая сортировка</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 19:24<br>редактировано: 23 Aug 2011 12:42</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="topological_sort.html#" id="contents-hide">[скрыть]</a><a href="topological_sort.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Топологическая сортировка</h1><p>Дан ориентированный граф с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами и <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> рёбрами. Требуется <b>перенумеровать</b> его вершины таким образом, чтобы каждое рёбро вело из вершины с меньшим номером в вершину с большим.<p>Иными словами, требуется найти перестановку вершин (<b>топологический порядок</b>), соответствующую порядку, задаваемому всеми рёбрами графа.<p>Топологическая сортировка может быть <b>не единственной</b> (например, если граф &mdash; пустой; или если есть три такие вершины <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a">, <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">, <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">, что из <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> есть пути в <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> и в <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">, но ни из <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> в <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">, ни из <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> в <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> добраться нельзя).<p>Топологической сортировки может <b>не существовать</b> вовсе &mdash; если граф содержит циклы (поскольку при этом возникает противоречие: есть путь и из одной вершины в другую, и наоборот).<p><b>Распространённая задача</b> на топологическую сортировку &mdash; следующая. Есть <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> переменных, значения которых нам неизвестны. Известно лишь про некоторые пары переменных, что одна переменная меньше другой. Требуется проверить, не противоречивы ли эти неравенства, и если нет, выдать переменные в порядке их возрастания (если решений несколько &mdash; выдать любое). Легко заметить, что это в точности и есть задача о поиске топологической сортировки в графе из <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершин.<p><p><h2 style="padding-top:40px;">Алгоритм</h2><p>Для решения воспользуемся <a href="dfs.html">обходом в глубину</a>.<p>Предположим, что граф ацикличен, т.е. решение существует. Что делает обход в глубину? При запуске из какой-то вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> он пытается запуститься вдоль всех рёбер, исходящих из <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Вдоль тех рёбер, концы которых уже были посещены ранее, он не проходит, а вдоль всех остальных &mdash; проходит и вызывает себя от их концов.<p>Таким образом, к моменту выхода из вызова <img class=tex src="../tex2png/cache/65fc9396ab91952ca5f7483c7f8eb60f.png" alt="{\rm dfs}(v)"> все вершины, достижимые из <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> как непосредственно (по одному ребру), так и косвенно (по пути) &mdash; все такие вершины уже посещены обходом. Следовательно, если мы будем в момент выхода из <img class=tex src="../tex2png/cache/65fc9396ab91952ca5f7483c7f8eb60f.png" alt="{\rm dfs}(v)"> добавлять нашу вершину в начало некоего списка, то в конце концов в этом списке получится <b>топологическая сортировка</b>.<p>Эти объяснения можно представить и в несколько ином свете, с помощью понятия <b>"времени выхода"</b> обхода в глубину. Время выхода для каждой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> &mdash; это момент времени, в который закончил работать вызов <img class=tex src="../tex2png/cache/65fc9396ab91952ca5f7483c7f8eb60f.png" alt="{\rm dfs}(v)"> обхода в глубину от неё (времена выхода можно занумеровать от <img class=tex src="../tex2png/cache/1737ac55fdbc871d8c7d14245b749ccd.png" alt="1"> до <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">). Легко понять, что при обходе в глубину время выхода из какой-либо вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> всегда больше, чем время выхода из всех вершин, достижимых из неё (т.к. они были посещены либо до вызова <img class=tex src="../tex2png/cache/65fc9396ab91952ca5f7483c7f8eb60f.png" alt="{\rm dfs}(v)">, либо во время него). Таким образом, искомая топологическая сортировка &mdash; это сортировка в порядке убывания времён выхода.<p><p><h2 style="padding-top:40px;">Реализация</h2><p>Приведём реализацию, предполагающую, что граф ацикличен, т.е. искомая топологическая сортировка существует. При необходимости проверку графа на ацикличность легко вставить в обход в глубину, как описано в <a href="dfs.html">статье по обходу в глубину</a>.<p><pre class="notranslate cpp"><span class="kw4">int</span> n<span class="sy4">;</span> <span class="co1">// число вершин</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> g<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span> <span class="co1">// граф</span>
<span class="kw4">bool</span> used<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> ans<span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> dfs <span class="br0">&#40;</span><span class="kw4">int</span> v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	used<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> to <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span>
			dfs <span class="br0">&#40;</span>to<span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="br0">&#125;</span>
	ans.<span class="me1">push_back</span> <span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">void</span> topological_sort<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		used<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span>
	ans.<span class="me1">clear</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>used<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>
			dfs <span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>
	reverse <span class="br0">&#40;</span>ans.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, ans.<span class="me1">end</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Здесь константе <img class=tex src="../tex2png/cache/f60813472f21f2839a771339816c6804.png" alt="\rm MAXN"> следует задать значение, равное максимально возможному числу вершин в графе.<p>Основная функция решения &mdash; это topological_sort, она инициализирует пометки обхода в глубину, запускает его, и ответ в итоге получается в векторе <img class=tex src="../tex2png/cache/607d24373b46b951fe9353e68153b1f4.png" alt="\rm ans">.<p><p><h2 style="padding-top:40px;">Задачи в online judges</h2><p>Список задач, в которых требуется искать топологическую сортировку:<p><ul><p><li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1246">UVA #10305 <b>"Ordering Tasks"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><p><li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=60">UVA #124 <b>"Following Orders"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><p><li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=136">UVA #200 <b>"Rare Order"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: низкая]</a><p><p><p></ul><p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>