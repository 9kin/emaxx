<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Нахождение кратчайших путей между всеми парами вершин графа методом Флойда-Уоршелла</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 19:41<br>редактировано: 24 Aug 2011 1:19</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="floyd_warshall_algorithm.html#" id="contents-hide">[скрыть]</a><a href="floyd_warshall_algorithm.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Алгоритм Флойда-Уоршелла нахождения кратчайших путей между всеми парами вершин </h1><p>Дан ориентированный или неориентированный взвешенный граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами. Требуется найти значения всех величин <img class=tex src="../tex2png/cache/b0ec37d230ce06129ccd81574c133289.png" alt="d_{ij}"> &mdash; длины кратчайшего пути из вершины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> в вершину <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">.<p>Предполагается, что граф не содержит циклов отрицательного веса (тогда ответа между некоторыми парами вершин может просто не существовать &mdash; он будет бесконечно маленьким).<p>Этот алгоритм был одновременно опубликован в статьях Роберта Флойда (Robert Floyd) и Стивена Уоршелла (Варшалла) (Stephen Warshall) в 1962 г., по имени которых этот алгоритм и называется в настоящее время. Впрочем, в 1959 г. Бернард Рой (Bernard Roy) опубликовал практически такой же алгоритм, но его публикация осталась незамеченной.<p><p><h2 style="padding-top:40px;"> Описание алгоритма </h2><p>Ключевая идея алгоритма &mdash; разбиение процесса поиска кратчайших путей на <b>фазы</b>.<p>Перед <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ой фазой (<img class=tex src="../tex2png/cache/7aed531ba7911477598aab38db1f1743.png" alt="k = 1 \ldots n">) считается, что в матрице расстояний <img class=tex src="../tex2png/cache/2108d8213526c488460c3eb1fe11c115.png" alt="d[][]"> сохранены длины таких кратчайших путей, которые содержат в качестве внутренних вершин только вершины из множества <img class=tex src="../tex2png/cache/5e14b50d64fb6fcec64d6dbf5fd3b0fe.png" alt="\{ 1, 2, \ldots, k-1 \}"> (вершины графа мы нумеруем, начиная с единицы).<p>Иными словами, перед <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ой фазой величина <img class=tex src="../tex2png/cache/a18f11689b09b23faa10c78d6b244cf8.png" alt="d[i][j]"> равна длине кратчайшего пути из вершины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> в вершину <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">, если этому пути разрешается заходить только в вершины с номерами, меньшими <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> (начало и конец пути не считаются).<p>Легко убедиться, что чтобы это свойство выполнилось для первой фазы, достаточно в матрицу расстояний <img class=tex src="../tex2png/cache/2108d8213526c488460c3eb1fe11c115.png" alt="d[][]"> записать матрицу смежности графа: <img class=tex src="../tex2png/cache/a02a827cfda7c4cf3d685be5bc3d6ec2.png" alt="d[i][j] = g[i][j]"> &mdash; стоимости ребра из вершины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> в вершину <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">. При этом, если между какими-то вершинами ребра нет, то записать следует величину "бесконечность" <img class=tex src="../tex2png/cache/3d40198f44abce2dbb7a7eb7fba559c9.png" alt="\infty">. Из вершины в саму себя всегда следует записывать величину <img class=tex src="../tex2png/cache/d796aaaffd5bff4144c8ac3509c1d33d.png" alt="0">, это критично для алгоритма.<p>Пусть теперь мы находимся на <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ой фазе, и хотим <b>пересчитать</b> матрицу <img class=tex src="../tex2png/cache/2108d8213526c488460c3eb1fe11c115.png" alt="d[][]"> таким образом, чтобы она соответствовала требованиям уже для <img class=tex src="../tex2png/cache/b7e1992873e6c485f926be57173a6d22.png" alt="k+1">-ой фазы. Зафиксируем какие-то вершины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">. У нас возникает два принципиально разных случая:<p><ul><p><li>Кратчайший путь из вершины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> в вершину <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">, которому разрешено дополнительно проходить через вершины <img class=tex src="../tex2png/cache/eba0e62f1a4feec7e3dc027cdc3ae354.png" alt="\{ 1, 2, \ldots, k \}">, <b>совпадает</b> с кратчайшим путём, которому разрешено проходить через вершины множества <img class=tex src="../tex2png/cache/5e14b50d64fb6fcec64d6dbf5fd3b0fe.png" alt="\{ 1, 2, \ldots, k-1 \}">.<p>В этом случае величина <img class=tex src="../tex2png/cache/a18f11689b09b23faa10c78d6b244cf8.png" alt="d[i][j]"> не изменится при переходе с <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ой на <img class=tex src="../tex2png/cache/b7e1992873e6c485f926be57173a6d22.png" alt="k+1">-ую фазу.<p><li>"Новый" кратчайший путь стал <b>лучше</b> "старого" пути.<p>Это означает, что "новый" кратчайший путь проходит через вершину <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">. Сразу отметим, что мы не потеряем общности, рассматривая далее только простые пути (т.е. пути, не проходящие по какой-то вершине дважды).<p>Тогда заметим, что если мы разобьём этот "новый" путь вершиной <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> на две половинки (одна идущая <img class=tex src="../tex2png/cache/f9f6f3282cb407e3167f40c89f393788.png" alt="i \Rightarrow k">, а другая &mdash; <img class=tex src="../tex2png/cache/7862efc77aa20de70995ca3ed673a5c5.png" alt="k \Rightarrow j">), то каждая из этих половинок уже не заходит в вершину <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">. Но тогда получается, что длина каждой из этих половинок была посчитана ещё на <img class=tex src="../tex2png/cache/658627816b5be3d0859b8d0d52d03fd5.png" alt="k-1">-ой фазе или ещё раньше, и нам достаточно взять просто сумму <img class=tex src="../tex2png/cache/f80b03b45fc059b8067c9a4bf4000a9f.png" alt="d[i][k] + d[k][j]">, она и даст длину "нового" кратчайшего пути.<p></ul><p><b>Объединяя</b> эти два случая, получаем, что на <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ой фазе требуется пересчитать длины кратчайших путей между всеми парами вершин <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> следующим образом:<p><pre class="notranslate cpp">new_d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> min <span class="br0">&#40;</span>d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>, d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>k<span class="br0">&#93;</span> <span class="sy2">+</span> d<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p>Таким образом, вся работа, которую требуется произвести на <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ой фазе &mdash; это перебрать все пары вершин и пересчитать длину кратчайшего пути между ними. В результате после выполнения <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">-ой фазы в матрице расстояний <img class=tex src="../tex2png/cache/a18f11689b09b23faa10c78d6b244cf8.png" alt="d[i][j]"> будет записана длина кратчайшего пути между <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">, либо <img class=tex src="../tex2png/cache/3d40198f44abce2dbb7a7eb7fba559c9.png" alt="\infty">, если пути между этими вершинами не существует.<p>Последнее замечание, которое следует сделать, &mdash; то, что можно <b>не создавать отдельную матрицу</b> <img class=tex src="../tex2png/cache/75b834818921c36c13dca8194b7f05bb.png" alt="\rm new\_d[][]"> для временной матрицы кратчайших путей на <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-ой фазе: все изменения можно делать сразу в матрице <img class=tex src="../tex2png/cache/2108d8213526c488460c3eb1fe11c115.png" alt="d[][]">. В самом деле, если мы улучшили (уменьшили) какое-то значение в матрице расстояний, мы не могли ухудшить тем самым длину кратчайшего пути для каких-то других пар вершин, обработанных позднее.<p><b>Асимптотика</b> алгоритма, очевидно, составляет <img class=tex src="../tex2png/cache/ee6e2ce73ecd60d80d4fa8f04d0691e9.png" alt="O (n^3)">.<p><p><h2 style="padding-top:40px;"> Реализация </h2><p>На вход программе подаётся граф, заданный в виде матрицы смежности &mdash; двумерного массива <img class=tex src="../tex2png/cache/2108d8213526c488460c3eb1fe11c115.png" alt="d[][]"> размера <img class=tex src="../tex2png/cache/0fc9328e33c84faad487e059a12d8e47.png" alt="n \times n">, в котором каждый элемент задаёт длину ребра между соответствующими вершинами.<p>Требуется, чтобы выполнялось <img class=tex src="../tex2png/cache/7c1cc247371bc45cf832ce99833a985d.png" alt="d[i][i] = 0"> для любых <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">.<p><pre class="notranslate cpp"><span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> k<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> k<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>k<span class="br0">&#41;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> min <span class="br0">&#40;</span>d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>, d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>k<span class="br0">&#93;</span> <span class="sy2">+</span> d<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p>Предполагается, что если между двумя какими-то вершинами <b>нет ребра</b>, то в матрице смежности было записано какое-то большое число (достаточно большое, чтобы оно было больше длины любого пути в этом графе); тогда это ребро всегда будет невыгодно брать, и алгоритм сработает правильно.<p>Правда, если не принять специальных мер, то при наличии в графе рёбер <b>отрицательного веса</b>, в результирующей матрице могут появиться числа вида <img class=tex src="../tex2png/cache/adb7e2a1e5b54dd241c189b598c226f9.png" alt="\infty-1">, <img class=tex src="../tex2png/cache/549dbf00649114175e24015a551f3f9f.png" alt="\infty-2">, и т.д., которые, конечно, по-прежнему означают, что между соответствующими вершинами вообще нет пути. Поэтому при наличии в графе отрицательных рёбер алгоритм Флойда лучше написать так, чтобы он не выполнял переходы из тех состояний, в которых уже стоит "нет пути":<p><pre class="notranslate cpp"><span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> k<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> k<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>k<span class="br0">&#41;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>k<span class="br0">&#93;</span> <span class="sy1">&lt;</span> INF <span class="sy3">&amp;&amp;</span> d<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">&lt;</span> INF<span class="br0">&#41;</span>
				d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> min <span class="br0">&#40;</span>d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>, d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>k<span class="br0">&#93;</span> <span class="sy2">+</span> d<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span></pre><p><p><h2 style="padding-top:40px;"> Восстановление самих путей </h2><p>Легко поддерживать дополнительную информацию &mdash; так называемых "предков", по которым можно будет восстанавливать сам кратчайший путь между любыми двумя заданными вершинами <b>в виде последовательности вершин</b>.<p>Для этого достаточно кроме матрицы расстояний <img class=tex src="../tex2png/cache/2108d8213526c488460c3eb1fe11c115.png" alt="d[][]"> поддерживать также <b>матрицу предков</b> <img class=tex src="../tex2png/cache/901ba0328af44f1e788411ee0b571dbf.png" alt="p[][]">, которая для каждой пары вершин будет содержать номер фазы, на которой было получено кратчайшее расстояние между ними. Понятно, что этот номер фазы является не чем иным, как "средней" вершиной искомого кратчайшего пути, и теперь нам просто надо найти кратчайший путь между вершинами <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/e854116cbf31ec688fd19b8e883583c7.png" alt="p[i][j]">, а также между <img class=tex src="../tex2png/cache/e854116cbf31ec688fd19b8e883583c7.png" alt="p[i][j]"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">. Отсюда получается простой рекурсивный алгоритм восстановления кратчайшего пути.<p><p><h2 style="padding-top:40px;"> Случай вещественных весов </h2><p>Если веса рёбер графа не целочисленные, а вещественные, то следует учитывать погрешности, неизбежно возникающие при работе с типами с плавающей точкой.<p>Применительно к алгоритму Флойда неприятным спецэффектом этих погрешностей становится то, что найденные алгоритмом расстояния могут уйти сильно в минус из-за <b>накопившихся ошибок</b>. В самом деле, если на первой фазе имела место ошибка <img class=tex src="../tex2png/cache/b10959d13d437bdf88c1a3c489e71f65.png" alt="\Delta">, то на второй итерации эта ошибка уже может превратиться в <img class=tex src="../tex2png/cache/b17e0ce5f101cf8d0a369fed00ef2e2e.png" alt="2 \Delta">, на третьей &mdash; в <img class=tex src="../tex2png/cache/0af8ffa18bf44b10e43f806382efe84c.png" alt="4 \Delta">, и так далее.<p>Чтобы этого не происходило, сравнения в алгоритме Флойда следует делать с учётом погрешности:<p><pre class="notranslate cpp"><span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>k<span class="br0">&#93;</span> <span class="sy2">+</span> d<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">&lt;</span> d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy2">-</span> EPS<span class="br0">&#41;</span>
	d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span> <span class="sy1">=</span> d<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#91;</span>k<span class="br0">&#93;</span> <span class="sy2">+</span> d<span class="br0">&#91;</span>k<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="sy4">;</span></pre><p><p><h2 style="padding-top:40px;"> Случай отрицательных циклов </h2><p>Если в графе есть циклы отрицательного веса, то формально алгоритм Флойда-Уоршелла неприменим к такому графу.<p>На самом же деле, для тех пар вершин <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">, между которыми нельзя зайти в цикл отрицательного вес, алгоритм отработает корректно.<p>Для тех же пар вершин, ответа для которых не существует (по причине наличия отрицательного цикла на пути между ними), алгоритм Флойда найдёт в качестве ответа какое-то число (возможно, сильно отрицательное, но не обязательно). Тем не менее, можно улучшить алгоритм Флойда, чтобы он аккуратно обрабатывал такие пары вершин и выводил для них, например, <img class=tex src="../tex2png/cache/5cdfdf11fbe70e54c09d094363da793e.png" alt="- \infty">.<p>Для этого можно сделать, например, следующий <b>критерий</b> "не существования пути". Итак, пусть на данном графе отработал обычный алгоритм Флойда. Тогда между вершинами <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j"> не существует кратчайшего пути тогда и только тогда, когда найдётся такая вершина <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">, достижимая из <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и из которой достижима <img class=tex src="../tex2png/cache/f2761432c5377ee4ded848884be6d407.png" alt="j">, для которой выполняется <img class=tex src="../tex2png/cache/c8ea96b552e0695933b7ee26f6aae4db.png" alt="d[t][t] < 0">.<p>Кроме того, при использовании алгоритма Флойда для графов с отрицательными циклами следует помнить, что возникающие в процессе работы расстояния могут сильно уходить в минус, экспоненциально с каждой фазой. Поэтому следует принять меры против целочисленного переполнения, ограничив все расстояния снизу какой-нибудь величиной (например, <img class=tex src="../tex2png/cache/b713ae21124fd02234e62cfcffca4695.png" alt="- {\rm INF}">).<p>Более подробно об этой задаче см. отдельную статью: <a href="negative_cycle.html"><b>"Нахождение отрицательного цикла в графе"</b></a>.<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>