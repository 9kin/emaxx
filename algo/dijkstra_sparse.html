<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Нахождение кратчайших путей от заданной вершины до всех остальных вершин алгоритмом Дейкстры для разреженных графов за O (M log N)</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="../data/jquery.js"></script><script type="text/javascript" src="../data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php.html" >home</a></li><li><a href="index.html" class=current>algo</a></li><li><a href="../bookz/index.html" >bookz</a></li><li><a href="../forum/index.html" >forum</a></li><li><a href="../about.php.html" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 10 Jun 2008 19:32<br>редактировано: 9 Jul 2009 23:51</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="dijkstra_sparse.html#" id="contents-hide">[скрыть]</a><a href="dijkstra_sparse.html#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1>Нахождение кратчайших путей от заданной вершины до всех остальных вершин алгоритмом Дейкстры для разреженных графов</h1><p>Постановку задачи, алгоритм и его доказательство см. в <a href="dijkstra.html">статье об общем алгоритме Дейкстры</a>.<p><h2 style="padding-top:40px;">Алгоритм</h2><p>Напомним, что сложность алгоритма Дейкстры складывается из двух основных операций: время нахождения вершины с наименьшей величиной расстояния <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]">, и время совершения релаксации, т.е. время изменения величины <img class=tex src="../tex2png/cache/055ebcf2759a1e84a08f5a359acfc850.png" alt="d[to]">.<p>При простейшей реализации эти операции потребуют соответственно <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> и <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)"> времени. Учитывая, что первая операция всего выполняется <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)"> раз, а вторая &mdash; <img class=tex src="../tex2png/cache/baa7e0765a2f4f8991346c62c1279993.png" alt="O(m)">, получаем асимптотику простейшей реализации алгоритма Дейкстры: <img class=tex src="../tex2png/cache/9aebc5e297f3974d32c02a4777ec634f.png" alt="O(n^2+m)">.<p>Понятно, что эта асимптотика является оптимальной для плотных графов, т.е. когда <img class=tex src="../tex2png/cache/6bea08740553016113780ef33cb5ac6a.png" alt="m \approx n^2">. Чем более разрежен граф (т.е. чем меньше <img class=tex src="../tex2png/cache/4f70748eaed5e0c2c70d7e899166ee1d.png" alt="m"> по сравнению с максимальным количество рёбер <img class=tex src="../tex2png/cache/69c69118ca9294d5cdd0f79417241516.png" alt="n^2">), тем менее оптимальной становится эта оценка, и по вине первого слагаемого. Таким образом, надо улучшать время выполнения операций первого типа, не сильно ухудшая при этом время выполнения операций второго типа.<p>Для этого надо использовать различные вспомогательные структуры данных. Наиболее привлекательными являются <b>Фибоначчиевы кучи</b>, которые позволяют производить операцию первого вида за <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)">, а второго &mdash; за <img class=tex src="../tex2png/cache/817532dd84d4eb666e5d80dc58098e94.png" alt="O(1)">. Поэтому при использовании Фибоначчиевых куч время работы алгоритма Дейкстры составит <img class=tex src="../tex2png/cache/37dcafc425b78f1670ef9dcd12ac035a.png" alt="O(n \log n + m)">, что является практически теоретическим минимумом для алгоритма поиска кратчайшего пути. Кстати говоря, эта оценка является оптимальной для алгоритмов, основанных на алгоритме Дейкстры, т.е. Фибоначчиевы кучи являются оптимальными с этой точки зрения (это утверждение об оптимальности на самом деле основано на невозможности существования такой "идеальной" структуры данных &mdash; если бы она существовала, то можно было бы выполнять сортировку за линейное время, что, как известно, в общем случае невозможно; впрочем, интересно, что существует алгоритм Торупа (Thorup), который ищет кратчайший путь с оптимальной, линейной, асимптотикой, но основан он на совсем другой идее, чем алгоритм Дейкстры, поэтому никакого противоречия здесь нет). Однако, Фибоначчиевы кучи довольно сложны в реализации (и, надо отметить, имеют немалую константу, скрытую в асимптотике).<p>В качестве компромисса можно использовать структуры данных, позволяющие выполнять <b>оба типа операций</b> (фактически, это извлечение минимума и обновление элемента) за <img class=tex src="../tex2png/cache/a4b96f8bbb97a929331f6c1104787527.png" alt="O(\log n)">. Тогда время работы алгоритма Дейкстры составит:<p class=formula><img class=tex src="../tex2png/cache/87d2cbabc4290997c327a052e2fbbe67.png" alt=" O(n \log n + m \log n) = O (m \log n) "></p><p>В качестве такой структуры данных программистам на C++ удобно взять стандартный контейнер <img class=tex src="../tex2png/cache/69ee37dcc56b08d150f58c59e467f874.png" alt="\rm set"> или <img class=tex src="../tex2png/cache/b2804582df3f6ed1cf7188f980e4aa35.png" alt="\rm priority\_queue">. Первый основан на красно-чёрном дереве, второй &mdash; на бинарной куче. Поэтому <img class=tex src="../tex2png/cache/b2804582df3f6ed1cf7188f980e4aa35.png" alt="\rm priority\_queue"> имеет меньшую константу, скрытую в асимпотике, однако у него есть и недостаток: он не поддерживает операцию удаления элемента, из-за чего приходится делать "обходной манёвр", который фактически приводит к замене в асимптотике <img class=tex src="../tex2png/cache/6839f55793e4e69dcc7f4ca7caed0770.png" alt="\log n"> на <img class=tex src="../tex2png/cache/a70b4ea8ab5cf32a31cb2ecac114f464.png" alt="\log m"> (с точки зрения асимптотики это на самом деле ничего не меняет, но скрытую константу увеличивает).<p><h2 style="padding-top:40px;">Реализация</h2><p><h3 style="padding-top:15px;">set</h3><p>Начнём с контейнера <img class=tex src="../tex2png/cache/69ee37dcc56b08d150f58c59e467f874.png" alt="\rm set">. Поскольку в контейнере нам надо хранить вершины, упорядоченные по их величинам <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]">, то удобно в контейнер помещать пары: первый элемент пары &mdash; расстояние, а второй &mdash; номер вершины. В результате в <img class=tex src="../tex2png/cache/69ee37dcc56b08d150f58c59e467f874.png" alt="\rm set"> будут храниться пары, автоматически упорядоченные по расстояниям, что нам и нужно.<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> INF <span class="sy1">=</span> <span class="nu0">1000000000</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n<span class="sy4">;</span>
	... чтение n ...
	<span class="me1">vector</span> <span class="sy1">&lt;</span> vector <span class="sy1">&lt;</span> pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> <span class="sy1">&gt;</span> g <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
	... чтение графа ...
	<span class="kw4">int</span> s <span class="sy1">=</span> ...<span class="sy4">;</span> <span class="co1">// стартовая вершина</span>
&nbsp;
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> d <span class="br0">&#40;</span>n, INF<span class="br0">&#41;</span>,  p <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
	d<span class="br0">&#91;</span>s<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	set <span class="sy1">&lt;</span> pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> q<span class="sy4">;</span>
	q.<span class="me1">insert</span> <span class="br0">&#40;</span>make_pair <span class="br0">&#40;</span>d<span class="br0">&#91;</span>s<span class="br0">&#93;</span>, s<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy3">!</span>q.<span class="me1">empty</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> v <span class="sy1">=</span> q.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy2">-</span><span class="sy1">&gt;</span>second<span class="sy4">;</span>
		q.<span class="me1">erase</span> <span class="br0">&#40;</span>q.<span class="me1">begin</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> to <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">first</span>,
				len <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">second</span><span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> len <span class="sy1">&lt;</span> d<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				q.<span class="me1">erase</span> <span class="br0">&#40;</span>make_pair <span class="br0">&#40;</span>d<span class="br0">&#91;</span>to<span class="br0">&#93;</span>, to<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
				d<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> len<span class="sy4">;</span>
				p<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
				q.<span class="me1">insert</span> <span class="br0">&#40;</span>make_pair <span class="br0">&#40;</span>d<span class="br0">&#91;</span>to<span class="br0">&#93;</span>, to<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>В отличие от обычного алгоритма Дейкстры, становится ненужным массив <img class=tex src="../tex2png/cache/df09cae95940e511f8d96cbe8d9ad6b7.png" alt="u[]">. Его роль, как и функцию нахождения вершины с наименьшим расстоянием, выполняет <img class=tex src="../tex2png/cache/69ee37dcc56b08d150f58c59e467f874.png" alt="\rm set">. Изначально в него помещаем стартовую вершину <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> с её расстоянием. Основной цикл алгоритма выполняется, пока в очереди есть хоть одна вершина. Из очереди извлекается вершина с наименьшим расстоянием, и затем из неё выполняются релаксации. Перед выполнением каждой успешной релаксации мы сначала удаляем из <img class=tex src="../tex2png/cache/69ee37dcc56b08d150f58c59e467f874.png" alt="\rm set"> старую пару, а затем, после выполнения релаксации, добавляем обратно новую пару (с новым расстоянием <img class=tex src="../tex2png/cache/055ebcf2759a1e84a08f5a359acfc850.png" alt="d[to]">).<p><h3 style="padding-top:15px;">priority_queue</h3><p>Принципиально здесь отличий от <img class=tex src="../tex2png/cache/69ee37dcc56b08d150f58c59e467f874.png" alt="\rm set"> нет, за исключением того момента, что удалять из <img class=tex src="../tex2png/cache/b2804582df3f6ed1cf7188f980e4aa35.png" alt="\rm priority\_queue"> произвольные элементы невозможно (хотя теоретически кучи поддерживают такую операцию, в стандартной библиотеке она не реализована). Поэтому приходится совершать "обходной манёвр": при релаксации просто не будем удалять старые пары из очереди. В результате в очереди могут находиться одновременно несколько пар для одной и той же вершины (но с разными расстояниями). Среди этих пар нас интересует только одна, для которой элемент <img class=tex src="../tex2png/cache/c75bad783356a3e6214c4645811bb660.png" alt="\rm first"> равен <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]">, а все остальные являются фиктивными. Поэтому надо сделать небольшую модификацию: в начале каждой итерации, когда мы извлекаем из очереди очередную пару, будем проверять, фиктивная она или нет (для этого достаточно сравнить <img class=tex src="../tex2png/cache/c75bad783356a3e6214c4645811bb660.png" alt="\rm first"> и <img class=tex src="../tex2png/cache/1d6e1859e7756da32846240db3a97517.png" alt="d[v]">). Следует отметить, что это важная модификация: если не сделать её, то это приведёт к значительному ухудшению асимптотики (до <img class=tex src="../tex2png/cache/c4fa4086adf46462d07aa16071f709ef.png" alt="O(nm)">).<p>Ещё нужно помнить о том, что <img class=tex src="../tex2png/cache/b2804582df3f6ed1cf7188f980e4aa35.png" alt="\rm priority\_queue"> упорядочивает элементы по убыванию, а не по возрастанию, как обычно. Проще всего преодолеть эту особенность не указанием своего оператора сравнения, а просто помещая в качестве элементов <img class=tex src="../tex2png/cache/c75bad783356a3e6214c4645811bb660.png" alt="\rm first"> расстояния со знаком минус. В результате в корне кучи будут оказываться элементы с наименьшим расстоянием, что нам и нужно.<p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> INF <span class="sy1">=</span> <span class="nu0">1000000000</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> n<span class="sy4">;</span>
	... чтение n ...
	<span class="me1">vector</span> <span class="sy1">&lt;</span> vector <span class="sy1">&lt;</span> pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> <span class="sy1">&gt;</span> g <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
	... чтение графа ...
	<span class="kw4">int</span> s <span class="sy1">=</span> ...<span class="sy4">;</span> <span class="co1">// стартовая вершина</span>
&nbsp;
	vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> d <span class="br0">&#40;</span>n, INF<span class="br0">&#41;</span>,  p <span class="br0">&#40;</span>n<span class="br0">&#41;</span><span class="sy4">;</span>
	d<span class="br0">&#91;</span>s<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	priority_queue <span class="sy1">&lt;</span> pair<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">&gt;</span> q<span class="sy4">;</span>
	q.<span class="me1">push</span> <span class="br0">&#40;</span>make_pair <span class="br0">&#40;</span><span class="nu0">0</span>, s<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy3">!</span>q.<span class="me1">empty</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> v <span class="sy1">=</span> q.<span class="me1">top</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">second</span>,  cur_d <span class="sy1">=</span> <span class="sy2">-</span>q.<span class="me1">top</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">first</span><span class="sy4">;</span>
		q.<span class="me1">pop</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>cur_d <span class="sy1">&gt;</span> d<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span>  <span class="kw1">continue</span><span class="sy4">;</span>
&nbsp;
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> j<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> j<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> to <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">first</span>,
				len <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>j<span class="br0">&#93;</span>.<span class="me1">second</span><span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> len <span class="sy1">&lt;</span> d<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				d<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> len<span class="sy4">;</span>
				p<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> v<span class="sy4">;</span>
				q.<span class="me1">push</span> <span class="br0">&#40;</span>make_pair <span class="br0">&#40;</span><span class="sy2">-</span>d<span class="br0">&#91;</span>to<span class="br0">&#93;</span>, to<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><p>Как правило, на практике версия с <img class=tex src="../tex2png/cache/b2804582df3f6ed1cf7188f980e4aa35.png" alt="\rm priority\_queue"> оказывается несколько быстрее версии с <img class=tex src="../tex2png/cache/69ee37dcc56b08d150f58c59e467f874.png" alt="\rm set">.<p><h3 style="padding-top:15px;">Избавление от pair</h3><p>Можно ещё немного улучшить производительность, если в контейнерах всё же хранить не пары, а только номера вершин. При этом, понятно, надо перегрузить оператор сравнения для вершин: сравнивать две вершины надо по расстояниям до них <img class=tex src="../tex2png/cache/192f42354669dea1048458208212e4d4.png" alt="d[]">.<p>Поскольку в результате релаксации величина расстояния до какой-то вершины меняется, то надо понимать, что "сама по себе" структура данных не перестроится. Поэтому, хотя может показаться, что удалять/добавлять элементы в контейнер в процессе релаксации не надо, это приведёт к разрушению структуры данных. По-прежнему перед релаксацией надо удалить из структуры данных вершину <img class=tex src="../tex2png/cache/f7896bcdbeaef5c80849d97eecb4b8bb.png" alt="\rm to">, а после релаксации вставить её обратно &mdash; тогда никакие соотношения между элементами структуры данных не нарушатся.<p>А поскольку удалять элементы можно из <img class=tex src="../tex2png/cache/69ee37dcc56b08d150f58c59e467f874.png" alt="\rm set">, но нельзя из <img class=tex src="../tex2png/cache/b2804582df3f6ed1cf7188f980e4aa35.png" alt="\rm priority\_queue">, то получается, что этот приём применим только к <img class=tex src="../tex2png/cache/69ee37dcc56b08d150f58c59e467f874.png" alt="\rm set">. На практике он заметно увеличивает производительность, особенно когда для хранения расстояний используются большие типы данных (как <img class=tex src="../tex2png/cache/efb3ef3a7a831fc4c1d31cbb3a79c4ea.png" alt="\rm long\ long"> или <img class=tex src="../tex2png/cache/e3c90d372cb9ff8842ac670838fe210c.png" alt="\rm double">).<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>